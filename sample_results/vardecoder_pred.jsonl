{"input": "What are the original name and data type of variables `a1`, `a2`, `s1`, `v4`?\n```\n__int64 __fastcall sub_409FD9(__int64 a1, const void *a2)\n{\n__int64 result; // rax\nchar s1[28]; // [rsp+10h] [rbp-20h] BYREF\nunsigned int v4; // [rsp+2Ch] [rbp-4h]\n\nsub_408A49((__int64)s1, (int *)(a1 + 288));\nv4 = memcmp(s1, a2, 0x14uLL);\nif ( v4 )\n{\nsub_408A49((__int64)s1, (int *)(a1 + 380));\nv4 = memcmp(s1, a2, 0x14uLL);\nif ( !v4 )\n{\nsub_408919((int *)(a1 + 196), s1, 0x14u);\nsub_408919((int *)(a1 + 196), (char *)(a1 + 472), 0x28u);\nsub_408A49(a1 + 512, (int *)(a1 + 196));\n}\nresult = v4;\n}\nelse\n{\nsub_408A49(a1 + 512, (int *)(a1 + 104));\nresult = 0LL;\n}\nreturn result;\n}\n```", "output": "a1: ts, t_server*\na2: resp, unsigned char*\ns1: expected, unsigned char[20]\nv4: i, int", "predict": "a1: ts, t_server*\na2: resp, unsigned char*\ns1: expected, unsigned char[20]\nv4: i, int", "funname": "t_serververify", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "409FD9"}
{"input": "What are the original name and data type of variables `i`?\n```\n__int64 sub_403EFA()\n{\n__int64 result; // rax\n__int64 i; // [rsp+8h] [rbp-8h]\n\nsub_406293(sub_403ECE, 0LL);\nresult = qword_414820;\nfor ( i = qword_414820; (__int64 *)i != &qword_414820; i = *(_QWORD *)i )\n{\nif ( *(_BYTE *)(i + 53) )\n{\n*(_BYTE *)(i + 53) = 0;\n}\nelse if ( *(_BYTE *)(i + 37) )\n{\n*(_BYTE *)(i + 37) = 0;\nsub_403D53((__pid_t *)i, 0);\n}\nresult = *(_QWORD *)i;\n}\nreturn result;\n}\n```", "output": "i: p, list_head*", "predict": "i: p, list_head*", "funname": "check_all_interfaces", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403EFA"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n__int64 __fastcall sub_4025E8(__int64 a1, unsigned int a2)\n{\nreturn a2;\n}\n```", "output": "a1: p, pcap_t*\na2: rx, _Bool", "predict": "a1: address, uint16_t\na2: data, uint8_t", "funname": "set_recv_type", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4025E8"}
{"input": "What are the original name and data type of variables `stat_loc`?\n```\nvoid handler()\n{\n__WAIT_STATUS stat_loc; // [rsp+1Ch] [rbp-4h] BYREF\n\nLODWORD(stat_loc.__uptr) = 0;\nwait((__WAIT_STATUS)&stat_loc);\nbyte_4145A0 = 0;\n}\n```", "output": "stat_loc: pid, int", "predict": "stat_loc: pid, int", "funname": "instance_handle_sigchld", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403C15"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n_QWORD *__fastcall sub_402582(_QWORD *a1, __int64 a2)\n{\n_QWORD *result; // rax\n\n*(_QWORD *)(a2 + 8) = a1;\nresult = a1;\n*a1 = a2;\nreturn result;\n}\n```", "output": "a1: prev, list_head*\na2: next, list_head*", "predict": "a1: prev, const list_head*\na2: next, const list_head*", "funname": "__list_del", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402582"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\nvoid __fastcall sub_403D53(__pid_t *a1, char a2)\n{\nif ( a1[8] > 0 )\nkill(a1[8], 9);\na1[8] = 0;\nif ( a2 )\n{\nsub_4025A8((__int64)a1);\nfree(a1);\n}\n}\n```", "output": "a1: in, ead_instance*\na2: do_free, _Bool", "predict": "a1: in, ead_instance*\na2: do_free, _Bool", "funname": "stop_server", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403D53"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n__int64 __fastcall sub_40CE13(__int64 a1, __int64 a2)\n{\nbool v2; // al\n\nif ( *(_DWORD *)(a1 + 12) )\nv2 = a1 == 0;\nelse\nv2 = sub_40C9FA(a1, 2) == 0;\nif ( v2 )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 0;\n*(_DWORD *)(a1 + 8) = 0;\n**(_QWORD **)a1 = a2;\nif ( **(_QWORD **)a1 )\n*(_DWORD *)(a1 + 8) = 1;\nreturn 1LL;\n}\n```", "output": "a1: a, BIGNUM*\na2: w, long unsigned int", "predict": "a1: a, BIGNUM*\na2: w, long unsigned int", "funname": "BN_set_word", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40CE13"}
{"input": "What are the original name and data type of variables `v1`, `v2`, `v3`?\n```\n__int64 sub_402EC2()\n{\nchar *v1; // [rsp+28h] [rbp-18h]\nchar *v2; // [rsp+30h] [rbp-10h]\nint v3; // [rsp+3Ch] [rbp-4h]\n\nv2 = (char *)off_4132D8 + 42;\nv1 = (char *)off_4132D8 + 62;\nv3 = strlen(src);\nif ( v3 > 1024 )\nv3 = 1024;\n*((_DWORD *)v2 + 1) = htonl(v3 + 2);\nstrncpy(v1 + 2, src, v3);\nv1[v3 + 2] = 0;\n*(_WORD *)v1 = htons(1u);\nreturn 1LL;\n}\n```", "output": "v1: pong, ead_msg_pong*\nv2: msg, ead_msg*\nv3: slen, int", "predict": "v1: pong, ead_msg_pong*\nv2: msg, ead_msg*\nv3: slen, int", "funname": "handle_ping", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402EC2"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v3`, `v4`, `i`?\n```\n_DWORD *__fastcall sub_4046D3(int *a1, unsigned __int8 *a2)\n{\n_DWORD *result; // rax\nint *v3; // [rsp+8h] [rbp-18h]\nunsigned int v4; // [rsp+18h] [rbp-8h]\nint i; // [rsp+1Ch] [rbp-4h]\n\nv3 = a1;\n*a1 = a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24);\na1[1] = (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24) ^ a2[7];\na1[2] = (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24) ^ a2[11];\nresult = a1 + 3;\na1[3] = (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24) ^ a2[15];\nfor ( i = 0; i <= 9; ++i )\n{\nv4 = v3[3];\nv3[4] = ((unsigned __int8)byte_40FDC0[i] << 24) ^ (unsigned __int8)BYTE1(dword_40F4C0[HIBYTE(v4)]) ^ dword_40F4C0[(unsigned __int8)v4] & 0xFF00 ^ dword_40F4C0[BYTE1(v4)] & 0xFF0000 ^ (dword_40F4C0[BYTE2(v4)] << 8) & 0xFF000000 ^ *v3;\nv3[5] = v3[1] ^ v3[4];\nv3[6] = v3[2] ^ v3[5];\nresult = v3 + 7;\nv3[7] = v3[3] ^ v3[6];\nv3 += 4;\n}\nreturn result;\n}\n```", "output": "a1: rk, u32*\na2: cipherKey, const u8*\nv3: rk, u32*\nv4: temp, u32\ni: i, int", "predict": "a1: rk, u32*\na2: cipherKey, const u8*\nv3: rk, u32*\nv4: temp, u32\ni: i, int", "funname": "rijndaelKeySetupEnc", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4046D3"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v6`, `v10`, `k`, `j`?\n```\n__int64 __fastcall sub_40493E(int *a1, unsigned __int8 *a2)\n{\nint v2; // ebx\nint v3; // ebx\nint v4; // ebx\n__int64 result; // rax\nint *v6; // [rsp+8h] [rbp-20h]\nint v7; // [rsp+10h] [rbp-18h]\nint v8; // [rsp+10h] [rbp-18h]\nint v9; // [rsp+10h] [rbp-18h]\nint v10; // [rsp+10h] [rbp-18h]\nint i; // [rsp+18h] [rbp-10h]\nint k; // [rsp+18h] [rbp-10h]\nint v13; // [rsp+1Ch] [rbp-Ch]\nint j; // [rsp+1Ch] [rbp-Ch]\n\nv6 = a1;\nsub_4046D3(a1, a2);\nv13 = 0;\nfor ( i = 40; v13 < i; i -= 4 )\n{\nv7 = a1[v13];\na1[v13] = a1[i];\na1[i] = v7;\nv8 = a1[v13 + 1];\na1[v13 + 1] = a1[i + 1];\na1[i + 1] = v8;\nv9 = a1[v13 + 2];\na1[v13 + 2] = a1[i + 2];\na1[i + 2] = v9;\nv10 = a1[v13 + 3];\na1[v13 + 3] = a1[i + 3];\na1[i + 3] = v10;\nv13 += 4;\n}\nfor ( j = 1; ; ++j )\n{\nresult = (unsigned int)j;\nif ( j >= 10 )\nbreak;\nv6 += 4;\nfor ( k = 0; k <= 3; ++k )\n{\nv2 = dword_40F8C0[(unsigned __int8)BYTE1(dword_40F4C0[HIBYTE(v6[k])])];\nv3 = sub_4046BB(dword_40F8C0[(unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)BYTE2(v6[k])])], 8) ^ v2;\nv4 = sub_4046BB(dword_40F8C0[(unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)BYTE1(v6[k])])], 16) ^ v3;\nv6[k] = v4 ^ sub_4046BB(dword_40F8C0[(unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v6[k]])], 24);\n}\n}\nreturn result;\n}\n```", "output": "a1: rk, u32*\na2: cipherKey, const u8*\nv6: rk, u32*\nv10: temp, u32\nk: j, int\nj: i, int", "predict": "a1: rk, u32*\na2: cipherKey, const u8*\nv6: rk, u32*\nv10: temp, u32\nk: j, int\nj: i, int", "funname": "rijndaelKeySetupDec", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40493E"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `n`?\n```\nunsigned __int64 __fastcall sub_409306(char *a1, unsigned int a2)\n{\nunsigned __int64 result; // rax\nunsigned int n; // [rsp+4h] [rbp-Ch]\n\nn = a2;\nresult = (unsigned __int8)byte_415164;\nif ( !byte_415164 )\nresult = sub_4091A7();\nif ( a2 )\n{\nwhile ( 1 )\n{\nresult = (unsigned int)::n;\nif ( n <= (unsigned int)::n )\nbreak;\nif ( (_DWORD)::n )\n{\nmemcpy(a1, (char *)&unk_415140 + 20LL - (unsigned int)::n, (unsigned int)::n);\na1 += (unsigned int)::n;\nn -= ::n;\n}\nsub_4088BF(dword_4150C0);\nsub_408919(dword_4150C0, byte_415120, 0x14u);\nsub_408A49((__int64)&unk_415140, dword_4150C0);\nsub_4088BF(dword_4150C0);\nsub_408919(dword_4150C0, (char *)&qword_415158, 8u);\nsub_408919(dword_4150C0, byte_415120, 0x14u);\nsub_408A49((__int64)byte_415120, dword_4150C0);\n++qword_415158;\nLODWORD(::n) = 20;\n}\nif ( n )\n{\nmemcpy(a1, (char *)&unk_415140 + 20LL - (unsigned int)::n, n);\nresult = (unsigned int)::n - n;\nLODWORD(::n) = ::n - n;\n}\n}\nreturn result;\n}\n```", "output": "a1: data, unsigned char*\na2: size, unsigned int\nn: size, unsigned int", "predict": "a1: data, unsigned char*\na2: size, unsigned int\nn: size, unsigned int", "funname": "t_random", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "409306"}
{"input": "What are the original name and data type of variables `a1`, `i`?\n```\nvoid __fastcall sub_40AA9A(_DWORD *a1)\n{\nint i; // [rsp+1Ch] [rbp-4h]\n\nif ( a1 )\n{\nfor ( i = 0; i <= 11; ++i )\nsub_40C867(&a1[6 * i + 2]);\nif ( (a1[74] & 1) != 0 )\nfree(a1);\n}\n}\n```", "output": "a1: ctx, BN_CTX*\ni: i, int", "predict": "a1: ctx, BN_CTX*\ni: i, int", "funname": "BN_CTX_free", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40AA9A"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_405DB9(unsigned int a1)\n{\nif ( a1 <= dword_414EF0 )\nreturn 0LL;\nif ( a1 > dword_414EF0 + 128 )\nreturn 0LL;\ndword_414EF0 = a1;\nreturn 1LL;\n}\n```", "output": "a1: iv, uint32_t", "predict": "a1: iv, uint32_t", "funname": "ead_check_rx_iv", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405DB9"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v5`?\n```\n__int64 __fastcall sub_408CEA(__int64 a1, __int64 a2, unsigned int a3)\n{\n__int64 v5; // [rsp+28h] [rbp-8h]\n\nv5 = sub_40C999();\nsub_40CE13(v5, a3);\nsub_40A34C(a1, a2, v5);\nreturn sub_40C906(v5);\n}\n```", "output": "a1: result, BigInteger*\na2: a1, BigInteger*\na3: a2, unsigned int\nv5: a, BIGNUM*", "predict": "a1: result, BigInteger*\na2: a1, BigInteger*\na3: a2, unsigned int\nv5: a, BIGNUM*", "funname": "BigIntegerAddInt", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408CEA"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `v8`, `v9`, `v10`, `v11`, `i`?\n```\nunsigned __int64 __fastcall sub_40D606(unsigned __int64 *a1, unsigned __int64 *a2, int a3, unsigned __int64 *a4)\n{\nunsigned __int64 *v4; // rax\nint v8; // [rsp+24h] [rbp-2Ch]\nunsigned __int64 *v9; // [rsp+28h] [rbp-28h]\nunsigned __int64 *v10; // [rsp+30h] [rbp-20h]\nint v11; // [rsp+38h] [rbp-18h]\nint i; // [rsp+3Ch] [rbp-14h]\n\nv8 = 2 * a3;\nv10 = a2;\nv4 = &a1[2 * a3 - 1];\n*v4 = 0LL;\n*a1 = *v4;\nv9 = a1 + 1;\nv11 = a3 - 1;\nif ( a3 - 1 > 0 )\n{\nv10 = a2 + 1;\nv9[v11] = sub_40BB0A(v9, a2 + 1, v11, *a2);\nv9 = a1 + 3;\n}\nfor ( i = a3 - 2; i > 0; --i )\n{\n--v11;\n++v10;\nv9[v11] = sub_40B510(v9, v10, v11, *(v10 - 1));\nv9 += 2;\n}\nsub_40C4C7(a1, a1, a1, v8);\nsub_40C061(a4, a2, a3);\nreturn sub_40C4C7(a1, a1, a4, v8);\n}\n```", "output": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: n, int\na4: tmp, long unsigned int*\nv8: max, int\nv9: rp, long unsigned int*\nv10: ap, long unsigned int*\nv11: j, int\ni: i, int", "predict": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: n, int\na4: tmp, long unsigned int*\nv8: max, int\nv9: rp, long unsigned int*\nv10: ap, long unsigned int*\nv11: j, int\ni: i, int", "funname": "bn_sqr_normal", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D606"}
{"input": "What are the original name and data type of variables `a1`, `v3`, `dest`, `i`?\n```\n__int64 __fastcall sub_408EF8(__int64 a1)\n{\nunsigned int v1; // eax\nint v3[24]; // [rsp+10h] [rbp-170h] BYREF\nchar dest[264]; // [rsp+70h] [rbp-110h] BYREF\nchar **i; // [rsp+178h] [rbp-8h]\n\nsub_4088BF(v3);\nfor ( i = environ; *i; ++i )\n{\nstrncpy(dest, *i, 0xFFuLL);\ndest[255] = 0;\nv1 = strlen(dest);\nsub_408919(v3, dest, v1);\n}\nreturn sub_408A49(a1, v3);\n}\n```", "output": "a1: out, unsigned char*\nv3: ctxt, struct SHA1_CTX\ndest: ebuf, char[256]\ni: ptr, char**", "predict": "a1: out, unsigned char*\nv3: ctxt, struct SHA1_CTX\ndest: ebuf, char[256]\ni: ptr, char**", "funname": "t_envhash", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408EF8"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v6`, `s`, `ptr`, `size`?\n```\n__int64 __fastcall sub_409462(__int64 a1, _BYTE *a2, unsigned int a3)\n{\nint v6[24]; // [rsp+20h] [rbp-90h] BYREF\nchar s[32]; // [rsp+80h] [rbp-30h] BYREF\nvoid *ptr; // [rsp+A0h] [rbp-10h]\nsize_t size; // [rsp+A8h] [rbp-8h]\n\nwhile ( a3 && !*a2 )\n{\n--a3;\n++a2;\n}\nLODWORD(size) = a3 >> 1;\nptr = malloc(a3 >> 1);\nif ( !ptr )\nreturn 0LL;\nfor ( HIDWORD(size) = 0; HIDWORD(size) < (unsigned int)size; ++HIDWORD(size) )\n*((_BYTE *)ptr + HIDWORD(size)) = a2[a3 - 2 * HIDWORD(size) - 1];\nsub_4088BF(v6);\nsub_408919(v6, (char *)ptr, size);\nsub_408A49((__int64)s, v6);\nfor ( HIDWORD(size) = 0; HIDWORD(size) <= 0x13; ++HIDWORD(size) )\n*(_BYTE *)(a1 + (unsigned int)(2 * HIDWORD(size))) = s[HIDWORD(size)];\nfor ( HIDWORD(size) = 0; HIDWORD(size) < (unsigned int)size; ++HIDWORD(size) )\n*((_BYTE *)ptr + HIDWORD(size)) = a2[a3 - 2 * HIDWORD(size) - 2];\nsub_4088BF(v6);\nsub_408919(v6, (char *)ptr, size);\nsub_408A49((__int64)s, v6);\nfor ( HIDWORD(size) = 0; HIDWORD(size) <= 0x13; ++HIDWORD(size) )\n*(_BYTE *)(a1 + (unsigned int)(2 * HIDWORD(size) + 1)) = s[HIDWORD(size)];\nmemset(s, 0, 0x14uLL);\nmemset(ptr, 0, (unsigned int)size);\nfree(ptr);\nreturn a1;\n}\n```", "output": "a1: key, unsigned char*\na2: sk, unsigned char*\na3: sklen, unsigned int\nv6: ctxt, struct SHA1_CTX\ns: hout, unsigned char[20]\nptr: hbuf, unsigned char*\nsize: klen, unsigned int", "predict": "a1: key, unsigned char*\na2: sk, unsigned char*\na3: sklen, unsigned int\nv6: ctxt, struct SHA1_CTX\ns: hout, unsigned char[20]\nptr: hbuf, unsigned char*\nsize: klen, unsigned int", "funname": "t_sessionkey", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "409462"}
{"input": "What are the original name and data type of variables `v4`, `ptr`, `v7`, `v8`, `v13`?\n```\n__int64 __fastcall sub_4067D8(void *dest, char *s)\n{\nchar *v4; // [rsp+0h] [rbp-30h]\n_BYTE *ptr; // [rsp+8h] [rbp-28h]\nunsigned int v6; // [rsp+14h] [rbp-1Ch]\nunsigned int v7; // [rsp+14h] [rbp-1Ch]\nunsigned int v8; // [rsp+18h] [rbp-18h]\nunsigned int i; // [rsp+1Ch] [rbp-14h]\nint v10; // [rsp+1Ch] [rbp-14h]\nint v11; // [rsp+1Ch] [rbp-14h]\nint v12; // [rsp+1Ch] [rbp-14h]\nint v13; // [rsp+1Ch] [rbp-14h]\n\nwhile ( *s && (*s == 32 || *s == 9 || *s == 10) )\n++s;\nv6 = strlen(s);\nptr = malloc(v6 + 1);\nif ( !ptr )\nreturn 0xFFFFFFFFLL;\nfor ( i = 0; v6 > i; ++i )\n{\nv4 = strchr(a0123456789abcd, s[i]);\nif ( !v4 )\nbreak;\nptr[i] = v4 - a0123456789abcd;\n}\nv7 = i;\nv10 = i - 1;\nv8 = v7;\ndo\n{\nptr[v8] = ptr[v10];\nv11 = v10 - 1;\nif ( v11 < 0 )\nbreak;\nptr[v8--] |= ptr[v11] << 6;\nptr[v8] = ((int)(unsigned __int8)ptr[v11] >> 2) & 0xF;\nv12 = v11 - 1;\nif ( v12 < 0 )\nbreak;\nptr[v8--] |= 16 * ptr[v12];\nptr[v8] = ((int)(unsigned __int8)ptr[v12] >> 4) & 3;\nv13 = v12 - 1;\nif ( v13 < 0 )\nbreak;\nptr[v8--] |= 4 * ptr[v13];\nptr[v8] = 0;\nv10 = v13 - 1;\n}\nwhile ( v10 >= 0 );\nwhile ( v7 >= v8 && !ptr[v8] )\n++v8;\nmemcpy(dest, &ptr[v8], v7 - v8 + 1);\nfree(ptr);\nreturn v7 - v8 + 1;\n}\n```", "output": "v4: loc, char*\nptr: a, unsigned char*\nv7: size, unsigned int\nv8: j, int\nv13: i, int", "predict": "v4: loc, char*\nptr: a, unsigned char*\nv7: size, unsigned int\nv8: j, int\nv13: i, int", "funname": "t_fromb64", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4067D8"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`?\n```\n__int16 __fastcall sub_403889(__int64 a1, __int64 a2, __int64 a3)\n{\nunsigned __int64 v3; // rax\nint v4; // ebx\nint v5; // ebx\nint v6; // ebx\nunsigned __int64 v7; // rbx\nint v8; // ebx\n\nLODWORD(v3) = *(_DWORD *)(a2 + 20);\nif ( (unsigned int)v3 > 0x3D )\n{\nv4 = *(unsigned __int16 *)(a3 + 12);\nLOWORD(v3) = htons(0x800u);\nif ( v4 == (_DWORD)v3 )\n{\nLODWORD(v3) = memcmp((const void *)a3, &unk_40F1C8, 6uLL);\nif ( !(_DWORD)v3 )\n{\nLOWORD(v3) = *(unsigned __int8 *)(a3 + 23);\nif ( (_BYTE)v3 == 17 )\n{\nv5 = *(unsigned __int16 *)(a3 + 36);\nLOWORD(v3) = htons(0xDADAu);\nif ( v5 == (_DWORD)v3 )\n{\nv6 = *(_DWORD *)(a3 + 42);\nLODWORD(v3) = htonl(0xDADACAFE);\nif ( v6 == (_DWORD)v3 )\n{\nv7 = *(unsigned int *)(a2 + 20);\nv3 = (int)ntohl(*(_DWORD *)(a3 + 46)) + 62LL;\nif ( v7 >= v3 )\n{\nif ( *(_WORD *)(a3 + 54) == 0xFFFF\n|| (v8 = *(unsigned __int16 *)(a3 + 54), LOWORD(v3) = htons(word_4132E0), v8 == (_DWORD)v3) )\n{\nLOWORD(v3) = sub_4036C6(a3, *(_DWORD *)(a2 + 20));\n}\n}\n}\n}\n}\n}\n}\n}\nreturn v3;\n}\n```", "output": "a1: user, u_char*\na2: h, const pcap_pkthdr*\na3: bytes, const u_char*", "predict": "a1: user, u_char*\na2: h, const pcap_pkthdr*\na3: bytes, const u_char*", "funname": "handle_packet", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403889"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v6`, `v7`, `v8`?\n```\n__int64 __fastcall sub_402AAD(unsigned __int16 a1, unsigned __int8 *a2, unsigned __int16 a3)\n{\nunsigned __int16 v5; // [rsp+1Eh] [rbp-12h]\nunsigned __int16 v6; // [rsp+1Eh] [rbp-12h]\nunsigned __int8 *v7; // [rsp+20h] [rbp-10h]\nunsigned __int8 *v8; // [rsp+28h] [rbp-8h]\n\nv8 = a2;\nv7 = &a2[a3 - 1];\nwhile ( v8 < v7 )\n{\nv5 = (*v8 << 8) + v8[1];\na1 += v5;\nif ( a1 < v5 )\n++a1;\nv8 += 2;\n}\nif ( v8 == v7 )\n{\nv6 = *v8 << 8;\na1 += v6;\nif ( a1 < v6 )\n++a1;\n}\nreturn a1;\n}\n```", "output": "a1: sum, u16_t\na2: data, const u8_t*\na3: len, u16_t\nv6: t, u16_t\nv7: last_byte, const u8_t*\nv8: dataptr, const u8_t*", "predict": "a1: sum, u16_t\na2: len, u16_t\na3: data, const u8_t*\nv6: t, u16_t\nv7: last_byte, const u8_t*\nv8: dataptr, const u8_t*", "funname": "chksum", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402AAD"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v3`?\n```\n__int64 __fastcall sub_408BEE(__int64 a1, unsigned int a2)\n{\n__int64 v3; // [rsp+18h] [rbp-8h]\n\nv3 = sub_40C999();\nsub_40CF0A(a1, a2, v3);\nreturn v3;\n}\n```", "output": "a1: bytes, unsigned char*\na2: length, int\nv3: a, BIGNUM*", "predict": "a1: bytes, unsigned char*\na2: length, int\nv3: a, BIGNUM*", "funname": "BigIntegerFromBytes", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408BEE"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v6`, `v7`, `v8`, `v9`?\n```\n__int64 __fastcall sub_40A857(__int64 a1, __int64 a2, __int64 a3)\n{\n__int64 result; // rax\nsigned int v4; // eax\nbool v5; // al\n__int64 v6; // [rsp+8h] [rbp-38h]\n__int64 v7; // [rsp+10h] [rbp-30h]\nint v8; // [rsp+38h] [rbp-8h]\nint v9; // [rsp+3Ch] [rbp-4h]\n\nv7 = a2;\nv6 = a3;\nv9 = 0;\nv8 = 0;\nif ( *(_DWORD *)(a2 + 16) )\n{\nif ( *(_DWORD *)(a3 + 16) )\n{\nv7 = a3;\nv6 = a2;\n}\nelse\n{\nv9 = 1;\nv8 = 1;\n}\n}\nelse if ( *(_DWORD *)(a3 + 16) )\n{\nv9 = 1;\nv8 = 0;\n}\nif ( v9 )\n{\nif ( (unsigned int)sub_40A462((__int64 *)a1, (__int64 *)v7, (__int64 *)v6) )\n{\n*(_DWORD *)(a1 + 16) = v8;\nresult = 1LL;\n}\nelse\n{\nresult = 0LL;\n}\n}\nelse\n{\nv4 = *(_DWORD *)(v7 + 8);\nif ( *(_DWORD *)(v6 + 8) >= v4 )\nv4 = *(_DWORD *)(v6 + 8);\nif ( v4 <= *(_DWORD *)(a1 + 12) )\nv5 = a1 == 0;\nelse\nv5 = sub_40C9FA(a1, (unsigned int)v4) == 0;\nif ( v5 )\nreturn 0LL;\nif ( (int)sub_40D158(v7, v6) >= 0 )\n{\nif ( !(unsigned int)sub_40A626(a1, v7, v6) )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 0;\n}\nelse\n{\nif ( !(unsigned int)sub_40A626(a1, v6, v7) )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 1;\n}\nresult = 1LL;\n}\nreturn result;\n}\n```", "output": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: b, const BIGNUM*\nv6: b, const BIGNUM*\nv7: a, const BIGNUM*\nv8: neg, int\nv9: add, int", "predict": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: b, const BIGNUM*\nv6: b, const BIGNUM*\nv7: a, const BIGNUM*\nv8: neg, int\nv9: add, int", "funname": "BN_sub", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A857"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n__int64 __fastcall sub_4046BB(int a1, char a2)\n{\nreturn (unsigned int)__ROR4__(a1, a2);\n}\n```", "output": "a1: val, u32\na2: bits, int", "predict": "a1: val, u32\na2: bits, int", "funname": "rotr", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4046BB"}
{"input": "What are the original name and data type of variables `a1`?\n```\nvoid *__fastcall sub_40C974(void *a1)\n{\nreturn memset(a1, 0, 0x18uLL);\n}\n```", "output": "a1: a, BIGNUM*", "predict": "a1: a, BIGNUM*", "funname": "BN_init", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C974"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n__int64 __fastcall sub_40D358(__int64 a1, int a2)\n{\nif ( a2 < 0 )\nreturn 0LL;\nif ( a2 / 64 < *(_DWORD *)(a1 + 8) )\nreturn (*(_QWORD *)(*(_QWORD *)a1 + 8LL * (a2 / 64)) >> (a2 % 64)) & 1LL;\nreturn 0LL;\n}\n```", "output": "a1: a, const BIGNUM*\na2: n, int", "predict": "a1: a, const BIGNUM*\na2: n, int", "funname": "BN_is_bit_set", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D358"}
{"input": "What are the original name and data type of variables `a1`, `v2`?\n```\n__int64 __fastcall sub_40C804(__int64 a1)\n{\nint v2; // [rsp+Ch] [rbp-Ch]\n\nif ( !*(_DWORD *)(a1 + 8) )\nreturn 0LL;\nv2 = (*(_DWORD *)(a1 + 8) - 1) << 6;\nreturn v2 + (unsigned int)sub_40C6B5(*(_QWORD *)(*(_QWORD *)a1 + 8LL * *(int *)(a1 + 8) - 8));\n}\n```", "output": "a1: a, const BIGNUM*\nv2: i, int", "predict": "a1: a, const BIGNUM*\nv2: i, int", "funname": "BN_num_bits", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C804"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`?\n```\n__int64 __fastcall sub_408D3E(__int64 a1, __int64 a2, __int64 a3)\n{\nreturn sub_40A857(a1, a2, a3);\n}\n```", "output": "a1: result, BigInteger*\na2: s1, BigInteger*\na3: s2, BigInteger*", "predict": "a1: result, BigInteger*\na2: s1, BigInteger*\na3: s2, BigInteger*", "funname": "BigIntegerSub", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408D3E"}
{"input": "What are the original name and data type of variables `a1`, `v2`?\n```\n__int64 __fastcall sub_408BC2(unsigned int a1)\n{\n__int64 v2; // [rsp+18h] [rbp-8h]\n\nv2 = sub_40C999();\nsub_40CE13(v2, a1);\nreturn v2;\n}\n```", "output": "a1: n, unsigned int\nv2: a, BIGNUM*", "predict": "a1: n, unsigned int\nv2: a, BIGNUM*", "funname": "BigIntegerFromInt", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408BC2"}
{"input": "What are the original name and data type of variables `v0`, `v1`?\n```\nvoid __noreturn sub_403DAE()\n{\n__pid_t *v0; // [rsp+20h] [rbp-10h]\n__pid_t *v1; // [rsp+28h] [rbp-8h]\n\nv1 = (__pid_t *)qword_414820;\nv0 = *(__pid_t **)qword_414820;\nwhile ( v1 != (__pid_t *)&qword_414820 )\n{\nsub_403D53(v1, 1);\nv1 = v0;\nv0 = *(__pid_t **)v0;\n}\nexit(1);\n}\n```", "output": "v0: tmp, list_head*\nv1: p, list_head*", "predict": "v0: tmp, list_head*\nv1: p, list_head*", "funname": "server_handle_sigint", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403DAE"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v5`, `v6`?\n```\n__int64 __fastcall sub_408D6C(__int64 a1, __int64 a2, unsigned int a3)\n{\n__int64 v5; // [rsp+20h] [rbp-10h]\n__int64 v6; // [rsp+28h] [rbp-8h]\n\nv6 = sub_40A9D9();\nv5 = sub_40C999();\nsub_40CE13(v5, a3);\nsub_40B1C5(a1, a2, v5, v6);\nreturn sub_40AA9A(v6);\n}\n```", "output": "a1: result, BigInteger*\na2: m1, BigInteger*\na3: m2, unsigned int\nv5: m, BIGNUM*\nv6: ctx, BN_CTX*", "predict": "a1: result, BigInteger*\na2: a1, BigInteger*\na3: a2, unsigned int\nv5: a, BIGNUM*\nv6: ctx, BN_CTX*", "funname": "BigIntegerMulInt", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408D6C"}
{"input": "What are the original name and data type of variables `stat_loc`, `i`?\n```\nvoid sub_403BA7()\n{\n_DWORD stat_loc[3]; // [rsp+1Ch] [rbp-14h] BYREF\n__int64 i; // [rsp+28h] [rbp-8h]\n\nstat_loc[0] = 0;\nwait((__WAIT_STATUS)stat_loc);\nfor ( i = qword_414820; (__int64 *)i != &qword_414820; i = *(_QWORD *)i )\n{\n*(_QWORD *)&stat_loc[1] = i;\nif ( *(_DWORD *)(i + 32) == stat_loc[0] )\n{\n*(_DWORD *)(*(_QWORD *)&stat_loc[1] + 32LL) = 0;\nreturn;\n}\n}\n}\n```", "output": "stat_loc: pid, int\ni: p, list_head*", "predict": "stat_loc: pid, int\ni: p, list_head*", "funname": "server_handle_sigchld", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403BA7"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v5`, `s`, `v7`, `n`, `v9`, `v10`, `v11`, `v12`, `v13`, `v14`, `v15`?\n```\n__int64 __fastcall sub_409B94(__int64 a1, __int64 a2)\n{\n__int64 result; // rax\nunsigned int v5[8]; // [rsp+10h] [rbp-1C0h] BYREF\nchar s[256]; // [rsp+30h] [rbp-1A0h] BYREF\nint v7[23]; // [rsp+130h] [rbp-A0h] BYREF\nunsigned int n[3]; // [rsp+18Ch] [rbp-44h]\n__int64 v9; // [rsp+198h] [rbp-38h]\n__int64 v10; // [rsp+1A0h] [rbp-30h]\n__int64 v11; // [rsp+1A8h] [rbp-28h]\n__int64 v12; // [rsp+1B0h] [rbp-20h]\n__int64 v13; // [rsp+1B8h] [rbp-18h]\n__int64 v14; // [rsp+1C0h] [rbp-10h]\nunsigned int v15; // [rsp+1CCh] [rbp-4h]\n\nsub_408919((int *)(a1 + 380), *(char **)(a2 + 8), *(_DWORD *)a2);\nsub_408919((int *)(a1 + 380), *(char **)(a1 + 96), *(_DWORD *)(a1 + 88));\nsub_4088BF(v7);\nsub_408919(v7, *(char **)(a1 + 96), *(_DWORD *)(a1 + 88));\nsub_408A49((__int64)v5, v7);\nv15 = _byteswap_ulong(v5[0]);\nsub_408919((int *)(a1 + 104), *(char **)(a2 + 8), *(_DWORD *)a2);\nsub_408919((int *)(a1 + 196), *(char **)(a2 + 8), *(_DWORD *)a2);\nv14 = sub_408BEE(*(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 8));\nv13 = sub_408BEE(*(_QWORD *)(a1 + 80), *(_DWORD *)(a1 + 72));\nv12 = sub_408BEE(*(_QWORD *)(a1 + 48), *(_DWORD *)(a1 + 40));\nv11 = sub_408BEE(*(_QWORD *)(a2 + 8), *(_DWORD *)a2);\nv10 = sub_408BC2(0);\nsub_408E68(v10, v12, v15, v14);\nv9 = sub_408BC2(0);\nsub_408DCA(v9, v10, v11, v14);\nsub_408EDD(v11);\nsub_408EDD(v12);\nsub_408EDD(v10);\nif ( (int)sub_408C6B(v9, 1u) > 0 )\n{\n*(_QWORD *)&n[1] = sub_408BC2(0);\nsub_408CEA(*(__int64 *)&n[1], v9, 1u);\nif ( (unsigned int)sub_408C46(*(__int64 *)&n[1], v14) )\n{\nsub_408E19(*(__int64 *)&n[1], v9, v13, v14);\nn[0] = sub_408C21(*(__int64 *)&n[1], (__int64)s);\nsub_408EDD(*(__int64 *)&n[1]);\nsub_408EDD(v9);\nsub_408EDD(v13);\nsub_408EDD(v14);\nsub_409462(a1 + 472, s, n[0]);\nmemset(s, 0, n[0]);\nsub_408919((int *)(a1 + 104), (char *)(a1 + 472), 0x28u);\nsub_408919((int *)(a1 + 288), (char *)(a1 + 472), 0x28u);\nsub_408919((int *)(a1 + 380), (char *)(a1 + 472), 0x28u);\nresult = a1 + 472;\n}\nelse\n{\nsub_408EDD(v9);\nsub_408EDD(v13);\nsub_408EDD(v14);\nsub_408EDD(*(__int64 *)&n[1]);\nresult = 0LL;\n}\n}\nelse\n{\nsub_408EDD(v9);\nsub_408EDD(v13);\nsub_408EDD(v14);\nresult = 0LL;\n}\nreturn result;\n}\n```", "output": "a1: ts, t_server*\na2: clientval, t_num*\nv5: dig, unsigned char[20]\ns: sbuf, unsigned char[256]\nv7: ctxt, struct SHA1_CTX\nn: slen, unsigned int\nv9: res, BigInteger*\nv10: prod, BigInteger*\nv11: A, BigInteger*\nv12: v, BigInteger*\nv13: b, BigInteger*\nv14: n, BigInteger*\nv15: u, unsigned int", "predict": "a1: ts, t_server*\na2: clientval, t_num*\nv5: dig, unsigned char[20]\ns: sbuf, unsigned char[256]\nv7: ctxt, struct SHA1_CTX\nn: slen, unsigned int\nv9: res, BigInteger*\nv10: prod, BigInteger*\nv11: A, BigInteger*\nv12: v, BigInteger*\nv13: b, BigInteger*\nv14: n, BigInteger*\nv15: u, unsigned int", "funname": "t_servergetkey", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "409B94"}
{"input": "What are the original name and data type of variables `a1`, `v6`, `v8`?\n```\n__int64 __fastcall sub_402B6D(__int64 a1)\n{\nchar *v1; // rax\n__int16 v2; // ax\nunsigned __int16 v3; // ax\n__int16 v5; // [rsp+1Ch] [rbp-4h]\nuint16_t v6; // [rsp+1Ch] [rbp-4h]\n__int16 v7; // [rsp+1Eh] [rbp-2h]\n__int16 v8; // [rsp+1Eh] [rbp-2h]\n\nmemmove(off_4132D8, (const void *)a1, 0x2AuLL);\nv1 = (char *)off_4132D8 + 6;\n*(_DWORD *)((char *)off_4132D8 + 6) = dword_4132D0;\n*((_WORD *)v1 + 2) = word_4132D4;\nmemmove(off_4132D8, (const void *)(a1 + 6), 6uLL);\nv2 = ntohl(*(_DWORD *)((char *)off_4132D8 + 46));\nv5 = v2 + 48;\n*((_BYTE *)off_4132D8 + 16) = (unsigned __int16)(v2 + 48) >> 8;\n*((_BYTE *)off_4132D8 + 17) = v2 + 48;\n*(_DWORD *)((char *)off_4132D8 + 26) = *(_DWORD *)(a1 + 58);\n*(_DWORD *)((char *)off_4132D8 + 30) = *(_DWORD *)(a1 + 26);\n*((_WORD *)off_4132D8 + 12) = 0;\nv7 = sub_402AAD(0, (unsigned __int8 *)off_4132D8 + 14, 0x14u);\nif ( !v7 )\nv7 = -1;\n*((_WORD *)off_4132D8 + 12) = htons(~v7);\n*((_WORD *)off_4132D8 + 17) = *(_WORD *)(a1 + 36);\n*((_WORD *)off_4132D8 + 18) = *(_WORD *)(a1 + 34);\nv6 = v5 - 20;\n*((_WORD *)off_4132D8 + 19) = htons(v6);\n*((_WORD *)off_4132D8 + 20) = 0;\nv3 = sub_402AAD(v6 + 17, (unsigned __int8 *)off_4132D8 + 26, 8u);\nv8 = sub_402AAD(v3, (unsigned __int8 *)off_4132D8 + 34, v6);\nif ( !v8 )\nv8 = -1;\n*((_WORD *)off_4132D8 + 20) = htons(~v8);\nntohl(*(_DWORD *)((char *)off_4132D8 + 46));\nreturn pcap_sendpacket();\n}\n```", "output": "a1: pkt, ead_packet*\nv6: len, u16_t\nv8: sum, u16_t", "predict": "a1: pkt, ead_packet*\nv6: len, u16_t\nv8: sum, u16_t", "funname": "ead_send_packet_clone", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402B6D"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `i`?\n```\n__int64 __fastcall sub_40D0BF(_QWORD *a1, _BYTE *a2)\n{\nint v2; // kr04_4\n_BYTE *v3; // rax\nint v4; // eax\nint i; // [rsp+1Ch] [rbp-4h]\n\nv2 = sub_40C804((__int64)a1) + 7;\nfor ( i = v2 / 8; ; *v3 = *(_QWORD *)(*a1 + 8LL * (i / 8)) >> (8 * (unsigned __int8)(i % 8)) )\n{\nv4 = i--;\nif ( v4 <= 0 )\nbreak;\nv3 = a2++;\n}\nreturn (unsigned int)(v2 / 8);\n}\n```", "output": "a1: a, const BIGNUM*\na2: to, unsigned char*\ni: i, int", "predict": "a1: a, const BIGNUM*\na2: to, unsigned char*\ni: i, int", "funname": "BN_bn2bin", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D0BF"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_40AB57(int *a1)\n{\n__int64 result; // rax\nint v2; // eax\n\nif ( a1[75] <= 12 && *a1 <= 11 )\n{\nv2 = (*a1)++;\nresult = (__int64)&a1[6 * v2 + 2];\n}\nelse\n{\nif ( !a1[88] )\na1[88] = 1;\nresult = 0LL;\n}\nreturn result;\n}\n```", "output": "a1: ctx, BN_CTX*", "predict": "a1: ctx, BN_CTX*", "funname": "BN_CTX_get", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40AB57"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v4`, `v5`, `v6`, `v7`, `i`?\n```\nchar *__fastcall sub_409670(__int64 a1, __int64 a2)\n{\nunsigned int v3; // eax\nint v4[24]; // [rsp+10h] [rbp-B0h] BYREF\nchar v5[32]; // [rsp+70h] [rbp-50h] BYREF\nchar v6[32]; // [rsp+90h] [rbp-30h] BYREF\nchar *v7; // [rsp+B0h] [rbp-10h]\nunsigned int i; // [rsp+BCh] [rbp-4h]\n\nv7 = (char *)malloc(0x658uLL);\nif ( !v7 )\nreturn 0LL;\nsub_4088BF((_DWORD *)v7 + 95);\n*(_DWORD *)v7 = *(_DWORD *)(a1 + 40);\n*((_DWORD *)v7 + 2) = *(_DWORD *)(a2 + 8);\n*((_QWORD *)v7 + 2) = v7 + 532;\nmemcpy(*((void **)v7 + 2), *(const void **)(a2 + 16), *((int *)v7 + 2));\nsub_4088BF(v4);\nsub_408919(v4, *((char **)v7 + 2), *((_DWORD *)v7 + 2));\nsub_408A49((__int64)v6, v4);\n*((_DWORD *)v7 + 6) = *(_DWORD *)(a2 + 24);\n*((_QWORD *)v7 + 4) = v7 + 788;\nmemcpy(*((void **)v7 + 4), *(const void **)(a2 + 32), *((int *)v7 + 6));\nsub_4088BF(v4);\nsub_408919(v4, *((char **)v7 + 4), *((_DWORD *)v7 + 6));\nsub_408A49((__int64)v5, v4);\nfor ( i = 0; i <= 0x13; ++i )\nv6[i] ^= v5[i];\nsub_408919((int *)v7 + 95, v6, 0x14u);\nsub_4088BF(v4);\nv3 = strlen(*(const char **)a1);\nsub_408919(v4, *(char **)a1, v3);\nsub_408A49((__int64)v6, v4);\nsub_408919((int *)v7 + 95, v6, 0x14u);\n*((_DWORD *)v7 + 10) = *(_DWORD *)(a1 + 8);\n*((_QWORD *)v7 + 6) = v7 + 1044;\nmemcpy(*((void **)v7 + 6), *(const void **)(a1 + 16), *((int *)v7 + 10));\n*((_DWORD *)v7 + 14) = *(_DWORD *)(a1 + 24);\n*((_QWORD *)v7 + 8) = v7 + 1300;\nmemcpy(*((void **)v7 + 8), *(const void **)(a1 + 32), *((int *)v7 + 14));\nsub_408919((int *)v7 + 95, *((char **)v7 + 8), *((_DWORD *)v7 + 14));\n*((_QWORD *)v7 + 10) = v7 + 1332;\n*((_QWORD *)v7 + 12) = v7 + 1364;\nsub_4088BF((_DWORD *)v7 + 49);\nsub_4088BF((_DWORD *)v7 + 26);\nsub_4088BF((_DWORD *)v7 + 72);\nreturn v7;\n}\n```", "output": "a1: ent, t_pwent*\na2: tce, t_confent*\nv4: ctxt, struct SHA1_CTX\nv5: buf2, unsigned char[20]\nv6: buf1, unsigned char[20]\nv7: ts, t_server*\ni: i, int", "predict": "a1: ent, t_pwent*\na2: tce, t_confent*\nv4: ctxt, struct SHA1_CTX\nv5: buf2, unsigned char[20]\nv6: buf1, unsigned char[20]\nv7: ts, t_server*\ni: i, int", "funname": "t_serveropenraw", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "409670"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v24`, `v25`, `v26`, `v27`, `v31`?\n```\n__int64 __fastcall sub_40A626(__int64 a1, __int64 a2, __int64 a3)\n{\nbool v4; // al\nunsigned __int64 *v5; // rbx\nunsigned __int64 *v6; // r15\nunsigned __int64 *v7; // r12\nunsigned __int64 *v8; // rax\nunsigned __int64 v9; // r13\nunsigned __int64 *v10; // rax\nunsigned __int64 v11; // r14\n__int64 v12; // r13\n__int64 *v13; // rax\nunsigned __int64 *v14; // rax\nunsigned __int64 v15; // r13\nunsigned __int64 v16; // r14\nunsigned __int64 *v17; // rax\nint v18; // eax\nint v19; // eax\nint v20; // eax\nint v21; // eax\n_QWORD *v22; // rax\nint v24; // [rsp+28h] [rbp-48h]\nsigned int v25; // [rsp+2Ch] [rbp-44h]\n__int64 v26; // [rsp+30h] [rbp-40h]\n_BOOL4 v27; // [rsp+38h] [rbp-38h]\nint i; // [rsp+3Ch] [rbp-34h]\nint v29; // [rsp+3Ch] [rbp-34h]\nint v30; // [rsp+3Ch] [rbp-34h]\nint v31; // [rsp+3Ch] [rbp-34h]\n\nif ( *(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8) )\nreturn 0LL;\nv25 = *(_DWORD *)(a2 + 8);\nv24 = *(_DWORD *)(a3 + 8);\nif ( v25 <= *(_DWORD *)(a1 + 12) )\nv4 = a1 == 0;\nelse\nv4 = sub_40C9FA(a1, (unsigned int)v25) == 0;\nif ( v4 )\nreturn 0LL;\nv5 = *(unsigned __int64 **)a2;\nv6 = *(unsigned __int64 **)a3;\nv7 = *(unsigned __int64 **)a1;\nv27 = 0;\nfor ( i = 0; i < v24; ++i )\n{\nv8 = v5++;\nv9 = *v8;\nv10 = v6++;\nv11 = *v10;\nif ( v27 )\n{\nv27 = v9 <= v11;\nv12 = v9 - v11 - 1;\n}\nelse\n{\nv27 = v9 < v11;\nv12 = v9 - v11;\n}\nv13 = (__int64 *)v7++;\n*v13 = v12;\n}\nif ( v27 )\n{\ndo\n{\nif ( i >= v25 )\nbreak;\n++i;\nv14 = v5++;\nv15 = *v14;\nv16 = *v14 - 1;\nv17 = v7++;\n*v17 = v16;\n}\nwhile ( v15 <= v16 );\n}\nif ( v7 != v5 )\n{\nwhile ( 1 )\n{\nv18 = i;\nv29 = i + 1;\nif ( v25 <= v18 )\nbreak;\n*v7 = *v5;\nv19 = v29;\nv30 = v29 + 1;\nif ( v25 <= v19 )\nbreak;\nv7[1] = v5[1];\nv20 = v30;\nv31 = v30 + 1;\nif ( v25 <= v20 )\nbreak;\nv7[2] = v5[2];\nv21 = v31;\ni = v31 + 1;\nif ( v25 <= v21 )\nbreak;\nv7[3] = v5[3];\nv7 += 4;\nv5 += 4;\n}\n}\n*(_DWORD *)(a1 + 8) = v25;\nif ( *(int *)(a1 + 8) > 0 )\n{\nv26 = *(_QWORD *)a1 + 8LL * *(int *)(a1 + 8) - 8;\nwhile ( *(int *)(a1 + 8) > 0 )\n{\nv22 = (_QWORD *)v26;\nv26 -= 8LL;\nif ( *v22 )\nbreak;\n--*(_DWORD *)(a1 + 8);\n}\n}\nreturn 1LL;\n}\n```", "output": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: b, const BIGNUM*\nv24: min, int\nv25: max, int\nv26: ftl, long unsigned int*\nv27: carry, int\nv31: i, int", "predict": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: b, const BIGNUM*\nv24: min, int\nv25: max, int\nv26: ftl, long unsigned int*\nv27: carry, int\nv31: i, int", "funname": "BN_usub", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A626"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v5`, `v6`, `v7`?\n```\n__int64 __fastcall sub_4030D5(__int64 a1, __int64 a2, _DWORD *a3)\n{\nsigned int v5; // [rsp+14h] [rbp-1Ch]\nchar *v6; // [rsp+20h] [rbp-10h]\nchar *v7; // [rsp+28h] [rbp-8h]\n\nv5 = ntohl(*(_DWORD *)(a1 + 46)) - 1;\nif ( v5 > 257 )\nreturn 0LL;\ndword_414850 = v5;\nqword_414858 = &unk_4145C0;\nmemmove(&unk_4145C0, (const void *)(a1 + 63), v5);\nv7 = (char *)off_4132D8 + 42;\nv6 = (char *)off_4132D8 + 62;\n*((_DWORD *)v7 + 1) = htonl(*(_DWORD *)qword_414860 + 1);\nmemmove(v6 + 1, *(const void **)(qword_414860 + 8), *(int *)qword_414860);\n*a3 = 8;\nreturn 1LL;\n}\n```", "output": "a1: pkt, ead_packet*\na2: len, int\na3: nstate, int*\nv5: len, int\nv6: number, ead_msg_number*\nv7: msg, ead_msg*", "predict": "a1: pkt, ead_packet*\na2: len, int\na3: nstate, int*\nv5: len, int\nv6: number, ead_msg_number*\nv7: msg, ead_msg*", "funname": "handle_send_a", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4030D5"}
{"input": "What are the original name and data type of variables `v1`?\n```\n_DWORD *sub_40C999()\n{\n_DWORD *v1; // [rsp+8h] [rbp-8h]\n\nv1 = malloc(0x18uLL);\nif ( !v1 )\nreturn 0LL;\nv1[5] = 1;\nv1[2] = 0;\nv1[4] = 0;\nv1[3] = 0;\n*(_QWORD *)v1 = 0LL;\nreturn v1;\n}\n```", "output": "v1: ret, BIGNUM*", "predict": "v1: ret, BIGNUM*", "funname": "BN_new", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C999"}
{"input": "What are the original name and data type of variables `a1`?\n```\n_DWORD *__fastcall sub_40466E(_DWORD *a1)\n{\n_DWORD *result; // rax\n\n*a1 = 1732584193;\na1[1] = -271733879;\na1[2] = -1732584194;\na1[3] = 271733878;\nresult = a1 + 4;\na1[4] = -1009589776;\nreturn result;\n}\n```", "output": "a1: buf, uint32_t*", "predict": "a1: buf, uint32_t*", "funname": "sha_init", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40466E"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`?\n```\n_QWORD *__fastcall sub_402514(_QWORD *a1, _QWORD *a2, __int64 a3)\n{\n_QWORD *result; // rax\n\n*(_QWORD *)(a3 + 8) = a1;\n*a1 = a3;\na1[1] = a2;\nresult = a2;\n*a2 = a1;\nreturn result;\n}\n```", "output": "a1: new, list_head*\na2: prev, list_head*\na3: next, list_head*", "predict": "a1: new, const list_head*\na2: prev, const list_head*\na3: next, const list_head*", "funname": "__list_add", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402514"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v14`, `v15`, `v16`, `v17`, `v18`, `v19`, `v20`, `v22`, `v23`, `i`?\n```\n__int64 __fastcall sub_40E1BA(__int64 a1, __int64 a2, int a3)\n{\nint v3; // eax\nint v4; // edx\n__int64 result; // rax\nbool v6; // al\n__int64 *v7; // rdx\n__int64 *v8; // rax\nunsigned __int64 *v9; // rax\nunsigned __int64 *v10; // rax\n__int64 *v11; // rax\nunsigned __int64 *v12; // rax\n_QWORD *v13; // rax\nint v14; // [rsp+Ch] [rbp-54h]\nunsigned __int64 v15; // [rsp+20h] [rbp-40h]\nint v16; // [rsp+28h] [rbp-38h]\nint v17; // [rsp+30h] [rbp-30h]\nint v18; // [rsp+34h] [rbp-2Ch]\n__int64 v19; // [rsp+38h] [rbp-28h]\nunsigned __int64 v20; // [rsp+40h] [rbp-20h]\n__int64 v21; // [rsp+48h] [rbp-18h]\nunsigned __int64 *v22; // [rsp+48h] [rbp-18h]\n__int64 *v23; // [rsp+50h] [rbp-10h]\nint j; // [rsp+5Ch] [rbp-4h]\nint i; // [rsp+5Ch] [rbp-4h]\n\nv14 = a3;\nv3 = a3;\nv4 = a3 + 63;\nif ( v3 < 0 )\nv3 = v4;\nv18 = v3 >> 6;\nv17 = v14 % 64;\nif ( v3 >> 6 <= *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 8) )\n{\nif ( a1 == a2\n|| ((*(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 8) - v18 < *(_DWORD *)(a1 + 12)) ? (v6 = a1 == 0) : (v6 = sub_40C9FA(a1, *(_DWORD *)(a2 + 8) - v18 + 1) == 0),\n!v6) )\n{\nv21 = *(_QWORD *)a2 + 8LL * v18;\nv23 = *(__int64 **)a1;\nv16 = *(_DWORD *)(a2 + 8) - v18;\n*(_DWORD *)(a1 + 8) = v16;\nif ( v17 )\n{\nv9 = (unsigned __int64 *)v21;\nv22 = (unsigned __int64 *)(v21 + 8);\nv20 = *v9;\nfor ( i = 1; i < v16; ++i )\n{\nv15 = v20 >> v17;\nv10 = v22++;\nv20 = *v10;\nv11 = v23++;\n*v11 = v15 | (v20 << (64 - (unsigned __int8)(v14 % 64)));\n}\nv12 = (unsigned __int64 *)v23++;\n*v12 = v20 >> v17;\n}\nelse\n{\nfor ( j = v16 + 1; j > 0; --j )\n{\nv7 = (__int64 *)v21;\nv21 += 8LL;\nv8 = v23++;\n*v8 = *v7;\n}\n}\n*v23 = 0LL;\nif ( *(int *)(a1 + 8) > 0 )\n{\nv19 = *(_QWORD *)a1 + 8LL * *(int *)(a1 + 8) - 8;\nwhile ( *(int *)(a1 + 8) > 0 )\n{\nv13 = (_QWORD *)v19;\nv19 -= 8LL;\nif ( *v13 )\nbreak;\n--*(_DWORD *)(a1 + 8);\n}\n}\nresult = 1LL;\n}\nelse\n{\nresult = 0LL;\n}\n}\nelse\n{\nsub_40CE13(a1, 0LL);\nresult = 1LL;\n}\nreturn result;\n}\n```", "output": "a1: r, BIGNUM*\na2: a, BIGNUM*\na3: n, int\nv14: n, int\nv15: tmp, long unsigned int\nv16: j, int\nv17: rb, int\nv18: nw, int\nv19: ftl, long unsigned int*\nv20: l, long unsigned int\nv22: f, long unsigned int*\nv23: t, long unsigned int*\ni: i, int", "predict": "a1: r, BIGNUM*\na2: a, BIGNUM*\na3: n, int\nv14: n, int\nv15: tmp, long unsigned int\nv16: j, int\nv17: rb, int\nv18: nw, int\nv19: ftl, long unsigned int*\nv20: l, long unsigned int\nv22: f, long unsigned int*\nv23: t, long unsigned int*\ni: i, int", "funname": "BN_rshift", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40E1BA"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_403C42(__int64 a1)\n{\n__int64 result; // rax\n\nif ( byte_414830 == 1 || (*(_DWORD *)(a1 + 32) = fork()) == 0 )\n{\nqword_414838 = a1;\nsignal(17, (__sighandler_t)handler);\nsub_4039D5(1);\nsub_403B44();\n}\nresult = *(unsigned int *)(a1 + 32);\nif ( (int)result < 0 )\n{\nresult = a1;\n*(_DWORD *)(a1 + 32) = 0;\n}\nreturn result;\n}\n```", "output": "a1: i, ead_instance*", "predict": "a1: i, ead_instance*", "funname": "start_server", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403C42"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v7`, `v10`, `v12`, `v13`, `v15`, `v16`, `v18`, `v19`, `v21`, `v23`, `v25`, `v27`, `v29`?\n```\nunsigned __int64 __fastcall sub_40C061(unsigned __int64 *a1, _QWORD *a2, int a3)\n{\nunsigned __int64 result; // rax\nint v4; // [rsp+0h] [rbp-74h]\nint v5; // [rsp+0h] [rbp-74h]\nint v6; // [rsp+0h] [rbp-74h]\nint v7; // [rsp+0h] [rbp-74h]\nunsigned __int64 v10; // [rsp+14h] [rbp-60h]\n__int64 v11; // [rsp+1Ch] [rbp-58h]\nunsigned __int64 v12; // [rsp+1Ch] [rbp-58h]\nunsigned __int64 v13; // [rsp+24h] [rbp-50h]\n__int64 v14; // [rsp+2Ch] [rbp-48h]\nunsigned __int64 v15; // [rsp+2Ch] [rbp-48h]\nunsigned __int64 v16; // [rsp+34h] [rbp-40h]\n__int64 v17; // [rsp+3Ch] [rbp-38h]\nunsigned __int64 v18; // [rsp+3Ch] [rbp-38h]\nunsigned __int64 v19; // [rsp+44h] [rbp-30h]\n__int64 v20; // [rsp+4Ch] [rbp-28h]\nunsigned __int64 v21; // [rsp+4Ch] [rbp-28h]\nunsigned __int64 v22; // [rsp+54h] [rbp-20h]\nunsigned __int64 v23; // [rsp+54h] [rbp-20h]\nunsigned __int64 v24; // [rsp+5Ch] [rbp-18h]\nunsigned __int64 v25; // [rsp+5Ch] [rbp-18h]\nunsigned __int64 v26; // [rsp+64h] [rbp-10h]\nunsigned __int64 v27; // [rsp+64h] [rbp-10h]\n__int64 v28; // [rsp+6Ch] [rbp-8h]\nunsigned __int64 v29; // [rsp+6Ch] [rbp-8h]\n\nv4 = a3;\nif ( a3 > 0 )\n{\nwhile ( 1 )\n{\nv20 = (unsigned int)*a2;\nv28 = HIDWORD(*a2);\nv19 = v28 * v20;\nv29 = ((unsigned __int64)(v28 * v20) >> 31) + v28 * v28;\nv19 <<= 33;\nv21 = v19 + v20 * v20;\nif ( v21 < v19 )\n++v29;\n*a1 = v21;\nresult = v29;\na1[1] = v29;\nv5 = v4 - 1;\nif ( !v5 )\nbreak;\nv26 = a2[1];\nv17 = (unsigned int)v26;\nv26 >>= 32;\nv16 = v26 * v17;\nv27 = ((v26 * v17) >> 31) + v26 * v26;\nv16 <<= 33;\nv18 = v16 + v17 * v17;\nif ( v18 < v16 )\n++v27;\na1[2] = v18;\nresult = v27;\na1[3] = v27;\nv6 = v5 - 1;\nif ( !v6 )\nbreak;\nv24 = a2[2];\nv14 = (unsigned int)v24;\nv24 >>= 32;\nv13 = v24 * v14;\nv25 = ((v24 * v14) >> 31) + v24 * v24;\nv13 <<= 33;\nv15 = v13 + v14 * v14;\nif ( v15 < v13 )\n++v25;\na1[4] = v15;\nresult = v25;\na1[5] = v25;\nv7 = v6 - 1;\nif ( !v7 )\nbreak;\nv22 = a2[3];\nv11 = (unsigned int)v22;\nv22 >>= 32;\nv10 = v22 * v11;\nv23 = ((v22 * v11) >> 31) + v22 * v22;\nv10 <<= 33;\nv12 = v10 + v11 * v11;\nif ( v12 < v10 )\n++v23;\na1[6] = v12;\nresult = v23;\na1[7] = v23;\nv4 = v7 - 1;\nif ( !v4 )\nbreak;\na2 += 4;\na1 += 8;\n}\n}\nreturn result;\n}\n```", "output": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: n, int\nv7: n, int\nv10: m, long unsigned int\nv12: l, long unsigned int\nv13: m, long unsigned int\nv15: l, long unsigned int\nv16: m, long unsigned int\nv18: l, long unsigned int\nv19: m, long unsigned int\nv21: l, long unsigned int\nv23: h, long unsigned int\nv25: h, long unsigned int\nv27: h, long unsigned int\nv29: h, long unsigned int", "predict": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: n, int\nv7: n, int\nv10: m, long unsigned int\nv12: l, long unsigned int\nv13: m, long unsigned int\nv15: l, long unsigned int\nv16: m, long unsigned int\nv18: l, long unsigned int\nv19: m, long unsigned int\nv21: l, long unsigned int\nv23: h, long unsigned int\nv25: h, long unsigned int\nv27: h, long unsigned int\nv29: h, long unsigned int", "funname": "bn_sqr_words", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C061"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`?\n```\n__int64 __fastcall sub_408CBC(__int64 a1, __int64 a2, __int64 a3)\n{\nreturn sub_40A34C(a1, a2, a3);\n}\n```", "output": "a1: result, BigInteger*\na2: a1, BigInteger*\na3: a2, BigInteger*", "predict": "a1: result, BigInteger*\na2: s1, BigInteger*\na3: s2, BigInteger*", "funname": "BigIntegerAdd", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408CBC"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `a5`?\n```\n__int64 __fastcall sub_40AD12(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)\n{\nreturn (unsigned int)sub_40AD55(a1, a2, a3, a4, a5);\n}\n```", "output": "a1: r, BIGNUM*\na2: a, BIGNUM*\na3: p, const BIGNUM*\na4: m, const BIGNUM*\na5: ctx, BN_CTX*", "predict": "a1: r, BIGNUM*\na2: a, BIGNUM*\na3: p, const BIGNUM*\na4: m, const BIGNUM*\na5: ctx, BN_CTX*", "funname": "BN_mod_exp", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40AD12"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`?\n```\n__int64 __fastcall sub_402F7E(__int64 a1, __int64 a2, _DWORD *a3)\n{\nsub_402DA1(2);\nstrncpy(s2, (const char *)(a1 + 62), 0x20uLL);\nbyte_41459F = 0;\n*(_DWORD *)((char *)off_4132D8 + 46) = 0;\n*a3 = 4;\nreturn 1LL;\n}\n```", "output": "a1: pkt, ead_packet*\na2: len, int\na3: nstate, int*", "predict": "a1: pkt, ead_packet*\na2: len, int\na3: nstate, int*", "funname": "handle_set_username", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402F7E"}
{"input": "What are the original name and data type of variables `a1`, `s2`, `s1`, `v6`, `v7`, `i`, `v9`, `v10`?\n```\n__int64 __fastcall sub_405FA1(__int64 a1)\n{\n__int64 result; // rax\nunsigned int v2; // eax\nuint32_t v3; // eax\nint s2[8]; // [rsp+10h] [rbp-50h] BYREF\nint s1[5]; // [rsp+30h] [rbp-30h] BYREF\nint v6; // [rsp+44h] [rbp-1Ch]\nunsigned __int8 *v7; // [rsp+48h] [rbp-18h]\nint i; // [rsp+50h] [rbp-10h]\nint v9; // [rsp+54h] [rbp-Ch]\nunsigned __int8 *v10; // [rsp+58h] [rbp-8h]\n\nv7 = (unsigned __int8 *)(a1 + 20);\nv10 = (unsigned __int8 *)(a1 + 20);\nv9 = ntohl(*(_DWORD *)(a1 + 4));\nv6 = v9;\nif ( !v9 || v9 % 64 > 0 )\nreturn 0LL;\nwhile ( v9 > 0 )\n{\nsub_4054D5(dword_414E40, v10, v10);\nv10 += 16;\nv9 -= 16;\n}\nv10 = v7;\nif ( v7[24] > 0x3Fu )\nreturn 0LL;\nv2 = ntohl(*((_DWORD *)v7 + 5));\nif ( (unsigned __int8)sub_405DB9(v2) != 1 )\nreturn 0LL;\nfor ( i = 0; i <= 4; ++i )\n{\nv3 = ntohl(*(_DWORD *)&v7[4 * i]);\ns1[i] = v3;\n}\nsub_405E43(v7, s2, v6);\nif ( !memcmp(s1, s2, 0x14uLL) )\nresult = v6 - (unsigned int)v7[24] - 25;\nelse\nresult = 0LL;\nreturn result;\n}\n```", "output": "a1: msg, ead_msg*\ns2: hash_new, uint32_t[5]\ns1: hash_old, uint32_t[5]\nv6: enclen, int\nv7: enc, ead_msg_encrypted*\ni: i, int\nv9: len, int\nv10: data, unsigned char*", "predict": "a1: msg, ead_msg*\ns2: hash_new, uint32_t[5]\ns1: hash_old, uint32_t[5]\nv6: enclen, int\nv7: enc, ead_msg_encrypted*\ni: i, int\nv9: len, int\nv10: data, unsigned char*", "funname": "ead_decrypt_message", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405FA1"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `v7`?\n```\n__int64 __fastcall sub_408DCA(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n__int64 v7; // [rsp+28h] [rbp-8h]\n\nv7 = sub_40A9D9();\nsub_40AC4C(a1, a2, a3, a4, v7);\nreturn sub_40AA9A(v7);\n}\n```", "output": "a1: r, BigInteger*\na2: m1, BigInteger*\na3: m2, BigInteger*\na4: modulus, BigInteger*\nv7: ctx, BN_CTX*", "predict": "a1: r, BigInteger*\na2: m1, BigInteger*\na3: m2, BigInteger*\na4: modulus, BigInteger*\nv7: ctx, BN_CTX*", "funname": "BigIntegerModMul", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408DCA"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_405D19(__int64 a1)\n{\n__int64 result; // rax\n\nmemset(dword_414D80, 0, 0xB0uLL);\nmemset(dword_414E40, 0, sizeof(dword_414E40));\nsub_4046D3(dword_414D80, (unsigned __int8 *)a1);\nsub_40493E(dword_414E40, (unsigned __int8 *)a1);\ndword_414EF0 = ntohl(*(_DWORD *)(a1 + 32)) & 0xFFFFFF;\ndword_414EF4 = dword_414EF0;\nresult = *(unsigned int *)(a1 + 36);\ndword_414EF8 = *(_DWORD *)(a1 + 36);\nreturn result;\n}\n```", "output": "a1: skey, unsigned char*", "predict": "a1: skey, unsigned char*", "funname": "ead_set_key", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405D19"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n__int64 __fastcall sub_408C46(__int64 a1, __int64 a2)\n{\nreturn sub_40D215(a1, a2);\n}\n```", "output": "a1: c1, BigInteger*\na2: c2, BigInteger*", "predict": "a1: c1, BigInteger*\na2: c2, BigInteger*", "funname": "BigIntegerCmp", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408C46"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `v9`, `v10`, `v11`, `v12`, `v13`, `v14`?\n```\n__int64 __fastcall sub_40B1C5(__int64 a1, __int64 a2, __int64 a3, int *a4)\n{\nbool v5; // al\n_QWORD *v6; // rax\nunsigned int v9; // [rsp+2Ch] [rbp-24h]\nunsigned int v10; // [rsp+30h] [rbp-20h]\nunsigned int v11; // [rsp+34h] [rbp-1Ch]\n__int64 v12; // [rsp+38h] [rbp-18h]\nunsigned int v13; // [rsp+44h] [rbp-Ch]\n__int64 v14; // [rsp+48h] [rbp-8h]\n\nv13 = 0;\nv11 = *(_DWORD *)(a2 + 8);\nv10 = *(_DWORD *)(a3 + 8);\nif ( !v11 || !v10 )\n{\nsub_40CE13(a1, 0LL);\nreturn 1LL;\n}\nv9 = v11 + v10;\nsub_40AB08(a4);\nif ( a1 != a2 && a1 != a3 )\n{\nv14 = a1;\nLABEL_9:\n*(_DWORD *)(v14 + 16) = *(_DWORD *)(a3 + 16) ^ *(_DWORD *)(a2 + 16);\nif ( (signed int)v9 <= *(_DWORD *)(v14 + 12) )\nv5 = v14 == 0;\nelse\nv5 = sub_40C9FA(v14, v9) == 0;\nif ( !v5 )\n{\n*(_DWORD *)(v14 + 8) = v9;\nsub_40B381(*(_QWORD *)v14, *(_QWORD *)a2, v11, *(_QWORD *)a3, v10);\nif ( *(int *)(v14 + 8) > 0 )\n{\nv12 = *(_QWORD *)v14 + 8LL * *(int *)(v14 + 8) - 8;\nwhile ( *(int *)(v14 + 8) > 0 )\n{\nv6 = (_QWORD *)v12;\nv12 -= 8LL;\nif ( *v6 )\nbreak;\n--*(_DWORD *)(v14 + 8);\n}\n}\nif ( a1 != v14 )\nsub_40CC70(a1, v14);\nv13 = 1;\n}\ngoto LABEL_21;\n}\nv14 = sub_40AB57(a4);\nif ( v14 )\ngoto LABEL_9;\nLABEL_21:\nsub_40ABC8(a4);\nreturn v13;\n}\n```", "output": "a1: r, BIGNUM*\na2: a, BIGNUM*\na3: b, BIGNUM*\na4: ctx, BN_CTX*\nv9: top, int\nv10: bl, int\nv11: al, int\nv12: ftl, long unsigned int*\nv13: ret, int\nv14: rr, BIGNUM*", "predict": "a1: r, BIGNUM*\na2: a, BIGNUM*\na3: b, BIGNUM*\na4: ctx, BN_CTX*\nv9: top, int\nv10: bl, int\nv11: al, int\nv12: ftl, long unsigned int*\nv13: ret, int\nv14: rr, BIGNUM*", "funname": "BN_mul", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40B1C5"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v8`, `k`, `v12`, `v13`, `v14`, `v15`, `v16`?\n```\nint *__fastcall sub_40427F(int *a1, __int64 a2, __int64 a3)\n{\nint *result; // rax\nint v5; // [rsp+1Ch] [rbp-24h]\nint v6; // [rsp+1Ch] [rbp-24h]\nint v7; // [rsp+1Ch] [rbp-24h]\nint v8; // [rsp+1Ch] [rbp-24h]\nunsigned int i; // [rsp+20h] [rbp-20h]\nunsigned int j; // [rsp+20h] [rbp-20h]\nunsigned int k; // [rsp+20h] [rbp-20h]\nint v12; // [rsp+24h] [rbp-1Ch]\nint v13; // [rsp+28h] [rbp-18h]\nint v14; // [rsp+2Ch] [rbp-14h]\nint v15; // [rsp+30h] [rbp-10h]\nint v16; // [rsp+34h] [rbp-Ch]\n\nfor ( i = 0; i <= 0xF; ++i )\n*(_DWORD *)(4LL * i + a3) = *(unsigned __int8 *)((int)(4 * i) + 3LL + a2) | (*(unsigned __int8 *)((int)(4 * i) + 2LL + a2) << 8) | (*(unsigned __int8 *)((int)(4 * i) + 1LL + a2) << 16) | (*(unsigned __int8 *)((int)(4 * i) + a2) << 24);\nfor ( j = 0; j <= 0x3F; ++j )\n*(_DWORD *)(4LL * (j + 16) + a3) = sub_404267(\n*(_DWORD *)(4LL * (j + 2) + a3) ^ (unsigned int)(*(_DWORD *)(4LL * (j + 8) + a3) ^ *(_DWORD *)(4LL * (j + 13) + a3)) ^ *(_DWORD *)(4LL * j + a3),\n1);\nv16 = *a1;\nv15 = a1[1];\nv14 = a1[2];\nv13 = a1[3];\nv12 = a1[4];\nfor ( k = 0; k <= 0x13; ++k )\n{\nv5 = v12 + (v13 ^ v15 & (v13 ^ v14)) + sub_404267(v16, 5) + *(_DWORD *)(4LL * k + a3) + 1518500249;\nv12 = v13;\nv13 = v14;\nv14 = sub_404267(v15, 30);\nv15 = v16;\nv16 = v5;\n}\nwhile ( k <= 0x27 )\n{\nv6 = v12 + (v13 ^ v14 ^ v15) + sub_404267(v16, 5) + *(_DWORD *)(4LL * k + a3) + 1859775393;\nv12 = v13;\nv13 = v14;\nv14 = sub_404267(v15, 30);\nv15 = v16;\nv16 = v6;\n++k;\n}\nwhile ( k <= 0x3B )\n{\nv7 = v12 + (v14 & v15) + (v13 & (v14 ^ v15)) + sub_404267(v16, 5) + *(_DWORD *)(4LL * k + a3) - 1894007588;\nv12 = v13;\nv13 = v14;\nv14 = sub_404267(v15, 30);\nv15 = v16;\nv16 = v7;\n++k;\n}\nwhile ( k <= 0x4F )\n{\nv8 = v12 + (v13 ^ v14 ^ v15) + sub_404267(v16, 5) + *(_DWORD *)(4LL * k + a3) - 899497514;\nv12 = v13;\nv13 = v14;\nv14 = sub_404267(v15, 30);\nv15 = v16;\nv16 = v8;\n++k;\n}\n*a1 += v16;\na1[1] += v15;\na1[2] += v14;\na1[3] += v13;\nresult = a1 + 4;\na1[4] += v12;\nreturn result;\n}\n```", "output": "a1: digest, uint32_t*\na2: in, const unsigned char*\na3: W, uint32_t*\nv8: t, uint32_t\nk: i, uint32_t\nv12: e, uint32_t\nv13: d, uint32_t\nv14: c, uint32_t\nv15: b, uint32_t\nv16: a, uint32_t", "predict": "a1: digest, uint32_t*\na2: in, const unsigned char*\na3: W, uint32_t*\nv8: t, uint32_t\nk: i, uint32_t\nv12: e, uint32_t\nv13: d, uint32_t\nv14: c, uint32_t\nv15: b, uint32_t\nv16: a, uint32_t", "funname": "sha_transform", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40427F"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `a5`, `v9`, `v10`?\n```\n__int64 __fastcall sub_40AC4C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)\n{\n__int64 v9; // [rsp+30h] [rbp-10h]\nunsigned int v10; // [rsp+3Ch] [rbp-4h]\n\nv10 = 0;\nsub_40AB08(a5);\nv9 = sub_40AB57(a5);\nif ( v9 )\n{\nif ( a2 == a3 )\n{\nif ( !(unsigned int)sub_40D3CB(v9, a2, a5) )\ngoto LABEL_8;\n}\nelse if ( !(unsigned int)sub_40B1C5(v9, a2, a3, a5) )\n{\ngoto LABEL_8;\n}\nif ( (unsigned int)sub_40DEE2(a1, v9, a4, a5) )\nv10 = 1;\n}\nLABEL_8:\nsub_40ABC8(a5);\nreturn v10;\n}\n```", "output": "a1: ret, BIGNUM*\na2: a, BIGNUM*\na3: b, BIGNUM*\na4: m, const BIGNUM*\na5: ctx, BN_CTX*\nv9: t, BIGNUM*\nv10: r, int", "predict": "a1: ret, BIGNUM*\na2: a, BIGNUM*\na3: b, BIGNUM*\na4: m, const BIGNUM*\na5: ctx, BN_CTX*\nv9: t, BIGNUM*\nv10: r, int", "funname": "BN_mod_mul", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40AC4C"}
{"input": "What are the original name and data type of variables `i`?\n```\n__int64 sub_403CF4()\n{\n__int64 result; // rax\n__int64 i; // [rsp+18h] [rbp-8h]\n\nresult = qword_414820;\nfor ( i = qword_414820; (__int64 *)i != &qword_414820; i = *(_QWORD *)i )\n{\nif ( *(int *)(i + 32) <= 0 )\n{\nsleep(1u);\nsub_403C42(i);\n}\nresult = *(_QWORD *)i;\n}\nreturn result;\n}\n```", "output": "i: p, list_head*", "predict": "i: p, list_head*", "funname": "start_servers", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403CF4"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `v8`, `v11`, `v12`, `v14`, `v15`, `v16`, `v18`, `v19`, `v20`, `v22`, `v23`, `v24`, `v26`, `v27`, `v29`, `v31`, `v33`, `v35`, `v37`, `v39`, `v41`, `v43`, `v47`?\n```\nunsigned __int64 __fastcall sub_40B510(unsigned __int64 *a1, _QWORD *a2, int a3, unsigned __int64 a4)\n{\nint v5; // [rsp+Ch] [rbp-F4h]\nint v6; // [rsp+Ch] [rbp-F4h]\nint v7; // [rsp+Ch] [rbp-F4h]\nint v8; // [rsp+Ch] [rbp-F4h]\nunsigned __int64 v11; // [rsp+30h] [rbp-D0h]\nunsigned __int64 v12; // [rsp+38h] [rbp-C8h]\n__int64 v13; // [rsp+40h] [rbp-C0h]\nunsigned __int64 v14; // [rsp+40h] [rbp-C0h]\nunsigned __int64 v15; // [rsp+50h] [rbp-B0h]\nunsigned __int64 v16; // [rsp+58h] [rbp-A8h]\n__int64 v17; // [rsp+60h] [rbp-A0h]\nunsigned __int64 v18; // [rsp+60h] [rbp-A0h]\nunsigned __int64 v19; // [rsp+70h] [rbp-90h]\nunsigned __int64 v20; // [rsp+78h] [rbp-88h]\n__int64 v21; // [rsp+80h] [rbp-80h]\nunsigned __int64 v22; // [rsp+80h] [rbp-80h]\nunsigned __int64 v23; // [rsp+90h] [rbp-70h]\nunsigned __int64 v24; // [rsp+98h] [rbp-68h]\n__int64 v25; // [rsp+A0h] [rbp-60h]\nunsigned __int64 v26; // [rsp+A0h] [rbp-60h]\nunsigned __int64 v27; // [rsp+A8h] [rbp-58h]\n__int64 v28; // [rsp+B8h] [rbp-48h]\nunsigned __int64 v29; // [rsp+B8h] [rbp-48h]\nunsigned __int64 v30; // [rsp+C0h] [rbp-40h]\nunsigned __int64 v31; // [rsp+C0h] [rbp-40h]\n__int64 v32; // [rsp+C8h] [rbp-38h]\nunsigned __int64 v33; // [rsp+C8h] [rbp-38h]\nunsigned __int64 v34; // [rsp+D0h] [rbp-30h]\nunsigned __int64 v35; // [rsp+D0h] [rbp-30h]\n__int64 v36; // [rsp+D8h] [rbp-28h]\nunsigned __int64 v37; // [rsp+D8h] [rbp-28h]\nunsigned __int64 v38; // [rsp+E0h] [rbp-20h]\nunsigned __int64 v39; // [rsp+E0h] [rbp-20h]\n__int64 v40; // [rsp+E8h] [rbp-18h]\nunsigned __int64 v41; // [rsp+E8h] [rbp-18h]\n__int64 v42; // [rsp+F0h] [rbp-10h]\nunsigned __int64 v43; // [rsp+F0h] [rbp-10h]\nunsigned __int64 v44; // [rsp+F8h] [rbp-8h]\nunsigned __int64 v45; // [rsp+F8h] [rbp-8h]\nunsigned __int64 v46; // [rsp+F8h] [rbp-8h]\nunsigned __int64 v47; // [rsp+F8h] [rbp-8h]\n\nv5 = a3;\nv44 = 0LL;\nif ( a3 <= 0 )\nreturn 0LL;\nv27 = HIDWORD(a4);\nwhile ( 1 )\n{\nv25 = (unsigned int)*a2;\nv42 = HIDWORD(*a2);\nv40 = v27 * v42;\nv23 = v42 * (unsigned int)a4 + v25 * v27;\nif ( v23 < v42 * (unsigned __int64)(unsigned int)a4 )\nv40 += 0x100000000LL;\nv41 = HIDWORD(v23) + v40;\nv24 = (v23 << 32) + (unsigned int)a4 * v25;\nif ( v24 < v23 << 32 )\n++v41;\nv43 = v41;\nif ( v44 + v24 < v44 )\nv43 = v41 + 1;\nv26 = *a1 + v44 + v24;\nif ( v26 < *a1 )\n++v43;\nv44 = v43;\n*a1 = v26;\nv6 = v5 - 1;\nif ( !v6 )\nbreak;\nv38 = a2[1];\nv21 = (unsigned int)v38;\nv38 >>= 32;\nv36 = v27 * v38;\nv19 = v38 * (unsigned int)a4 + v21 * v27;\nif ( v19 < v38 * (unsigned int)a4 )\nv36 += 0x100000000LL;\nv37 = HIDWORD(v19) + v36;\nv20 = (v19 << 32) + (unsigned int)a4 * v21;\nif ( v20 < v19 << 32 )\n++v37;\nv39 = v37;\nif ( v43 + v20 < v43 )\nv39 = v37 + 1;\nv45 = a1[1];\nv22 = v45 + v43 + v20;\nif ( v22 < v45 )\n++v39;\nv44 = v39;\na1[1] = v22;\nv7 = v6 - 1;\nif ( !v7 )\nbreak;\nv34 = a2[2];\nv17 = (unsigned int)v34;\nv34 >>= 32;\nv32 = v27 * v34;\nv15 = v34 * (unsigned int)a4 + v17 * v27;\nif ( v15 < v34 * (unsigned int)a4 )\nv32 += 0x100000000LL;\nv33 = HIDWORD(v15) + v32;\nv16 = (v15 << 32) + (unsigned int)a4 * v17;\nif ( v16 < v15 << 32 )\n++v33;\nv35 = v33;\nif ( v39 + v16 < v39 )\nv35 = v33 + 1;\nv46 = a1[2];\nv18 = v46 + v39 + v16;\nif ( v18 < v46 )\n++v35;\nv44 = v35;\na1[2] = v18;\nv8 = v7 - 1;\nif ( !v8 )\nbreak;\nv30 = a2[3];\nv13 = (unsigned int)v30;\nv30 >>= 32;\nv28 = v27 * v30;\nv11 = v30 * (unsigned int)a4 + v13 * v27;\nif ( v11 < v30 * (unsigned int)a4 )\nv28 += 0x100000000LL;\nv29 = HIDWORD(v11) + v28;\nv12 = (v11 << 32) + (unsigned int)a4 * v13;\nif ( v12 < v11 << 32 )\n++v29;\nv31 = v29;\nif ( v35 + v12 < v35 )\nv31 = v29 + 1;\nv47 = a1[3];\nv14 = v47 + v35 + v12;\nif ( v14 < v47 )\n++v31;\nv44 = v31;\na1[3] = v14;\nv5 = v8 - 1;\nif ( !v5 )\nbreak;\na2 += 4;\na1 += 4;\n}\nreturn v44;\n}\n```", "output": "a1: rp, long unsigned int*\na2: ap, long unsigned int*\na3: num, int\na4: w, long unsigned int\nv8: num, int\nv11: m, long unsigned int\nv12: lt, long unsigned int\nv14: l, long unsigned int\nv15: m, long unsigned int\nv16: lt, long unsigned int\nv18: l, long unsigned int\nv19: m, long unsigned int\nv20: lt, long unsigned int\nv22: l, long unsigned int\nv23: m, long unsigned int\nv24: lt, long unsigned int\nv26: l, long unsigned int\nv27: bh, long unsigned int\nv29: ht, long unsigned int\nv31: h, long unsigned int\nv33: ht, long unsigned int\nv35: h, long unsigned int\nv37: ht, long unsigned int\nv39: h, long unsigned int\nv41: ht, long unsigned int\nv43: h, long unsigned int\nv47: c, long unsigned int", "predict": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: n, int\na4: w, long unsigned int\nv8: n, int\nv11: t, long unsigned int\nv12: -, -\nv14: l, long unsigned int\nv15: t, long unsigned int\nv16: -, -\nv18: l, long unsigned int\nv19: t, long unsigned int\nv20: -, -\nv22: l, long unsigned int\nv23: t, long unsigned int\nv24: -, -\nv26: l, long unsigned int\nv27: nw, long unsigned int\nv29: l, long unsigned int\nv31: l, long unsigned int\nv33: t, long unsigned int\nv35: l, long unsigned int\nv37: t, long unsigned int\nv39: l, long unsigned int\nv41: t, long unsigned int\nv43: l, long unsigned int\nv47: l, long unsigned int", "funname": "bn_mul_add_words", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40B510"}
{"input": "What are the original name and data type of variables `a1`?\n```\n_DWORD *__fastcall sub_40AB08(_DWORD *a1)\n{\n_DWORD *result; // rax\n\nif ( (int)a1[75] <= 11 )\na1[a1[75] + 76] = *a1;\nresult = a1;\n++a1[75];\nreturn result;\n}\n```", "output": "a1: ctx, BN_CTX*", "predict": "a1: ctx, BN_CTX*", "funname": "BN_CTX_start", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40AB08"}
{"input": "What are the original name and data type of variables `a1`?\n```\nvoid __fastcall sub_40A103(__int64 a1)\n{\nmemset((void *)(a1 + 1332), 0, 0x20uLL);\nmemset((void *)(a1 + 1044), 0, 0x100uLL);\nmemset((void *)(a1 + 1300), 0, 0x20uLL);\nmemset((void *)(a1 + 472), 0, 0x28uLL);\nfree((void *)a1);\n}\n```", "output": "a1: ts, t_server*", "predict": "a1: ts, t_server*", "funname": "t_serverclose", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A103"}
{"input": "What are the original name and data type of variables `a1`?\n```\nvoid __fastcall sub_40C906(__int64 a1)\n{\nint v1; // eax\n\nif ( a1 )\n{\nif ( *(_QWORD *)a1 && (*(_DWORD *)(a1 + 20) & 2) == 0 )\nfree(*(void **)a1);\nv1 = *(_DWORD *)(a1 + 20);\nBYTE1(v1) |= 0x80u;\n*(_DWORD *)(a1 + 20) = v1;\nif ( (*(_DWORD *)(a1 + 20) & 1) != 0 )\nfree((void *)a1);\n}\n}\n```", "output": "a1: a, BIGNUM*", "predict": "a1: a, BIGNUM*", "funname": "BN_free", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C906"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_4025A8(__int64 a1)\n{\n__int64 result; // rax\n\nsub_402582(*(_QWORD **)(a1 + 8), *(_QWORD *)a1);\n*(_QWORD *)a1 = 0LL;\nresult = a1;\n*(_QWORD *)(a1 + 8) = 0LL;\nreturn result;\n}\n```", "output": "a1: entry, list_head*", "predict": "a1: entry, list_head*", "funname": "list_del", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4025A8"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `v7`, `v8`?\n```\n__int64 __fastcall sub_408E68(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)\n{\n__int64 v7; // [rsp+20h] [rbp-10h]\n__int64 v8; // [rsp+28h] [rbp-8h]\n\nv8 = sub_40A9D9();\nv7 = sub_40C999();\nsub_40CE13(v7, a3);\nsub_40AD12(a1, a2, v7, a4, v8);\nsub_40C906(v7);\nreturn sub_40AA9A(v8);\n}\n```", "output": "a1: r, BigInteger*\na2: b, BigInteger*\na3: e, unsigned int\na4: m, BigInteger*\nv7: p, BIGNUM*\nv8: ctx, BN_CTX*", "predict": "a1: r, BigInteger*\na2: b, BigInteger*\na3: e, unsigned int\na4: m, BigInteger*\nv7: p, BIGNUM*\nv8: ctx, BN_CTX*", "funname": "BigIntegerModExpInt", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408E68"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n__int64 __fastcall sub_408C21(__int64 a1, __int64 a2)\n{\nreturn sub_40D0BF(a1, a2);\n}\n```", "output": "a1: src, BigInteger*\na2: dest, unsigned char*", "predict": "a1: c1, BigInteger*\na2: c2, BigInteger*", "funname": "BigIntegerToBytes", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408C21"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_40665C(char a1)\n{\nif ( a1 > 47 && a1 <= 57 )\nreturn (unsigned int)(a1 - 48);\nif ( a1 > 96 && a1 <= 102 )\nreturn (unsigned int)(a1 - 87);\nif ( a1 <= 64 || a1 > 70 )\nreturn 0LL;\nreturn (unsigned int)(a1 - 55);\n}\n```", "output": "a1: c, char", "predict": "a1: c, char", "funname": "hexDigitToInt", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40665C"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_4064AB(int a1)\n{\nif ( !dword_413358[144 * a1 + 8] )\n{\n*(_QWORD *)&dword_413358[144 * a1 + 2] = 576LL * a1 + 4273020;\n*(_QWORD *)&dword_413358[144 * a1 + 6] = 576LL * a1 + 4273276;\ndword_413358[144 * a1] = sub_4067D8(*(void **)&dword_413358[144 * a1 + 2], off_413340[72 * a1]);\ndword_413358[144 * a1 + 4] = sub_4067D8(*(void **)&dword_413358[144 * a1 + 6], (&off_413348)[72 * a1]);\ndword_413358[144 * a1 + 8] = 1;\n}\nreturn 576LL * a1 + 4272960;\n}\n```", "output": "a1: idx, int", "predict": "a1: idx, int", "funname": "t_getpreparam", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4064AB"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v8`, `v9`, `s`, `v11`, `v12`, `v13`, `i`?\n```\n__int64 __fastcall sub_40DF1C(__int64 a1, __int64 *a2, int a3)\n{\nint v3; // eax\nint v4; // edx\nbool v5; // al\n_QWORD *v7; // rax\nint v8; // [rsp+Ch] [rbp-54h]\nunsigned __int64 v9; // [rsp+28h] [rbp-38h]\n_QWORD *s; // [rsp+30h] [rbp-30h]\n__int64 v11; // [rsp+38h] [rbp-28h]\nint v12; // [rsp+4Ch] [rbp-14h]\n__int64 v13; // [rsp+50h] [rbp-10h]\nint j; // [rsp+5Ch] [rbp-4h]\nint i; // [rsp+5Ch] [rbp-4h]\n\nv8 = a3;\n*(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);\nv3 = a3;\nv4 = a3 + 63;\nif ( v8 < 0 )\nv3 = v4;\nif ( *((_DWORD *)a2 + 2) + (v3 >> 6) < *(_DWORD *)(a1 + 12) )\nv5 = a1 == 0;\nelse\nv5 = sub_40C9FA(a1, *((_DWORD *)a2 + 2) + v8 / 64 + 1) == 0;\nif ( v5 )\nreturn 0LL;\nv12 = v8 / 64;\nv11 = *a2;\ns = *(_QWORD **)a1;\n*(_QWORD *)(8LL * (*((_DWORD *)a2 + 2) + v8 / 64) + *(_QWORD *)a1) = 0LL;\nif ( v8 % 64 )\n{\nfor ( i = *((_DWORD *)a2 + 2) - 1; i >= 0; --i )\n{\nv9 = *(_QWORD *)(8LL * i + v11);\ns[v12 + 1 + i] |= v9 >> (64 - (unsigned __int8)(v8 % 64));\ns[v12 + i] = v9 << (v8 % 64);\n}\n}\nelse\n{\nfor ( j = *((_DWORD *)a2 + 2) - 1; j >= 0; --j )\ns[v12 + j] = *(_QWORD *)(8LL * j + v11);\n}\nmemset(s, 0, 8LL * v12);\n*(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2) + v12 + 1;\nif ( *(int *)(a1 + 8) > 0 )\n{\nv13 = *(_QWORD *)a1 + 8LL * *(int *)(a1 + 8) - 8;\nwhile ( *(int *)(a1 + 8) > 0 )\n{\nv7 = (_QWORD *)v13;\nv13 -= 8LL;\nif ( *v7 )\nbreak;\n--*(_DWORD *)(a1 + 8);\n}\n}\nreturn 1LL;\n}\n```", "output": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: n, int\nv8: n, int\nv9: l, long unsigned int\ns: t, long unsigned int*\nv11: f, long unsigned int*\nv12: nw, int\nv13: ftl, long unsigned int*\ni: i, int", "predict": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: n, int\nv8: n, int\nv9: l, long unsigned int\ns: t, long unsigned int*\nv11: f, long unsigned int*\nv12: nw, int\nv13: ftl, long unsigned int*\ni: i, int", "funname": "BN_lshift", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40DF1C"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `dest`, `v7`?\n```\n__int64 __fastcall sub_4031DB(__int64 a1, __int64 a2, _DWORD *a3)\n{\n__int64 result; // rax\nconst void *v4; // rax\nchar *dest; // [rsp+20h] [rbp-20h]\nchar *v7; // [rsp+28h] [rbp-18h]\n\nif ( (unsigned int)sub_409FD9(qword_414840, a1 + 62) )\n{\n*a3 = 2;\nresult = 0LL;\n}\nelse\n{\nv7 = (char *)off_4132D8 + 42;\ndest = (char *)off_4132D8 + 62;\n*((_DWORD *)v7 + 1) = htonl(0x14u);\nv4 = (const void *)sub_40A0EF(qword_414840);\nmemmove(dest, v4, 0x14uLL);\n*a3 = 10;\nresult = 1LL;\n}\nreturn result;\n}\n```", "output": "a1: pkt, ead_packet*\na2: len, int\na3: nstate, int*\ndest: auth, ead_msg_auth*\nv7: msg, ead_msg*", "predict": "a1: pkt, ead_packet*\na2: len, int\na3: nstate, int*\ndest: auth, ead_msg_auth*\nv7: msg, ead_msg*", "funname": "handle_send_auth", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4031DB"}
{"input": "What are the original name and data type of variables `v1`?\n```\n__int64 sub_405DF7()\n{\nunsigned int v1; // [rsp+0h] [rbp-4h]\n\nv1 = (((unsigned int)dword_414EF8 >> (2 * dword_414EFC)) & 3) + 1;\ndword_414EFC = ((_BYTE)dword_414EFC + 1) & 0xF;\ndword_414EF4 += v1;\nreturn (unsigned int)dword_414EF4;\n}\n```", "output": "v1: ofs, unsigned int", "predict": "v1: ofs, unsigned int", "funname": "ead_get_tx_iv", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405DF7"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v5`?\n```\n__int64 __fastcall sub_4025F8(__int64 a1, __int64 a2, unsigned __int8 a3)\n{\n__int64 v5; // [rsp+28h] [rbp-8h]\n\nv5 = pcap_create();\nif ( v5 )\n{\npcap_set_snaplen();\npcap_set_promisc();\npcap_set_timeout();\npcap_set_buffer_size();\npcap_activate();\nsub_4025E8(v5, a3);\n}\nreturn v5;\n}\n```", "output": "a1: ifname, const char*\na2: errbuf, char*\na3: rx, _Bool\nv5: p, pcap_t*", "predict": "a1: ifname, const char*\na2: errbuf, char*\na3: rx, _Bool\nv5: p, pcap_t*", "funname": "ead_open_pcap", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4025F8"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v3`, `v4`, `i`?\n```\n__int64 __fastcall sub_40D158(__int64 a1, __int64 a2)\n{\n__int64 result; // rax\nunsigned __int64 v3; // [rsp+18h] [rbp-28h]\nunsigned __int64 v4; // [rsp+20h] [rbp-20h]\nunsigned int v5; // [rsp+3Ch] [rbp-4h]\nint i; // [rsp+3Ch] [rbp-4h]\n\nv5 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8);\nif ( v5 )\nreturn v5;\nfor ( i = *(_DWORD *)(a1 + 8) - 1; ; --i )\n{\nif ( i < 0 )\nreturn 0LL;\nv4 = *(_QWORD *)(8LL * i + *(_QWORD *)a1);\nv3 = *(_QWORD *)(8LL * i + *(_QWORD *)a2);\nif ( v4 != v3 )\nbreak;\n}\nif ( v4 <= v3 )\nresult = 0xFFFFFFFFLL;\nelse\nresult = 1LL;\nreturn result;\n}\n```", "output": "a1: a, const BIGNUM*\na2: b, const BIGNUM*\nv3: t2, long unsigned int\nv4: t1, long unsigned int\ni: i, int", "predict": "a1: a, const BIGNUM*\na2: b, const BIGNUM*\nv3: t2, long unsigned int\nv4: t1, long unsigned int\ni: i, int", "funname": "BN_ucmp", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D158"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v5`, `v6`, `v7`, `v8)()`?\n```\n__int64 __fastcall sub_4036C6(__int64 a1, unsigned int a2)\n{\n__int64 result; // rax\nint v3; // eax\nint v4; // edx\nint v5; // [rsp+1Ch] [rbp-14h] BYREF\nuint32_t v6; // [rsp+20h] [rbp-10h]\nint v7; // [rsp+24h] [rbp-Ch]\n__int64 (__fastcall *v8)(); // [rsp+28h] [rbp-8h]\n\nv7 = 62;\nv5 = dword_4132E4;\nv6 = ntohl(*(_DWORD *)(a1 + 50));\nif ( (int)v6 <= 3 || (result = (unsigned int)dword_4132E4, v6 == dword_4132E4) )\n{\nif ( !v6\n|| (LOWORD(v3) = ntohs(*(_WORD *)(a1 + 56)),\nv4 = (v3 >> 12) & 0xF,\nresult = (unsigned int)*(char *)(qword_414838 + 36),\nv4 == (_DWORD)result) )\n{\nresult = v6;\nswitch ( v6 )\n{\ncase 0u:\nv8 = sub_402EC2;\ngoto LABEL_12;\ncase 2u:\nv8 = (__int64 (__fastcall *)())sub_402F7E;\nv7 += 32;\ngoto LABEL_12;\ncase 4u:\nv8 = (__int64 (__fastcall *)())sub_402FFB;\ngoto LABEL_12;\ncase 6u:\nv8 = (__int64 (__fastcall *)())sub_4030D5;\n++v7;\ngoto LABEL_12;\ncase 8u:\nv8 = (__int64 (__fastcall *)())sub_4031DB;\nv7 += 20;\ngoto LABEL_12;\ncase 0xAu:\nv8 = (__int64 (__fastcall *)())sub_40329D;\nv7 += 28;\nLABEL_12:\nresult = a2;\nif ( (int)a2 >= v7 )\n{\n*(_DWORD *)((char *)off_4132D8 + 42) = htonl(0xDADACAFE);\n*(_DWORD *)((char *)off_4132D8 + 50) = htonl(v6 + 1);\n*((_WORD *)off_4132D8 + 27) = htons(word_4132E0);\n*((_WORD *)off_4132D8 + 28) = *(_WORD *)(a1 + 56);\n*(_DWORD *)((char *)off_4132D8 + 46) = 0;\nif ( ((unsigned __int8 (__fastcall *)(__int64, _QWORD, int *))v8)(a1, a2, &v5) )\nsub_402B6D(a1);\nresult = sub_402DA1(v5);\n}\nbreak;\ndefault:\nreturn result;\n}\n}\n}\nreturn result;\n}\n```", "output": "a1: pkt, ead_packet*\na2: len, int\nv5: nstate, int\nv6: type, int\nv7: min_len, int\nv8)(): handler, _Bool*", "predict": "a1: pkt, ead_packet*\na2: len, int\nv5: nstate, int\nv6: type, int\nv7: min_len, int\nv8)(): handler, _Bool*", "funname": "parse_message", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4036C6"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_40A0EF(__int64 a1)\n{\nreturn a1 + 512;\n}\n```", "output": "a1: ts, t_server*", "predict": "a1: ts, t_server*", "funname": "t_serverresponse", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A0EF"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `v7`?\n```\n__int64 __fastcall sub_408E19(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n__int64 v7; // [rsp+28h] [rbp-8h]\n\nv7 = sub_40A9D9();\nsub_40AD12(a1, a2, a3, a4, v7);\nreturn sub_40AA9A(v7);\n}\n```", "output": "a1: r, BigInteger*\na2: b, BigInteger*\na3: e, BigInteger*\na4: m, BigInteger*\nv7: ctx, BN_CTX*", "predict": "a1: r, BigInteger*\na2: m1, BigInteger*\na3: m2, BigInteger*\na4: modulus, BigInteger*\nv7: ctx, BN_CTX*", "funname": "BigIntegerModExp", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408E19"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `a5`, `v13`, `v14`, `v15`, `v16`, `v17`, `v18`, `v19`, `v20`, `v21`, `v22`, `v23`, `v24`, `v25`, `v26`, `v27`, `v28`, `v29`, `v30`, `v31`, `v32`, `v33`, `v34`, `v35`, `v36`, `v37`, `v38`, `v39`, `v40`, `v41`, `j`, `i`?\n```\n__int64 __fastcall sub_40D754(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)\n{\n__int64 v6; // rax\n_QWORD *v9; // rax\n__int64 v13; // [rsp+30h] [rbp-E0h] BYREF\nint v14; // [rsp+38h] [rbp-D8h]\nint v15; // [rsp+3Ch] [rbp-D4h]\nint v16; // [rsp+40h] [rbp-D0h]\nunsigned __int64 v17; // [rsp+50h] [rbp-C0h]\nunsigned __int64 v18; // [rsp+58h] [rbp-B8h]\nunsigned __int64 v19; // [rsp+60h] [rbp-B0h]\nunsigned __int64 v20; // [rsp+68h] [rbp-A8h]\nunsigned __int64 v21; // [rsp+70h] [rbp-A0h]\n__int64 v22; // [rsp+78h] [rbp-98h]\nunsigned __int64 v23; // [rsp+80h] [rbp-90h]\nunsigned __int64 v24; // [rsp+88h] [rbp-88h]\nunsigned __int64 v25; // [rsp+90h] [rbp-80h]\nunsigned __int64 v26; // [rsp+98h] [rbp-78h]\nint v27; // [rsp+A0h] [rbp-70h]\nint v28; // [rsp+A4h] [rbp-6Ch]\nint v29; // [rsp+A8h] [rbp-68h]\nunsigned int v30; // [rsp+ACh] [rbp-64h]\n__int64 v31; // [rsp+B0h] [rbp-60h]\n__int64 v32; // [rsp+B8h] [rbp-58h]\n__int64 v33; // [rsp+C0h] [rbp-50h]\nunsigned __int64 v34; // [rsp+C8h] [rbp-48h]\nunsigned __int64 v35; // [rsp+D0h] [rbp-40h]\nunsigned __int64 v36; // [rsp+D8h] [rbp-38h]\nunsigned __int64 v37; // [rsp+E0h] [rbp-30h]\nunsigned __int64 v38; // [rsp+E8h] [rbp-28h]\nunsigned __int64 *v39; // [rsp+F0h] [rbp-20h]\n_QWORD *v40; // [rsp+F8h] [rbp-18h]\n__int64 v41; // [rsp+100h] [rbp-10h]\nint j; // [rsp+108h] [rbp-8h]\nint i; // [rsp+10Ch] [rbp-4h]\n\nif ( !*(_DWORD *)(a4 + 8) || *(_DWORD *)(a4 + 8) == 1 && !**(_QWORD **)a4 )\nreturn 0LL;\nif ( (int)sub_40D158(a3, a4) < 0 )\n{\nif ( a2 && !sub_40CC70(a2, a3) )\nreturn 0LL;\nif ( a1 )\nsub_40CE13(a1, 0LL);\nreturn 1LL;\n}\nsub_40AB08(a5);\nv33 = sub_40AB57(a5);\n*(_DWORD *)(v33 + 16) = 0;\nv32 = sub_40AB57(a5);\nv31 = sub_40AB57(a5);\nif ( a1 )\nv41 = a1;\nelse\nv41 = sub_40AB57(a5);\nif ( !v41 )\ngoto LABEL_57;\nv30 = 64 - (int)sub_40C804(a4) % 64;\nsub_40DF1C(v31, a4, v30);\n*(_DWORD *)(v31 + 16) = 0;\nv30 += 64;\nsub_40DF1C(v32, a3, v30);\n*(_DWORD *)(v32 + 16) = 0;\nv29 = *(_DWORD *)(v31 + 8);\nv28 = *(_DWORD *)(v32 + 8);\nv27 = v28 - v29;\nsub_40C974(&v13);\nv13 = *(_QWORD *)v32 + 8LL * v27;\nv14 = v29;\nv15 = *(_DWORD *)(v32 + 12) + 1;\nv26 = *(_QWORD *)(*(_QWORD *)v31 + 8LL * v29 - 8);\nv6 = v29 == 1 ? 0LL : *(_QWORD *)(*(_QWORD *)v31 + 8LL * v29 - 16);\nv25 = v6;\nv39 = (unsigned __int64 *)(*(_QWORD *)v32 + 8LL * v28 - 8);\n*(_DWORD *)(v41 + 16) = *(_DWORD *)(a4 + 16) ^ *(_DWORD *)(a3 + 16);\nif ( v27 >= *(_DWORD *)(v41 + 12) ? sub_40C9FA(v41, v27 + 1) == 0 : v41 == 0 )\ngoto LABEL_57;\n*(_DWORD *)(v41 + 8) = v27;\nv40 = (_QWORD *)(*(_QWORD *)v41 + 8LL * v27 - 8);\nif ( v29 >= *(_DWORD *)(v33 + 12) ? sub_40C9FA(v33, v29 + 1) == 0 : v33 == 0 )\ngoto LABEL_57;\nif ( (int)sub_40D158((__int64)&v13, v31) >= 0 )\n{\nif ( (unsigned int)sub_40A626((__int64)&v13, (__int64)&v13, v31) )\n{\n*v40 = 1LL;\n*(_QWORD *)(*(_QWORD *)v41 + 8LL * *(int *)(v41 + 8) - 8) = 1LL;\ngoto LABEL_31;\n}\nLABEL_57:\nsub_40ABC8(a5);\nreturn 0LL;\n}\n--*(_DWORD *)(v41 + 8);\nLABEL_31:\n--v40;\nfor ( i = 0; i < v27 - 1; ++i )\n{\nv37 = 0LL;\nv24 = *v39;\nv23 = *(v39 - 1);\nif ( v24 == v26 )\n{\nv38 = -1LL;\n}\nelse\n{\nv38 = sub_40C2DF(v24, v23, v26);\nv37 = v23 - v26 * v38;\nv36 = (unsigned int)v25;\nv35 = HIDWORD(v25);\nv22 = (unsigned int)v38;\nv21 = HIDWORD(v38);\nv19 = (unsigned int)v25 * HIDWORD(v38);\nv20 = (unsigned int)v38 * (unsigned __int64)(unsigned int)v25;\nv18 = HIDWORD(v25) * (unsigned int)v38;\nv34 = HIDWORD(v38) * HIDWORD(v25);\nv19 += v18;\nif ( v19 < v18 )\nv34 += 0x100000000LL;\nv34 += HIDWORD(v19);\nv18 = v19 << 32;\nv20 += v19 << 32;\nif ( v20 < v19 << 32 )\n++v34;\nv36 = v20;\nv35 = v34;\nwhile ( v35 >= v37 && (v35 != v37 || v36 > *(v39 - 2)) )\n{\n--v38;\nv37 += v26;\nif ( v37 < v26 )\nbreak;\nif ( v36 < v25 )\n--v35;\nv36 -= v25;\n}\n}\nv17 = sub_40BB0A(*(_QWORD **)v33, *(_QWORD **)v31, v29, v38);\nv13 -= 8LL;\n++v14;\n*(_QWORD *)(8LL * v29 + *(_QWORD *)v33) = v17;\nfor ( j = v29 + 1; j > 0 && !*(_QWORD *)(*(_QWORD *)v33 + 8LL * j - 8); --j )\n;\n*(_DWORD *)(v33 + 8) = j;\nj = v14;\nsub_40A857((__int64)&v13, (__int64)&v13, v33);\n*(_DWORD *)(v32 + 8) = *(_DWORD *)(v32 + 8) + v14 - j;\nif ( v16 )\n{\n--v38;\nj = v14;\nsub_40A34C((__int64)&v13, (__int64)&v13, v31);\n*(_DWORD *)(v32 + 8) += v14 - j;\n}\nv9 = v40--;\n*v9 = v38;\n--v39;\n}\nif ( a2 )\n{\nsub_40E1BA(a2, v32, v30);\n*(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);\n}\nsub_40ABC8(a5);\nreturn 1LL;\n}\n```", "output": "a1: dv, BIGNUM*\na2: rm, BIGNUM*\na3: num, const BIGNUM*\na4: divisor, const BIGNUM*\na5: ctx, BN_CTX*\nv13: wnum, struct BIGNUM\nv14: -, -\nv15: -, -\nv16: -, -\nv17: l0, long unsigned int\nv18: m1, long unsigned int\nv19: m, long unsigned int\nv20: lt, long unsigned int\nv21: qh, long unsigned int\nv22: ql, long unsigned int\nv23: n1, long unsigned int\nv24: n0, long unsigned int\nv25: d1, long unsigned int\nv26: d0, long unsigned int\nv27: loop, int\nv28: num_n, int\nv29: div_n, int\nv30: norm_shift, int\nv31: sdiv, BIGNUM*\nv32: snum, BIGNUM*\nv33: tmp, BIGNUM*\nv34: ht, long unsigned int\nv35: t2h, long unsigned int\nv36: t2l, long unsigned int\nv37: rem, long unsigned int\nv38: q, long unsigned int\nv39: wnump, long unsigned int*\nv40: resp, long unsigned int*\nv41: res, BIGNUM*\nj: j, int\ni: i, int", "predict": "a1: r, BIGNUM*\na2: rp, BIGNUM*\na3: a, const BIGNUM*\na4: b, const BIGNUM*\na5: ctx, BN_CTX*\nv13: t, struct BIGNUM\nv14: -, -\nv15: -, -\nv16: -, -\nv17: l, long unsigned int\nv18: rr, long unsigned int\nv19: ll, long unsigned int\nv20: high, long unsigned int\nv21: high, long unsigned int\nv22: low, long unsigned int\nv23: f, long unsigned int\nv24: e, long unsigned int\nv25: d, long unsigned int\nv26: c, long unsigned int\nv27: sb, int\nv28: sa, int\nv29: sb, int\nv30: top, int\nv31: v, BIGNUM*\nv32: u, BIGNUM*\nv33: t1, BIGNUM*\nv34: h2, long unsigned int\nv35: h1, long unsigned int\nv36: l1, long unsigned int\nv37: l0, long unsigned int\nv38: j, long unsigned int\nv39: ftl, long unsigned int*\nv40: fop, long unsigned int*\nv41: t0, BIGNUM*\nj: k, int\ni: i, int", "funname": "BN_div", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D754", "cluster_var": {"struct": [["v13", "v14", "v15", "v16"]]}}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_408EDD(__int64 a1)\n{\nreturn sub_40C906(a1);\n}\n```", "output": "a1: b, BigInteger*", "predict": "a1: b, BigInteger*", "funname": "BigIntegerFree", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408EDD"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v9`, `v11`, `v12`, `v13`, `v14`, `v15`?\n```\n_DWORD *__fastcall sub_40CF0A(unsigned __int8 *a1, int a2, _DWORD *a3)\n{\n_DWORD *result; // rax\nint v4; // eax\nbool v5; // al\nunsigned __int8 *v6; // rax\n_QWORD *v8; // rax\n_DWORD *v9; // [rsp+8h] [rbp-38h]\n__int64 v11; // [rsp+20h] [rbp-20h]\n__int64 v12; // [rsp+28h] [rbp-18h]\nint v13; // [rsp+34h] [rbp-Ch]\nint v14; // [rsp+38h] [rbp-8h]\nunsigned int v15; // [rsp+3Ch] [rbp-4h]\n\nv9 = a3;\nif ( !a3 )\nv9 = sub_40C999();\nif ( !v9 )\nreturn 0LL;\nv12 = 0LL;\nv13 = a2;\nif ( a2 )\n{\nif ( (8 * (a2 + 10) - 1) / 64 <= v9[3] )\n{\nv5 = v9 == 0LL;\n}\nelse\n{\nv4 = a2 + 2;\nif ( a2 + 2 < 0 )\nv4 = a2 + 9;\nv5 = sub_40C9FA((__int64)v9, (v4 >> 3) + 1) == 0;\n}\nif ( v5 )\n{\nresult = 0LL;\n}\nelse\n{\nv15 = ((unsigned int)(a2 - 1) >> 3) + 1;\nv14 = ((_BYTE)a2 - 1) & 7;\nv9[2] = v15;\nwhile ( v13-- )\n{\nv6 = a1++;\nv12 = (v12 << 8) | *v6;\nLODWORD(v6) = v14--;\nif ( !(_DWORD)v6 )\n{\n*(_QWORD *)(8LL * --v15 + *(_QWORD *)v9) = v12;\nv12 = 0LL;\nv14 = 7;\n}\n}\nif ( (int)v9[2] > 0 )\n{\nv11 = *(_QWORD *)v9 + 8LL * (int)v9[2] - 8;\nwhile ( (int)v9[2] > 0 )\n{\nv8 = (_QWORD *)v11;\nv11 -= 8LL;\nif ( *v8 )\nbreak;\n--v9[2];\n}\n}\nresult = v9;\n}\n}\nelse\n{\nv9[2] = 0;\nresult = v9;\n}\nreturn result;\n}\n```", "output": "a1: s, const unsigned char*\na2: len, int\na3: ret, BIGNUM*\nv9: ret, BIGNUM*\nv11: ftl, long unsigned int*\nv12: l, long unsigned int\nv13: n, unsigned int\nv14: m, unsigned int\nv15: i, unsigned int", "predict": "a1: s, const unsigned char*\na2: len, int\na3: ret, BIGNUM*\nv9: ret, BIGNUM*\nv11: ftl, long unsigned int*\nv12: l, long unsigned int\nv13: n, unsigned int\nv14: m, unsigned int\nv15: i, unsigned int", "funname": "BN_bin2bn", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40CF0A"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v29`, `v30`, `v31`, `v32`, `v33`, `v34`, `v36`, `v38`, `v40`, `v42`?\n```\n_BYTE *__fastcall sub_4054D5(_DWORD *a1, unsigned __int8 *a2, _BYTE *a3)\n{\nint v3; // ebx\nint v4; // ebx\nint v5; // ebx\nint v6; // ebx\nint v7; // ebx\nint v8; // ebx\nint v9; // ebx\nint v10; // ebx\nint v11; // ebx\nint v12; // ebx\nint v13; // ebx\nint v14; // ebx\nint v15; // ebx\nint v16; // ebx\nint v17; // ebx\nint v18; // ebx\nint v19; // ebx\nint v20; // ebx\nint v21; // ebx\nint v22; // ebx\nint v23; // ebx\nint v24; // ebx\nint v25; // ebx\nint v26; // ebx\n_BYTE *result; // rax\n_DWORD *v29; // [rsp+10h] [rbp-40h]\nunsigned int v30; // [rsp+20h] [rbp-30h]\nunsigned int v31; // [rsp+24h] [rbp-2Ch]\nunsigned int v32; // [rsp+28h] [rbp-28h]\nunsigned int v33; // [rsp+2Ch] [rbp-24h]\nint v34; // [rsp+34h] [rbp-1Ch]\nunsigned int v35; // [rsp+38h] [rbp-18h]\nint v36; // [rsp+38h] [rbp-18h]\nunsigned int v37; // [rsp+3Ch] [rbp-14h]\nint v38; // [rsp+3Ch] [rbp-14h]\nunsigned int v39; // [rsp+40h] [rbp-10h]\nint v40; // [rsp+40h] [rbp-10h]\nunsigned int v41; // [rsp+44h] [rbp-Ch]\nint v42; // [rsp+44h] [rbp-Ch]\n\nv29 = a1;\nv41 = a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24) ^ *a1;\nv39 = a2[7] ^ (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24) ^ a1[1];\nv37 = a2[11] ^ (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24) ^ a1[2];\nv35 = a2[15] ^ (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24) ^ a1[3];\nv34 = 5;\nwhile ( 1 )\n{\nv3 = dword_40F8C0[HIBYTE(v41)];\nv4 = sub_4046BB(dword_40F8C0[BYTE2(v35)], 8) ^ v3;\nv5 = sub_4046BB(dword_40F8C0[BYTE1(v37)], 16) ^ v4;\nv33 = sub_4046BB(dword_40F8C0[(unsigned __int8)v39], 24) ^ v5 ^ v29[4];\nv6 = dword_40F8C0[HIBYTE(v39)];\nv7 = sub_4046BB(dword_40F8C0[BYTE2(v41)], 8) ^ v6;\nv8 = sub_4046BB(dword_40F8C0[BYTE1(v35)], 16) ^ v7;\nv32 = sub_4046BB(dword_40F8C0[(unsigned __int8)v37], 24) ^ v8 ^ v29[5];\nv9 = dword_40F8C0[HIBYTE(v37)];\nv10 = sub_4046BB(dword_40F8C0[BYTE2(v39)], 8) ^ v9;\nv11 = sub_4046BB(dword_40F8C0[BYTE1(v41)], 16) ^ v10;\nv31 = sub_4046BB(dword_40F8C0[(unsigned __int8)v35], 24) ^ v11 ^ v29[6];\nv12 = dword_40F8C0[HIBYTE(v35)];\nv13 = sub_4046BB(dword_40F8C0[BYTE2(v37)], 8) ^ v12;\nv14 = sub_4046BB(dword_40F8C0[BYTE1(v39)], 16) ^ v13;\nv30 = sub_4046BB(dword_40F8C0[(unsigned __int8)v41], 24) ^ v14 ^ v29[7];\nv29 += 8;\nif ( !--v34 )\nbreak;\nv15 = dword_40F8C0[HIBYTE(v33)];\nv16 = sub_4046BB(dword_40F8C0[BYTE2(v30)], 8) ^ v15;\nv17 = sub_4046BB(dword_40F8C0[BYTE1(v31)], 16) ^ v16;\nv41 = sub_4046BB(dword_40F8C0[(unsigned __int8)v32], 24) ^ v17 ^ *v29;\nv18 = dword_40F8C0[HIBYTE(v32)];\nv19 = sub_4046BB(dword_40F8C0[BYTE2(v33)], 8) ^ v18;\nv20 = sub_4046BB(dword_40F8C0[BYTE1(v30)], 16) ^ v19;\nv39 = sub_4046BB(dword_40F8C0[(unsigned __int8)v31], 24) ^ v20 ^ v29[1];\nv21 = dword_40F8C0[HIBYTE(v31)];\nv22 = sub_4046BB(dword_40F8C0[BYTE2(v32)], 8) ^ v21;\nv23 = sub_4046BB(dword_40F8C0[BYTE1(v33)], 16) ^ v22;\nv37 = sub_4046BB(dword_40F8C0[(unsigned __int8)v30], 24) ^ v23 ^ v29[2];\nv24 = dword_40F8C0[HIBYTE(v30)];\nv25 = sub_4046BB(dword_40F8C0[BYTE2(v31)], 8) ^ v24;\nv26 = sub_4046BB(dword_40F8C0[BYTE1(v32)], 16) ^ v25;\nv35 = sub_4046BB(dword_40F8C0[(unsigned __int8)v33], 24) ^ v26 ^ v29[3];\n}\nv42 = ((unsigned __int8)byte_40FCC0[BYTE1(v31)] << 8) ^ ((unsigned __int8)byte_40FCC0[BYTE2(v30)] << 16) ^ ((unsigned __int8)byte_40FCC0[HIBYTE(v33)] << 24) ^ (unsigned __int8)byte_40FCC0[(unsigned __int8)v32] ^ *v29;\n*a3 = HIBYTE(v42);\na3[1] = BYTE2(v42);\na3[2] = BYTE1(v42);\na3[3] = v42;\nv40 = ((unsigned __int8)byte_40FCC0[BYTE1(v30)] << 8) ^ ((unsigned __int8)byte_40FCC0[BYTE2(v33)] << 16) ^ ((unsigned __int8)byte_40FCC0[HIBYTE(v32)] << 24) ^ (unsigned __int8)byte_40FCC0[(unsigned __int8)v31] ^ v29[1];\na3[4] = HIBYTE(v40);\na3[5] = BYTE2(v40);\na3[6] = BYTE1(v40);\na3[7] = v40;\nv38 = ((unsigned __int8)byte_40FCC0[BYTE1(v33)] << 8) ^ ((unsigned __int8)byte_40FCC0[BYTE2(v32)] << 16) ^ ((unsigned __int8)byte_40FCC0[HIBYTE(v31)] << 24) ^ (unsigned __int8)byte_40FCC0[(unsigned __int8)v30] ^ v29[2];\na3[8] = HIBYTE(v38);\na3[9] = BYTE2(v38);\na3[10] = BYTE1(v38);\na3[11] = v38;\nv36 = ((unsigned __int8)byte_40FCC0[BYTE1(v32)] << 8) ^ ((unsigned __int8)byte_40FCC0[BYTE2(v31)] << 16) ^ ((unsigned __int8)byte_40FCC0[HIBYTE(v30)] << 24) ^ (unsigned __int8)byte_40FCC0[(unsigned __int8)v33] ^ v29[3];\na3[12] = HIBYTE(v36);\na3[13] = BYTE2(v36);\na3[14] = BYTE1(v36);\nresult = a3 + 15;\na3[15] = v36;\nreturn result;\n}\n```", "output": "a1: rk, const u32*\na2: ct, const u8*\na3: pt, u8*\nv29: rk, const u32*\nv30: t3, u32\nv31: t2, u32\nv32: t1, u32\nv33: t0, u32\nv34: r, int\nv36: s3, u32\nv38: s2, u32\nv40: s1, u32\nv42: s0, u32", "predict": "a1: rk, u32*\na2: cipherKey, const u8*\na3: plainKey, u8*\nv29: rk, u32*\nv30: temp, u32\nv31: -, -\nv32: -, -\nv33: -, -\nv34: loop, int\nv36: d, u32\nv38: c, u32\nv40: b, u32\nv42: a, u32", "funname": "rijndaelDecrypt", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4054D5"}
{"input": "What are the original name and data type of variables `v13`, `v14`, `v15`, `v16`, `v17`, `v18`?\n```\n_BYTE *__fastcall sub_406A95(_BYTE *a1, unsigned __int8 *a2, unsigned int a3)\n{\n_BYTE *v3; // rax\n_BYTE *v6; // rdx\n_BYTE *v7; // rdx\n_BYTE *v8; // rdx\n_BYTE *v9; // rdx\nunsigned int v10; // edx\nint v12; // [rsp+0h] [rbp-14h]\nint v13; // [rsp+0h] [rbp-14h]\nchar v14; // [rsp+Ch] [rbp-8h]\nunsigned __int8 v15; // [rsp+Dh] [rbp-7h]\nunsigned __int8 v16; // [rsp+Eh] [rbp-6h]\nunsigned __int8 v17; // [rsp+Fh] [rbp-5h]\nunsigned int v18; // [rsp+10h] [rbp-4h]\n\nv3 = a1;\nv18 = a3 % 3;\nv17 = 0;\nv16 = 0;\nv15 = 0;\nv14 = 0;\nif ( a3 % 3 == 1 )\n{\nv15 = *a2;\n}\nelse if ( v18 == 2 )\n{\nv16 = *a2;\nv15 = a2[1];\n}\nwhile ( 1 )\n{\nif ( v14 || v17 >> 2 )\n{\nv6 = v3++;\n*v6 = a0123456789abcd[v17 >> 2];\nv14 = 1;\n}\nv12 = (16 * v17) & 0x30 | (v16 >> 4);\nif ( v14 || v12 )\n{\nv7 = v3++;\n*v7 = a0123456789abcd[v12];\nv14 = 1;\n}\nv13 = (4 * v16) & 0x3C | (v15 >> 6);\nif ( v14 || v13 )\n{\nv8 = v3++;\n*v8 = a0123456789abcd[v13];\nv14 = 1;\n}\nif ( v14 || (v15 & 0x3F) != 0 )\n{\nv9 = v3++;\n*v9 = a0123456789abcd[v15 & 0x3F];\nv14 = 1;\n}\nif ( a3 <= v18 )\nbreak;\nv17 = a2[v18];\nv16 = a2[v18 + 1];\nv10 = v18 + 2;\nv18 += 3;\nv15 = a2[v10];\n}\n*v3 = 0;\nreturn a1;\n}\n```", "output": "v13: c, int\nv14: notleading, unsigned char\nv15: b2, unsigned char\nv16: b1, unsigned char\nv17: b0, unsigned char\nv18: pos, int", "predict": "v13: c, int\nv14: notleading, unsigned char\nv15: b2, unsigned char\nv16: b1, unsigned char\nv17: b0, unsigned char\nv18: pos, int", "funname": "t_tob64", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "406A95"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `v8`, `v11`, `v12`, `v13`, `v14`, `v15`, `v16`, `v17`, `v18`, `v19`, `v20`, `v21`, `v23`, `v24`, `v26`, `v28`, `v30`, `v32`, `v34`, `v36`, `v38`, `v40`, `v41`?\n```\nunsigned __int64 __fastcall sub_40BB0A(_QWORD *a1, _QWORD *a2, int a3, unsigned __int64 a4)\n{\nint v5; // [rsp+Ch] [rbp-F4h]\nint v6; // [rsp+Ch] [rbp-F4h]\nint v7; // [rsp+Ch] [rbp-F4h]\nint v8; // [rsp+Ch] [rbp-F4h]\nunsigned __int64 v11; // [rsp+30h] [rbp-D0h]\nunsigned __int64 v12; // [rsp+38h] [rbp-C8h]\n__int64 v13; // [rsp+40h] [rbp-C0h]\nunsigned __int64 v14; // [rsp+50h] [rbp-B0h]\nunsigned __int64 v15; // [rsp+58h] [rbp-A8h]\n__int64 v16; // [rsp+60h] [rbp-A0h]\nunsigned __int64 v17; // [rsp+70h] [rbp-90h]\nunsigned __int64 v18; // [rsp+78h] [rbp-88h]\n__int64 v19; // [rsp+80h] [rbp-80h]\nunsigned __int64 v20; // [rsp+90h] [rbp-70h]\nunsigned __int64 v21; // [rsp+98h] [rbp-68h]\n__int64 v22; // [rsp+A0h] [rbp-60h]\n__int64 v23; // [rsp+A0h] [rbp-60h]\nunsigned __int64 v24; // [rsp+A8h] [rbp-58h]\n__int64 v25; // [rsp+B8h] [rbp-48h]\nunsigned __int64 v26; // [rsp+B8h] [rbp-48h]\nunsigned __int64 v27; // [rsp+C0h] [rbp-40h]\nunsigned __int64 v28; // [rsp+C0h] [rbp-40h]\n__int64 v29; // [rsp+C8h] [rbp-38h]\nunsigned __int64 v30; // [rsp+C8h] [rbp-38h]\nunsigned __int64 v31; // [rsp+D0h] [rbp-30h]\nunsigned __int64 v32; // [rsp+D0h] [rbp-30h]\n__int64 v33; // [rsp+D8h] [rbp-28h]\nunsigned __int64 v34; // [rsp+D8h] [rbp-28h]\nunsigned __int64 v35; // [rsp+E0h] [rbp-20h]\nunsigned __int64 v36; // [rsp+E0h] [rbp-20h]\n__int64 v37; // [rsp+E8h] [rbp-18h]\nunsigned __int64 v38; // [rsp+E8h] [rbp-18h]\n__int64 v39; // [rsp+F0h] [rbp-10h]\nunsigned __int64 v40; // [rsp+F0h] [rbp-10h]\nunsigned __int64 v41; // [rsp+F8h] [rbp-8h]\n\nv5 = a3;\nv41 = 0LL;\nif ( a3 <= 0 )\nreturn 0LL;\nv24 = HIDWORD(a4);\nwhile ( 1 )\n{\nv22 = (unsigned int)*a2;\nv39 = HIDWORD(*a2);\nv37 = v24 * v39;\nv20 = v39 * (unsigned int)a4 + v22 * v24;\nif ( v20 < v39 * (unsigned __int64)(unsigned int)a4 )\nv37 += 0x100000000LL;\nv38 = HIDWORD(v20) + v37;\nv21 = (v20 << 32) + (unsigned int)a4 * v22;\nif ( v21 < v20 << 32 )\n++v38;\nv40 = v38;\nv23 = v41 + v21;\nif ( v41 + v21 < v41 )\nv40 = v38 + 1;\nv41 = v40;\n*a1 = v23;\nv6 = v5 - 1;\nif ( !v6 )\nbreak;\nv35 = a2[1];\nv19 = (unsigned int)v35;\nv35 >>= 32;\nv33 = v24 * v35;\nv17 = v35 * (unsigned int)a4 + v19 * v24;\nif ( v17 < v35 * (unsigned int)a4 )\nv33 += 0x100000000LL;\nv34 = HIDWORD(v17) + v33;\nv18 = (v17 << 32) + (unsigned int)a4 * v19;\nif ( v18 < v17 << 32 )\n++v34;\nv36 = v34;\nif ( v40 + v18 < v40 )\nv36 = v34 + 1;\nv41 = v36;\na1[1] = v40 + v18;\nv7 = v6 - 1;\nif ( !v7 )\nbreak;\nv31 = a2[2];\nv16 = (unsigned int)v31;\nv31 >>= 32;\nv29 = v24 * v31;\nv14 = v31 * (unsigned int)a4 + v16 * v24;\nif ( v14 < v31 * (unsigned int)a4 )\nv29 += 0x100000000LL;\nv30 = HIDWORD(v14) + v29;\nv15 = (v14 << 32) + (unsigned int)a4 * v16;\nif ( v15 < v14 << 32 )\n++v30;\nv32 = v30;\nif ( v36 + v15 < v36 )\nv32 = v30 + 1;\nv41 = v32;\na1[2] = v36 + v15;\nv8 = v7 - 1;\nif ( !v8 )\nbreak;\nv27 = a2[3];\nv13 = (unsigned int)v27;\nv27 >>= 32;\nv25 = v24 * v27;\nv11 = v27 * (unsigned int)a4 + v13 * v24;\nif ( v11 < v27 * (unsigned int)a4 )\nv25 += 0x100000000LL;\nv26 = HIDWORD(v11) + v25;\nv12 = (v11 << 32) + (unsigned int)a4 * v13;\nif ( v12 < v11 << 32 )\n++v26;\nv28 = v26;\nif ( v32 + v12 < v32 )\nv28 = v26 + 1;\nv41 = v28;\na1[3] = v32 + v12;\nv5 = v8 - 1;\nif ( !v5 )\nbreak;\na2 += 4;\na1 += 4;\n}\nreturn v41;\n}\n```", "output": "a1: rp, long unsigned int*\na2: ap, long unsigned int*\na3: num, int\na4: w, long unsigned int\nv8: num, int\nv11: m, long unsigned int\nv12: lt, long unsigned int\nv13: l, long unsigned int\nv14: m, long unsigned int\nv15: lt, long unsigned int\nv16: l, long unsigned int\nv17: m, long unsigned int\nv18: lt, long unsigned int\nv19: l, long unsigned int\nv20: m, long unsigned int\nv21: lt, long unsigned int\nv23: l, long unsigned int\nv24: bh, long unsigned int\nv26: ht, long unsigned int\nv28: h, long unsigned int\nv30: ht, long unsigned int\nv32: h, long unsigned int\nv34: ht, long unsigned int\nv36: h, long unsigned int\nv38: ht, long unsigned int\nv40: h, long unsigned int\nv41: carry, long unsigned int", "predict": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: n, int\na4: w, long unsigned int\nv8: n, int\nv11: m, long unsigned int\nv12: l, long unsigned int\nv13: k, long unsigned int\nv14: m, long unsigned int\nv15: l, long unsigned int\nv16: k, long unsigned int\nv17: m, long unsigned int\nv18: l, long unsigned int\nv19: k, long unsigned int\nv20: m, long unsigned int\nv21: l, long unsigned int\nv23: t, long unsigned int\nv24: nw, long unsigned int\nv26: h, long unsigned int\nv28: g, long unsigned int\nv30: f, long unsigned int\nv32: e, long unsigned int\nv34: d, long unsigned int\nv36: c, long unsigned int\nv38: b, long unsigned int\nv40: a, long unsigned int\nv41: r2, long unsigned int", "funname": "bn_mul_words", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40BB0A"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_402DA1(int a1)\n{\n__int64 result; // rax\n\nresult = (unsigned int)dword_4132E4;\nif ( a1 != dword_4132E4 )\n{\nif ( a1 < dword_4132E4 )\n{\nif ( a1 <= 3 && dword_4132E4 > 3 )\n{\nsub_40A103(qword_414840);\nqword_414840 = 0LL;\n}\ngoto LABEL_17;\n}\nif ( dword_4132E4 == 6 )\n{\nqword_413F28 = sub_409B94(qword_414840, &dword_414850);\nresult = qword_413F28;\nif ( !qword_413F28 )\nreturn result;\nsub_405D19(qword_413F28);\ngoto LABEL_17;\n}\nif ( dword_4132E4 > 6 )\ngoto LABEL_17;\nif ( dword_4132E4 != 2 )\n{\nif ( dword_4132E4 == 4 )\nqword_414860 = sub_4099DA(qword_414840);\ngoto LABEL_17;\n}\nresult = (unsigned int)sub_40270A() ^ 1;\nif ( !(_BYTE)result )\n{\nqword_414840 = sub_409670(&off_413300, qword_413F20);\nresult = qword_414840;\nif ( qword_414840 )\n{\nLABEL_17:\nresult = (unsigned int)a1;\ndword_4132E4 = a1;\nreturn result;\n}\n}\n}\nreturn result;\n}\n```", "output": "a1: nstate, int", "predict": "a1: nstate, int", "funname": "set_state", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402DA1"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v7`, `v8`?\n```\n__int64 __fastcall sub_402FFB(__int64 a1, __int64 a2, _DWORD *a3)\n{\n__int64 v3; // rdx\n__int64 v4; // rdx\nchar *v7; // [rsp+20h] [rbp-10h]\nchar *v8; // [rsp+28h] [rbp-8h]\n\nv8 = (char *)off_4132D8 + 42;\nv7 = (char *)off_4132D8 + 62;\n*((_DWORD *)v8 + 1) = htonl(0x42u);\n*v7 = *(_DWORD *)qword_413F20 - 1;\nv7[1] = *(_DWORD *)(qword_414840 + 56);\nmemmove(v7 + 2, *(const void **)(qword_414840 + 64), *(int *)(qword_414840 + 56));\nv3 = qword_414808;\n*(_QWORD *)(v7 + 34) = *(_QWORD *)dest;\n*(_QWORD *)(v7 + 42) = v3;\nv4 = qword_414818;\n*(_QWORD *)(v7 + 50) = qword_414810;\n*(_QWORD *)(v7 + 58) = v4;\n*a3 = 6;\nreturn 1LL;\n}\n```", "output": "a1: pkt, ead_packet*\na2: len, int\na3: nstate, int*\nv7: salt, ead_msg_salt*\nv8: msg, ead_msg*", "predict": "a1: pkt, ead_packet*\na2: len, int\na3: nstate, int*\nv7: salt, ead_msg_salt*\nv8: msg, ead_msg*", "funname": "handle_get_prime", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402FFB"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v3`, `v4`?\n```\n__int64 __fastcall sub_408C6B(__int64 a1, unsigned int a2)\n{\nunsigned int v3; // [rsp+14h] [rbp-Ch]\n__int64 v4; // [rsp+18h] [rbp-8h]\n\nv4 = sub_40C999();\nsub_40CE13(v4, a2);\nv3 = sub_40D215(a1, v4);\nsub_40C906(v4);\nreturn v3;\n}\n```", "output": "a1: c1, BigInteger*\na2: c2, unsigned int\nv3: rv, int\nv4: a, BIGNUM*", "predict": "a1: c1, BigInteger*\na2: c2, unsigned int\nv3: rv, int\nv4: a, BIGNUM*", "funname": "BigIntegerCmpInt", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408C6B"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n_QWORD *__fastcall sub_402555(_QWORD *a1, __int64 *a2)\n{\nreturn sub_402514(a1, a2, *a2);\n}\n```", "output": "a1: new, list_head*\na2: head, list_head*", "predict": "a1: new, const list_head*\na2: head, const list_head*", "funname": "list_add", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402555"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v4`, `v5`, `v6`, `v7`, `k`, `v11`, `v13`?\n```\n__int64 __fastcall sub_40C9FA(__int64 a1, int a2)\n{\nint v3; // eax\n__int64 v4; // [rsp+10h] [rbp-40h]\n__int64 v5; // [rsp+18h] [rbp-38h]\n__int64 v6; // [rsp+20h] [rbp-30h]\n_QWORD *v7; // [rsp+30h] [rbp-20h]\nint i; // [rsp+3Ch] [rbp-14h]\nint j; // [rsp+3Ch] [rbp-14h]\nint k; // [rsp+3Ch] [rbp-14h]\n_QWORD *v11; // [rsp+40h] [rbp-10h]\n_QWORD *v12; // [rsp+48h] [rbp-8h]\n_QWORD *v13; // [rsp+48h] [rbp-8h]\n\nif ( a2 <= *(_DWORD *)(a1 + 12) )\nreturn a1;\nif ( (*(_DWORD *)(a1 + 20) & 2) != 0 )\nreturn 0LL;\nv12 = malloc(8LL * (a2 + 1));\nv7 = v12;\nif ( !v12 )\nreturn 0LL;\nv11 = *(_QWORD **)a1;\nif ( *(_QWORD *)a1 )\n{\nfor ( i = *(int *)(a1 + 8) >> 2; i > 0; --i )\n{\nv6 = v11[1];\nv5 = v11[2];\nv4 = v11[3];\n*v12 = *v11;\nv12[1] = v6;\nv12[2] = v5;\nv12[3] = v4;\nv12 += 4;\nv11 += 4;\n}\nv3 = *(_DWORD *)(a1 + 8) & 3;\nswitch ( v3 )\n{\ncase 3:\nv12[2] = v11[2];\nbreak;\ncase 1:\nLABEL_16:\n*v12 = *v11;\nLABEL_17:\nfree(*(void **)a1);\ngoto LABEL_18;\ncase 2:\nbreak;\ndefault:\ngoto LABEL_17;\n}\nv12[1] = v11[1];\ngoto LABEL_16;\n}\nLABEL_18:\n*(_QWORD *)a1 = v7;\n*(_DWORD *)(a1 + 12) = a2;\nv13 = (_QWORD *)(*(_QWORD *)a1 + 8LL * *(int *)(a1 + 8));\nfor ( j = (*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8)) >> 3; j > 0; --j )\n{\n*v13 = 0LL;\nv13[1] = 0LL;\nv13[2] = 0LL;\nv13[3] = 0LL;\nv13[4] = 0LL;\nv13[5] = 0LL;\nv13[6] = 0LL;\nv13[7] = 0LL;\nv13 += 8;\n}\nfor ( k = ((unsigned __int8)*(_DWORD *)(a1 + 12) - (unsigned __int8)*(_DWORD *)(a1 + 8)) & 7; k > 0; --k )\n*v13++ = 0LL;\nreturn a1;\n}\n```", "output": "a1: b, BIGNUM*\na2: words, int\nv4: a3, long unsigned int\nv5: a2, long unsigned int\nv6: a1, long unsigned int\nv7: a, long unsigned int*\nk: i, int\nv11: B, const long unsigned int*\nv13: A, long unsigned int*", "predict": "a1: b, BIGNUM*\na2: words, int\nv4: a3, long unsigned int\nv5: a2, long unsigned int\nv6: a1, long unsigned int\nv7: a, long unsigned int*\nk: i, int\nv11: B, const long unsigned int*\nv13: A, long unsigned int*", "funname": "bn_expand2", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C9FA"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v11`, `v12`, `v13`, `v14`, `v15`, `v16`, `v18`, `v20`?\n```\n__int64 __fastcall sub_40A462(__int64 *a1, __int64 *a2, __int64 *a3)\n{\nbool v3; // al\nint v5; // ebx\nunsigned __int64 *v6; // rax\nunsigned __int64 *v7; // rax\nunsigned __int64 *v8; // rax\nunsigned __int64 *v9; // rdx\nunsigned __int64 *v10; // rax\n__int64 *v11; // [rsp+8h] [rbp-68h]\n__int64 *v12; // [rsp+10h] [rbp-60h]\nunsigned __int64 v13; // [rsp+28h] [rbp-48h]\nunsigned int v14; // [rsp+38h] [rbp-38h]\nint v15; // [rsp+3Ch] [rbp-34h]\n__int64 v16; // [rsp+48h] [rbp-28h]\n__int64 v17; // [rsp+50h] [rbp-20h]\nunsigned __int64 *v18; // [rsp+50h] [rbp-20h]\n__int64 v19; // [rsp+58h] [rbp-18h]\nunsigned __int64 *v20; // [rsp+58h] [rbp-18h]\n\nv12 = a2;\nv11 = a3;\nif ( *((_DWORD *)a2 + 2) < *((_DWORD *)a3 + 2) )\n{\nv12 = a3;\nv11 = a2;\n}\nv15 = *((_DWORD *)v12 + 2);\nv14 = *((_DWORD *)v11 + 2);\nif ( v15 < *((_DWORD *)a1 + 3) )\nv3 = a1 == 0LL;\nelse\nv3 = sub_40C9FA(a1, (unsigned int)(v15 + 1)) == 0;\nif ( v3 )\nreturn 0LL;\n*((_DWORD *)a1 + 2) = v15;\nv19 = *v12;\nv17 = *a1;\nv16 = sub_40C4C7(*a1, *v12, *v11, v14);\nv18 = (unsigned __int64 *)(8LL * (int)v14 + v17);\nv20 = (unsigned __int64 *)(8LL * (int)v14 + v19);\nv5 = v14;\nif ( v16 )\n{\nwhile ( v5 < v15 )\n{\n++v5;\nv6 = v20++;\nv13 = *v6;\nv7 = v18++;\n*v7 = v13 + 1;\nif ( v13 <= *v7 )\n{\nv16 = 0LL;\nbreak;\n}\n}\nif ( v5 >= v15 && v16 )\n{\nv8 = v18++;\n*v8 = 1LL;\n++*((_DWORD *)a1 + 2);\n}\n}\nif ( v18 != v20 )\n{\nwhile ( v5 < v15 )\n{\nv9 = v20++;\nv10 = v18++;\n*v10 = *v9;\n++v5;\n}\n}\nreturn 1LL;\n}\n```", "output": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: b, const BIGNUM*\nv11: b, const BIGNUM*\nv12: a, const BIGNUM*\nv13: t1, long unsigned int\nv14: min, int\nv15: max, int\nv16: carry, long unsigned int\nv18: rp, long unsigned int*\nv20: ap, long unsigned int*", "predict": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: b, const BIGNUM*\nv11: b, const BIGNUM*\nv12: a, const BIGNUM*\nv13: t1, long unsigned int\nv14: min, int\nv15: max, int\nv16: carry, long unsigned int\nv18: rp, long unsigned int*\nv20: ap, long unsigned int*", "funname": "BN_uadd", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A462"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v5`?\n```\nvoid *__fastcall sub_405E43(void *a1, int *a2, int a3)\n{\nvoid *result; // rax\n__int64 v5; // [rsp+28h] [rbp-8h]\n\nv5 = (__int64)a1;\nsub_40466E(a2);\nresult = memset(a1, 0, 0x14uLL);\nwhile ( a3 > 0 )\n{\nresult = sub_40427F(a2, v5, (__int64)&unk_414F00);\na3 -= 64;\nv5 += 64LL;\n}\nreturn result;\n}\n```", "output": "a1: enc, ead_msg_encrypted*\na2: hash, uint32_t*\na3: len, int\nv5: data, unsigned char*", "predict": "a1: enc, ead_msg_encrypted*\na2: hash, uint32_t*\na3: len, int\nv5: data, unsigned char*", "funname": "ead_hash_message", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405E43"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`?\n```\n__int64 __fastcall sub_40DEE2(__int64 a1, __int64 a2, __int64 a3, int *a4)\n{\nreturn sub_40D754(0LL, a1, a2, a3, a4);\n}\n```", "output": "a1: rem, BIGNUM*\na2: m, const BIGNUM*\na3: d, const BIGNUM*\na4: ctx, BN_CTX*", "predict": "a1: rem, BIGNUM*\na2: m, const BIGNUM*\na3: d, const BIGNUM*\na4: ctx, BN_CTX*", "funname": "BN_mod", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40DEE2"}
{"input": "What are the original name and data type of variables `a1`?\n```\n__int64 __fastcall sub_40C6B5(unsigned __int64 a1)\n{\n__int64 result; // rax\n\nif ( (a1 & 0xFFFFFFFF00000000LL) != 0 )\n{\nif ( (a1 & 0xFFFF000000000000LL) != 0 )\n{\nif ( (a1 & 0xFF00000000000000LL) != 0 )\nresult = (unsigned int)(byte_410320[HIBYTE(a1)] + 56);\nelse\nresult = (unsigned int)(byte_410320[HIWORD(a1)] + 48);\n}\nelse if ( (a1 & 0xFF0000000000LL) != 0 )\n{\nresult = (unsigned int)(byte_410320[a1 >> 40] + 40);\n}\nelse\n{\nresult = (unsigned int)(byte_410320[SHIDWORD(a1)] + 32);\n}\n}\nelse if ( (a1 & 0xFFFF0000) != 0 )\n{\nif ( (a1 & 0xFF000000) != 0 )\nresult = (unsigned int)(byte_410320[(int)(a1 >> 24)] + 24);\nelse\nresult = (unsigned int)(byte_410320[(int)(a1 >> 16)] + 16);\n}\nelse if ( (a1 & 0xFF00) != 0 )\n{\nresult = (unsigned int)(byte_410320[(int)(a1 >> 8)] + 8);\n}\nelse\n{\nresult = (unsigned int)byte_410320[(int)a1];\n}\nreturn result;\n}\n```", "output": "a1: l, long unsigned int", "predict": "a1: l, long unsigned int", "funname": "BN_num_bits_word", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C6B5"}
{"input": "What are the original name and data type of variables `a1`, `v4`?\n```\nint *__fastcall sub_40642F(int a1)\n{\n__int64 v2; // rdx\n__int64 v3; // rdx\n_QWORD *v4; // [rsp+18h] [rbp-8h]\n\nif ( a1 <= 0 || a1 > (int)sub_406424() )\nreturn 0LL;\nv4 = (_QWORD *)sub_4064AB((unsigned int)(a1 - 1));\ndword_415040 = a1;\nv2 = v4[4];\nqword_415048 = v4[3];\nqword_415050 = v2;\nv3 = v4[6];\nqword_415058 = v4[5];\nqword_415060 = v3;\nreturn &dword_415040;\n}\n```", "output": "a1: id, int\nv4: tcp, t_preconf*", "predict": "a1: id, int\nv4: tcp, t_preconf*", "funname": "gettcid", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40642F"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `v8`, `v15`, `v19`, `v20`?\n```\nunsigned __int64 __fastcall sub_40C4C7(unsigned __int64 *a1, _QWORD *a2, _QWORD *a3, int a4)\n{\nint v5; // [rsp+0h] [rbp-3Ch]\nint v6; // [rsp+0h] [rbp-3Ch]\nint v7; // [rsp+0h] [rbp-3Ch]\nint v8; // [rsp+0h] [rbp-3Ch]\nunsigned __int64 v12; // [rsp+24h] [rbp-18h]\nunsigned __int64 v13; // [rsp+24h] [rbp-18h]\nunsigned __int64 v14; // [rsp+24h] [rbp-18h]\nunsigned __int64 v15; // [rsp+24h] [rbp-18h]\nunsigned __int64 v16; // [rsp+2Ch] [rbp-10h]\nunsigned __int64 v17; // [rsp+2Ch] [rbp-10h]\nunsigned __int64 v18; // [rsp+2Ch] [rbp-10h]\nunsigned __int64 v19; // [rsp+2Ch] [rbp-10h]\nunsigned __int64 v20; // [rsp+34h] [rbp-8h]\n\nv5 = a4;\nif ( a4 <= 0 )\nreturn 0LL;\nv20 = 0LL;\nwhile ( 1 )\n{\nv16 = v20 + *a2;\nv12 = *a3 + v16;\nv20 = (v12 < v16) + (unsigned __int64)(v16 < v20);\n*a1 = v12;\nv6 = v5 - 1;\nif ( v6 <= 0 )\nbreak;\nv17 = v20 + a2[1];\nv13 = a3[1] + v17;\nv20 = (v13 < v17) + (unsigned __int64)(v17 < v20);\na1[1] = v13;\nv7 = v6 - 1;\nif ( v7 <= 0 )\nbreak;\nv18 = v20 + a2[2];\nv14 = a3[2] + v18;\nv20 = (v14 < v18) + (unsigned __int64)(v18 < v20);\na1[2] = v14;\nv8 = v7 - 1;\nif ( v8 <= 0 )\nbreak;\nv19 = v20 + a2[3];\nv15 = a3[3] + v19;\nv20 = (v15 < v19) + (unsigned __int64)(v19 < v20);\na1[3] = v15;\nv5 = v8 - 1;\nif ( v5 <= 0 )\nbreak;\na2 += 4;\na3 += 4;\na1 += 4;\n}\nreturn v20;\n}\n```", "output": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: b, long unsigned int*\na4: n, int\nv8: n, int\nv15: l, long unsigned int\nv19: t, long unsigned int\nv20: c, long unsigned int", "predict": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: b, long unsigned int*\na4: n, int\nv8: n, int\nv15: l, long unsigned int\nv19: t, long unsigned int\nv20: c, long unsigned int", "funname": "bn_add_words", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C4C7"}
{"input": "What are the original name and data type of variables `a1`, `v2`, `v3`, `v4`, `v5`, `v6`?\n```\n__int64 __fastcall sub_4099DA(__int64 a1)\n{\n__int64 v2; // [rsp+18h] [rbp-28h]\n__int64 v3; // [rsp+20h] [rbp-20h]\n__int64 v4; // [rsp+28h] [rbp-18h]\n__int64 v5; // [rsp+30h] [rbp-10h]\n__int64 v6; // [rsp+38h] [rbp-8h]\n\nif ( *(int *)(a1 + 8) > 31 )\n*(_DWORD *)(a1 + 72) = 32;\nelse\n*(_DWORD *)(a1 + 72) = *(_DWORD *)(a1 + 8);\nsub_409306(*(char **)(a1 + 80), *(_DWORD *)(a1 + 72));\nv6 = sub_408BEE(*(_QWORD *)(a1 + 80), *(_DWORD *)(a1 + 72));\nv5 = sub_408BEE(*(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 8));\nv4 = sub_408BEE(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 24));\nv3 = sub_408BC2(0);\nsub_408E19(v3, v4, v6, v5);\nv2 = sub_408BEE(*(_QWORD *)(a1 + 48), *(_DWORD *)(a1 + 40));\nsub_408CBC(v3, v3, v2);\nif ( (int)sub_408C46(v3, v5) > 0 )\nsub_408D3E(v3, v3, v5);\n*(_DWORD *)(a1 + 88) = sub_408C21(v3, *(_QWORD *)(a1 + 96));\nsub_408EDD(v2);\nsub_408EDD(v3);\nsub_408EDD(v6);\nsub_408EDD(v4);\nsub_408EDD(v5);\nsub_408919((int *)(a1 + 288), *(char **)(a1 + 96), *(_DWORD *)(a1 + 88));\nreturn a1 + 88;\n}\n```", "output": "a1: ts, t_server*\nv2: v, BigInteger*\nv3: B, BigInteger*\nv4: g, BigInteger*\nv5: n, BigInteger*\nv6: b, BigInteger*", "predict": "a1: ts, t_server*\nv2: v, BigInteger*\nv3: B, BigInteger*\nv4: g, BigInteger*\nv5: n, BigInteger*\nv6: b, BigInteger*", "funname": "t_servergenexp", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4099DA"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v4`, `v5`?\n```\n_BOOL8 __fastcall sub_40A34C(__int64 a1, __int64 a2, __int64 a3)\n{\n_BOOL8 result; // rax\n__int64 v4; // [rsp+8h] [rbp-28h]\n__int64 v5; // [rsp+10h] [rbp-20h]\n\nv5 = a2;\nv4 = a3;\nif ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a3 + 16) )\n{\nif ( *(_DWORD *)(a2 + 16) )\n*(_DWORD *)(a1 + 16) = 1;\nelse\n*(_DWORD *)(a1 + 16) = 0;\nresult = (unsigned int)sub_40A462(a1, a2, a3) != 0;\n}\nelse\n{\nif ( *(_DWORD *)(a2 + 16) )\n{\nv5 = a3;\nv4 = a2;\n}\nif ( (int)sub_40D158(v5, v4) >= 0 )\n{\nif ( !(unsigned int)sub_40A626(a1, v5, v4) )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 0;\n}\nelse\n{\nif ( !(unsigned int)sub_40A626(a1, v4, v5) )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 1;\n}\nresult = 1LL;\n}\nreturn result;\n}\n```", "output": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: b, const BIGNUM*\nv4: b, const BIGNUM*\nv5: a, const BIGNUM*", "predict": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: b, const BIGNUM*\nv4: b, const BIGNUM*\nv5: a, const BIGNUM*", "funname": "BN_add", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A34C"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v5`, `n`?\n```\nvoid *__fastcall sub_408919(int *a1, char *a2, unsigned int a3)\n{\nunsigned int v5; // [rsp+28h] [rbp-8h]\nunsigned int n; // [rsp+2Ch] [rbp-4h]\n\nv5 = ((unsigned int)a1[5] >> 3) & 0x3F;\na1[5] += 8 * a3;\nif ( a1[5] < 8 * a3 )\n++a1[6];\na1[6] += a3 >> 29;\nif ( v5 + a3 <= 0x3F )\n{\nn = 0;\n}\nelse\n{\nn = 64 - v5;\nmemcpy((char *)a1 + v5 + 28, a2, 64 - v5);\nsub_406C3F(a1, a1 + 7);\nwhile ( a3 > n + 63 )\n{\nsub_406C3F(a1, &a2[n]);\nn += 64;\n}\nv5 = 0;\n}\nreturn memcpy((char *)a1 + v5 + 28, &a2[n], a3 - n);\n}\n```", "output": "a1: context, SHA1_CTX*\na2: data, const unsigned char*\na3: len, unsigned int\nv5: j, unsigned int\nn: i, unsigned int", "predict": "a1: context, SHA1_CTX*\na2: _data, const void*\na3: len, u32\nv5: j, u32\nn: i, u32", "funname": "SHA1Update", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408919"}
{"input": "What are the original name and data type of variables `v1`?\n```\n_DWORD *sub_40A9D9()\n{\n_DWORD *v1; // [rsp+8h] [rbp-8h]\n\nv1 = malloc(0x168uLL);\nif ( !v1 )\nreturn 0LL;\nsub_40AA1D(v1);\nv1[74] = 1;\nreturn v1;\n}\n```", "output": "v1: ret, BN_CTX*", "predict": "v1: ret, BN_CTX*", "funname": "BN_CTX_new", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A9D9"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v3`, `v4`, `v5`, `v6`, `i`?\n```\n__int64 __fastcall sub_40D215(__int64 a1, __int64 a2)\n{\n__int64 result; // rax\nunsigned __int64 v3; // [rsp+10h] [rbp-20h]\nunsigned __int64 v4; // [rsp+18h] [rbp-18h]\nunsigned int v5; // [rsp+24h] [rbp-Ch]\nunsigned int v6; // [rsp+28h] [rbp-8h]\nint i; // [rsp+2Ch] [rbp-4h]\n\nif ( a1 && a2 )\n{\nif ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16) )\n{\nif ( *(_DWORD *)(a1 + 16) )\n{\nv6 = -1;\nv5 = 1;\n}\nelse\n{\nv6 = 1;\nv5 = -1;\n}\nif ( *(_DWORD *)(a1 + 8) <= *(_DWORD *)(a2 + 8) )\n{\nif ( *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a2 + 8) )\n{\nfor ( i = *(_DWORD *)(a1 + 8) - 1; i >= 0; --i )\n{\nv4 = *(_QWORD *)(*(_QWORD *)a1 + 8LL * i);\nv3 = *(_QWORD *)(*(_QWORD *)a2 + 8LL * i);\nif ( v4 > v3 )\nreturn v6;\nif ( v4 < v3 )\nreturn v5;\n}\nresult = 0LL;\n}\nelse\n{\nresult = v5;\n}\n}\nelse\n{\nresult = v6;\n}\n}\nelse if ( *(_DWORD *)(a1 + 16) )\n{\nresult = 0xFFFFFFFFLL;\n}\nelse\n{\nresult = 1LL;\n}\n}\nelse if ( a1 )\n{\nresult = 0xFFFFFFFFLL;\n}\nelse\n{\nresult = a2 != 0;\n}\nreturn result;\n}\n```", "output": "a1: a, const BIGNUM*\na2: b, const BIGNUM*\nv3: t2, long unsigned int\nv4: t1, long unsigned int\nv5: lt, int\nv6: gt, int\ni: i, int", "predict": "a1: a, const BIGNUM*\na2: b, const BIGNUM*\nv3: t2, long unsigned int\nv4: t1, long unsigned int\nv5: lt, int\nv6: gt, int\ni: i, int", "funname": "BN_cmp", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D215"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v29`, `v30`, `v31`, `v32`, `v33`, `v34`, `v36`, `v38`, `v40`, `v42`?\n```\n_BYTE *__fastcall sub_404C8D(_DWORD *a1, unsigned __int8 *a2, _BYTE *a3)\n{\nint v3; // ebx\nint v4; // ebx\nint v5; // ebx\nint v6; // ebx\nint v7; // ebx\nint v8; // ebx\nint v9; // ebx\nint v10; // ebx\nint v11; // ebx\nint v12; // ebx\nint v13; // ebx\nint v14; // ebx\nint v15; // ebx\nint v16; // ebx\nint v17; // ebx\nint v18; // ebx\nint v19; // ebx\nint v20; // ebx\nint v21; // ebx\nint v22; // ebx\nint v23; // ebx\nint v24; // ebx\nint v25; // ebx\nint v26; // ebx\n_BYTE *result; // rax\n_DWORD *v29; // [rsp+10h] [rbp-40h]\nunsigned int v30; // [rsp+20h] [rbp-30h]\nunsigned int v31; // [rsp+24h] [rbp-2Ch]\nunsigned int v32; // [rsp+28h] [rbp-28h]\nunsigned int v33; // [rsp+2Ch] [rbp-24h]\nint v34; // [rsp+34h] [rbp-1Ch]\nunsigned int v35; // [rsp+38h] [rbp-18h]\nunsigned int v36; // [rsp+38h] [rbp-18h]\nunsigned int v37; // [rsp+3Ch] [rbp-14h]\nunsigned int v38; // [rsp+3Ch] [rbp-14h]\nunsigned int v39; // [rsp+40h] [rbp-10h]\nunsigned int v40; // [rsp+40h] [rbp-10h]\nunsigned int v41; // [rsp+44h] [rbp-Ch]\nunsigned int v42; // [rsp+44h] [rbp-Ch]\n\nv29 = a1;\nv41 = a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24) ^ *a1;\nv39 = a2[7] ^ (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24) ^ a1[1];\nv37 = a2[11] ^ (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24) ^ a1[2];\nv35 = a2[15] ^ (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24) ^ a1[3];\nv34 = 5;\nwhile ( 1 )\n{\nv3 = dword_40F4C0[HIBYTE(v41)];\nv4 = sub_4046BB(dword_40F4C0[BYTE2(v39)], 8) ^ v3;\nv5 = sub_4046BB(dword_40F4C0[BYTE1(v37)], 16) ^ v4;\nv33 = sub_4046BB(dword_40F4C0[(unsigned __int8)v35], 24) ^ v5 ^ v29[4];\nv6 = dword_40F4C0[HIBYTE(v39)];\nv7 = sub_4046BB(dword_40F4C0[BYTE2(v37)], 8) ^ v6;\nv8 = sub_4046BB(dword_40F4C0[BYTE1(v35)], 16) ^ v7;\nv32 = sub_4046BB(dword_40F4C0[(unsigned __int8)v41], 24) ^ v8 ^ v29[5];\nv9 = dword_40F4C0[HIBYTE(v37)];\nv10 = sub_4046BB(dword_40F4C0[BYTE2(v35)], 8) ^ v9;\nv11 = sub_4046BB(dword_40F4C0[BYTE1(v41)], 16) ^ v10;\nv31 = sub_4046BB(dword_40F4C0[(unsigned __int8)v39], 24) ^ v11 ^ v29[6];\nv12 = dword_40F4C0[HIBYTE(v35)];\nv13 = sub_4046BB(dword_40F4C0[BYTE2(v41)], 8) ^ v12;\nv14 = sub_4046BB(dword_40F4C0[BYTE1(v39)], 16) ^ v13;\nv30 = sub_4046BB(dword_40F4C0[(unsigned __int8)v37], 24) ^ v14 ^ v29[7];\nv29 += 8;\nif ( !--v34 )\nbreak;\nv15 = dword_40F4C0[HIBYTE(v33)];\nv16 = sub_4046BB(dword_40F4C0[BYTE2(v32)], 8) ^ v15;\nv17 = sub_4046BB(dword_40F4C0[BYTE1(v31)], 16) ^ v16;\nv41 = sub_4046BB(dword_40F4C0[(unsigned __int8)v30], 24) ^ v17 ^ *v29;\nv18 = dword_40F4C0[HIBYTE(v32)];\nv19 = sub_4046BB(dword_40F4C0[BYTE2(v31)], 8) ^ v18;\nv20 = sub_4046BB(dword_40F4C0[BYTE1(v30)], 16) ^ v19;\nv39 = sub_4046BB(dword_40F4C0[(unsigned __int8)v33], 24) ^ v20 ^ v29[1];\nv21 = dword_40F4C0[HIBYTE(v31)];\nv22 = sub_4046BB(dword_40F4C0[BYTE2(v30)], 8) ^ v21;\nv23 = sub_4046BB(dword_40F4C0[BYTE1(v33)], 16) ^ v22;\nv37 = sub_4046BB(dword_40F4C0[(unsigned __int8)v32], 24) ^ v23 ^ v29[2];\nv24 = dword_40F4C0[HIBYTE(v30)];\nv25 = sub_4046BB(dword_40F4C0[BYTE2(v33)], 8) ^ v24;\nv26 = sub_4046BB(dword_40F4C0[BYTE1(v32)], 16) ^ v25;\nv35 = sub_4046BB(dword_40F4C0[(unsigned __int8)v31], 24) ^ v26 ^ v29[3];\n}\nv42 = (unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v30]) ^ dword_40F4C0[BYTE1(v31)] & 0xFF00 ^ (dword_40F4C0[BYTE2(v32)] & 0xFF0000 | (dword_40F4C0[HIBYTE(v33)] << 8) & 0xFF000000) ^ *v29;\n*a3 = HIBYTE(v42);\na3[1] = BYTE2(v42);\na3[2] = BYTE1(v42);\na3[3] = v42;\nv40 = (unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v33]) ^ dword_40F4C0[BYTE1(v30)] & 0xFF00 ^ (dword_40F4C0[BYTE2(v31)] & 0xFF0000 | (dword_40F4C0[HIBYTE(v32)] << 8) & 0xFF000000) ^ v29[1];\na3[4] = HIBYTE(v40);\na3[5] = BYTE2(v40);\na3[6] = BYTE1(v40);\na3[7] = v40;\nv38 = (unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v32]) ^ dword_40F4C0[BYTE1(v33)] & 0xFF00 ^ (dword_40F4C0[BYTE2(v30)] & 0xFF0000 | (dword_40F4C0[HIBYTE(v31)] << 8) & 0xFF000000) ^ v29[2];\na3[8] = HIBYTE(v38);\na3[9] = BYTE2(v38);\na3[10] = BYTE1(v38);\na3[11] = v38;\nv36 = (unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v31]) ^ dword_40F4C0[BYTE1(v32)] & 0xFF00 ^ (dword_40F4C0[BYTE2(v33)] & 0xFF0000 | (dword_40F4C0[HIBYTE(v30)] << 8) & 0xFF000000) ^ v29[3];\na3[12] = HIBYTE(v36);\na3[13] = BYTE2(v36);\na3[14] = BYTE1(v36);\nresult = a3 + 15;\na3[15] = v36;\nreturn result;\n}\n```", "output": "a1: rk, const u32*\na2: pt, const u8*\na3: ct, u8*\nv29: rk, const u32*\nv30: t3, u32\nv31: t2, u32\nv32: t1, u32\nv33: t0, u32\nv34: r, int\nv36: s3, u32\nv38: s2, u32\nv40: s1, u32\nv42: s0, u32", "predict": "a1: rk, u32*\na2: cipherKey, const u8*\na3: plainKey, u8*\nv29: rk, u32*\nv30: temp, u32\nv31: -, -\nv32: -, -\nv33: -, -\nv34: loop, int\nv36: d, u32\nv38: c, u32\nv40: b, u32\nv42: a, u32", "funname": "rijndaelEncrypt", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "404C8D"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n__int64 __fastcall sub_404267(int a1, char a2)\n{\nreturn (unsigned int)__ROL4__(a1, a2);\n}\n```", "output": "a1: word, uint32_t\na2: shift, int", "predict": "a1: word, __u32\na2: shift, unsigned int", "funname": "rol32", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "404267"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `a5`, `v6`, `v10`, `v11`, `v12`, `v13`, `v14`?\n```\n__int64 __fastcall sub_40B381(__int64 a1, _QWORD *a2, int a3, _QWORD *a4, int a5)\n{\n__int64 result; // rax\n_QWORD *v6; // [rsp+0h] [rbp-50h]\nint v7; // [rsp+8h] [rbp-48h]\nint v8; // [rsp+8h] [rbp-48h]\nint v9; // [rsp+8h] [rbp-48h]\nint v10; // [rsp+8h] [rbp-48h]\nunsigned int v11; // [rsp+Ch] [rbp-44h]\n_QWORD *v12; // [rsp+10h] [rbp-40h]\n__int64 v13; // [rsp+18h] [rbp-38h]\n__int64 *v14; // [rsp+38h] [rbp-18h]\n\nv13 = a1;\nv12 = a2;\nv11 = a3;\nv6 = a4;\nv7 = a5;\nif ( a3 < a5 )\n{\nv11 = a5;\nv7 = a3;\nv12 = a4;\nv6 = a2;\n}\nv14 = (__int64 *)(8LL * (int)v11 + a1);\nresult = sub_40BB0A(a1, v12, v11, *v6);\n*v14 = result;\nwhile ( 1 )\n{\nv8 = v7 - 1;\nif ( v8 <= 0 )\nbreak;\nresult = sub_40B510(v13 + 8, v12, v11, v6[1]);\nv14[1] = result;\nv9 = v8 - 1;\nif ( v9 <= 0 )\nbreak;\nresult = sub_40B510(v13 + 16, v12, v11, v6[2]);\nv14[2] = result;\nv10 = v9 - 1;\nif ( v10 <= 0 )\nbreak;\nresult = sub_40B510(v13 + 24, v12, v11, v6[3]);\nv14[3] = result;\nv7 = v10 - 1;\nif ( v7 <= 0 )\nbreak;\nresult = sub_40B510(v13 + 32, v12, v11, v6[4]);\nv14[4] = result;\nv14 += 4;\nv13 += 32LL;\nv6 += 4;\n}\nreturn result;\n}\n```", "output": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: na, int\na4: b, long unsigned int*\na5: nb, int\nv6: b, long unsigned int*\nv10: nb, int\nv11: na, int\nv12: a, long unsigned int*\nv13: r, long unsigned int*\nv14: rr, long unsigned int*", "predict": "a1: r, long unsigned int*\na2: a, long unsigned int*\na3: na, int\na4: nb, int\na5: b, long unsigned int*\nv6: b, long unsigned int*\nv10: nb, int\nv11: na, int\nv12: a, long unsigned int*\nv13: r, long unsigned int*\nv14: rr, long unsigned int*", "funname": "bn_mul_normal", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40B381"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v5`, `v6`, `v7`, `v8`, `v9`, `i`?\n```\n__int64 __fastcall sub_40CC70(__int64 a1, __int64 a2)\n{\nbool v3; // al\nint v4; // eax\n__int64 v5; // [rsp+18h] [rbp-38h]\n__int64 v6; // [rsp+20h] [rbp-30h]\n__int64 v7; // [rsp+28h] [rbp-28h]\n_QWORD *v8; // [rsp+38h] [rbp-18h]\n_QWORD *v9; // [rsp+40h] [rbp-10h]\nint i; // [rsp+4Ch] [rbp-4h]\n\nif ( a1 == a2 )\nreturn a1;\nif ( *(_DWORD *)(a2 + 8) <= *(_DWORD *)(a1 + 12) )\nv3 = a1 == 0;\nelse\nv3 = sub_40C9FA(a1, *(_DWORD *)(a2 + 8)) == 0;\nif ( v3 )\nreturn 0LL;\nv9 = *(_QWORD **)a1;\nv8 = *(_QWORD **)a2;\nfor ( i = *(int *)(a2 + 8) >> 2; i > 0; --i )\n{\nv7 = v8[1];\nv6 = v8[2];\nv5 = v8[3];\n*v9 = *v8;\nv9[1] = v7;\nv9[2] = v6;\nv9[3] = v5;\nv9 += 4;\nv8 += 4;\n}\nv4 = *(_DWORD *)(a2 + 8) & 3;\nif ( v4 == 3 )\n{\nv9[2] = v8[2];\nLABEL_16:\nv9[1] = v8[1];\ngoto LABEL_17;\n}\nif ( v4 != 1 )\n{\nif ( v4 != 2 )\ngoto LABEL_18;\ngoto LABEL_16;\n}\nLABEL_17:\n*v9 = *v8;\nLABEL_18:\n*(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);\nif ( !*(_DWORD *)(a1 + 8) )\n{\nif ( *(_QWORD *)a1 )\n**(_QWORD **)a1 = 0LL;\n}\n*(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);\nreturn a1;\n}\n```", "output": "a1: a, BIGNUM*\na2: b, const BIGNUM*\nv5: a3, long unsigned int\nv6: a2, long unsigned int\nv7: a1, long unsigned int\nv8: B, const long unsigned int*\nv9: A, long unsigned int*\ni: i, int", "predict": "a1: a, BIGNUM*\na2: b, const BIGNUM*\nv5: a3, long unsigned int\nv6: a2, long unsigned int\nv7: a1, long unsigned int\nv8: B, const long unsigned int*\nv9: A, long unsigned int*\ni: i, int", "funname": "BN_copy", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40CC70"}
{"input": "What are the original name and data type of variables `a1`?\n```\n_QWORD *__fastcall sub_4024F2(_QWORD *a1)\n{\n_QWORD *result; // rax\n\n*a1 = a1;\nresult = a1;\na1[1] = a1;\nreturn result;\n}\n```", "output": "a1: list, list_head*", "predict": "a1: list, list_head*", "funname": "INIT_LIST_HEAD", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4024F2"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `a4`, `a5`, `v10`, `v11`, `v12`, `v13`, `v14`, `v15`, `v16`, `v17`, `v18`, `v19`, `v20`, `i`?\n```\n__int64 __fastcall sub_40AD55(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)\n{\nint v6; // eax\n_QWORD v10[96]; // [rsp+30h] [rbp-330h] BYREF\nint v11; // [rsp+330h] [rbp-30h]\nint v12; // [rsp+334h] [rbp-2Ch]\n__int64 v13; // [rsp+338h] [rbp-28h]\nint v14; // [rsp+340h] [rbp-20h]\nint v15; // [rsp+344h] [rbp-1Ch]\nint v16; // [rsp+348h] [rbp-18h]\nint v17; // [rsp+34Ch] [rbp-14h]\nint v18; // [rsp+350h] [rbp-10h]\nunsigned int v19; // [rsp+354h] [rbp-Ch]\nunsigned int v20; // [rsp+358h] [rbp-8h]\nint i; // [rsp+35Ch] [rbp-4h]\n\nv20 = 0;\nv16 = 0;\nv15 = 1;\nv14 = sub_40C804(a3);\nif ( !v14 )\n{\nsub_40CE13(a1, 1LL);\nreturn 1LL;\n}\nsub_40AB08(a5);\nv13 = sub_40AB57(a5);\nif ( v13 )\n{\nsub_40C974(v10);\nv16 = 1;\nif ( (unsigned int)sub_40DEE2(v10, a2, a4, a5) )\n{\nif ( v14 > 671 )\n{\nv6 = 6;\n}\nelse if ( v14 > 239 )\n{\nv6 = 5;\n}\nelse if ( v14 > 79 )\n{\nv6 = 4;\n}\nelse if ( v14 <= 23 )\n{\nv6 = 1;\n}\nelse\n{\nv6 = 3;\n}\nv12 = v6;\nif ( v6 <= 1 )\n{\nLABEL_21:\nv15 = 1;\nv17 = 0;\nv19 = v14 - 1;\nv18 = 0;\nif ( (unsigned int)sub_40CE13(a1, 1LL) )\n{\ndo\n{\nwhile ( !(unsigned int)sub_40D358(a3, v19) )\n{\nif ( !v15 && !(unsigned int)sub_40AC4C(a1, a1, a1, a4, a5) )\ngoto LABEL_41;\nif ( !v19 )\ngoto LABEL_40;\n--v19;\n}\nv11 = v19;\nv17 = 1;\nv18 = 0;\nfor ( i = 1; i < v12 && (int)(v19 - i) >= 0; ++i )\n{\nif ( (unsigned int)sub_40D358(a3, v19 - i) )\n{\nv17 <<= i - v18;\nv17 |= 1u;\nv18 = i;\n}\n}\nv11 = v18 + 1;\nif ( !v15 )\n{\nfor ( i = 0; i < v11; ++i )\n{\nif ( !(unsigned int)sub_40AC4C(a1, a1, a1, a4, a5) )\ngoto LABEL_41;\n}\n}\nif ( !(unsigned int)sub_40AC4C(a1, a1, (__int64)&v10[3 * (v17 >> 1)], a4, a5) )\ngoto LABEL_41;\nv19 -= v18 + 1;\nv17 = 0;\nv15 = 0;\n}\nwhile ( (v19 & 0x80000000) == 0 );\nLABEL_40:\nv20 = 1;\n}\ngoto LABEL_41;\n}\nif ( (unsigned int)sub_40AC4C(v13, (__int64)v10, (__int64)v10, a4, a5) )\n{\nv11 = 1 << (v12 - 1);\nfor ( i = 1; i < v11; ++i )\n{\nsub_40C974(&v10[3 * i]);\nif ( !(unsigned int)sub_40AC4C((__int64)&v10[3 * i], (__int64)&v10[3 * i - 3], v13, a4, a5) )\ngoto LABEL_41;\n}\nv16 = i;\ngoto LABEL_21;\n}\n}\n}\nLABEL_41:\nsub_40ABC8(a5);\nfor ( i = 0; i < v16; ++i )\nsub_40C867(&v10[3 * i]);\nreturn v20;\n}\n```", "output": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: p, const BIGNUM*\na4: m, const BIGNUM*\na5: ctx, BN_CTX*\nv10: val, BIGNUM[32]\nv11: j, int\nv12: window, int\nv13: d, BIGNUM*\nv14: bits, int\nv15: start, int\nv16: ts, int\nv17: wvalue, int\nv18: wend, int\nv19: wstart, int\nv20: ret, int\ni: i, int", "predict": "a1: r, BIGNUM*\na2: a, const BIGNUM*\na3: p, const BIGNUM*\na4: m, const BIGNUM*\na5: ctx, BN_CTX*\nv10: val, BIGNUM[32]\nv11: j, int\nv12: window, int\nv13: d, BIGNUM*\nv14: bits, int\nv15: start, int\nv16: ts, int\nv17: wvalue, int\nv18: wend, int\nv19: wstart, int\nv20: ret, int\ni: i, int", "funname": "BN_mod_exp_simple", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40AD55"}
{"input": "What are the original name and data type of variables `a1`, `i`?\n```\n__int64 __fastcall sub_40AA1D(_DWORD *a1)\n{\n__int64 result; // rax\nint i; // [rsp+1Ch] [rbp-4h]\n\n*a1 = 0;\na1[74] = 0;\na1[75] = 0;\nresult = (__int64)a1;\na1[88] = 0;\nfor ( i = 0; i <= 11; ++i )\nresult = sub_40C974(&a1[6 * i + 2]);\nreturn result;\n}\n```", "output": "a1: ctx, BN_CTX*\ni: i, int", "predict": "a1: ctx, BN_CTX*\ni: i, int", "funname": "BN_CTX_init", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40AA1D"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `a3`, `v4`, `v5`, `v6`, `v7`, `v8`, `v9`, `v11`, `v13`, `v14`, `v15`?\n```\n__int64 __fastcall sub_40C2DF(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)\n{\nunsigned __int64 v4; // [rsp+8h] [rbp-58h]\n__int128 v5; // [rsp+10h] [rbp-50h]\nunsigned __int64 v6; // [rsp+20h] [rbp-40h]\nunsigned __int64 v7; // [rsp+30h] [rbp-30h]\nint v8; // [rsp+38h] [rbp-28h]\nint v9; // [rsp+3Ch] [rbp-24h]\nunsigned __int64 i; // [rsp+40h] [rbp-20h]\nunsigned __int64 v11; // [rsp+40h] [rbp-20h]\n__int64 v12; // [rsp+48h] [rbp-18h]\nunsigned __int64 v13; // [rsp+48h] [rbp-18h]\n__int64 v14; // [rsp+50h] [rbp-10h]\n__int64 v15; // [rsp+58h] [rbp-8h]\n\n*((_QWORD *)&v5 + 1) = a1;\n*(_QWORD *)&v5 = a2;\nv4 = a3;\nv14 = 0LL;\nv9 = 2;\nif ( !a3 )\nreturn -1LL;\nv8 = 64 - sub_40C6B5(a3);\nif ( a1 >= v4 )\n*((_QWORD *)&v5 + 1) = a1 - v4;\nif ( v8 )\n{\nv4 <<= v8;\n*((_QWORD *)&v5 + 1) = (*((_QWORD *)&v5 + 1) << v8) | (a2 >> (64 - (unsigned __int8)v8));\n*(_QWORD *)&v5 = a2 << v8;\n}\nv7 = HIDWORD(v4);\nwhile ( 1 )\n{\nif ( v7 == HIDWORD(*((_QWORD *)&v5 + 1)) )\nv15 = 0xFFFFFFFFLL;\nelse\nv15 = *((_QWORD *)&v5 + 1) / v7;\nv12 = v7 * v15;\nfor ( i = v15 * (unsigned int)v4;\n((*((_QWORD *)&v5 + 1) - v12) & 0xFFFFFFFF00000000LL) == 0\n&& i > (((*((_QWORD *)&v5 + 1) - v12) << 32) | DWORD1(v5));\ni -= (unsigned int)v4 )\n{\n--v15;\nv12 -= v7;\n}\nv6 = HIDWORD(i);\nv11 = i << 32;\nv13 = v6 + v12;\nif ( (unsigned __int64)v5 < v11 )\n++v13;\n*(_QWORD *)&v5 = v5 - v11;\nif ( *((_QWORD *)&v5 + 1) < v13 )\n{\n*((_QWORD *)&v5 + 1) += v4;\n--v15;\n}\n*((_QWORD *)&v5 + 1) -= v13;\nif ( !--v9 )\nbreak;\nv14 = v15 << 32;\nv5 *= 0x100000000LL;\n}\nreturn v15 | v14;\n}\n```", "output": "a1: h, long unsigned int\na2: l, long unsigned int\na3: d, long unsigned int\nv4: d, long unsigned int\nv5: l, long unsigned int\nv6: t, long unsigned int\nv7: dh, long unsigned int\nv8: i, int\nv9: count, int\nv11: tl, long unsigned int\nv13: th, long unsigned int\nv14: ret, long unsigned int\nv15: q, long unsigned int", "predict": "a1: h, long unsigned int\na2: l, long unsigned int\na3: d, long unsigned int\nv4: d, long unsigned int\nv5: l, long unsigned int\nv6: t, long unsigned int\nv7: dh, long unsigned int\nv8: i, int\nv9: count, int\nv11: tl, long unsigned int\nv13: th, long unsigned int\nv14: ret, long unsigned int\nv15: q, long unsigned int", "funname": "bn_div_words", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C2DF"}
{"input": "What are the original name and data type of variables `i`?\n```\n__int64 __fastcall sub_403E11(const char *a1, const char *a2)\n{\n__int64 i; // [rsp+28h] [rbp-8h]\n\nfor ( i = qword_414820; (__int64 *)i != &qword_414820; i = *(_QWORD *)i )\n{\nif ( !strcmp((const char *)(i + 16), a2) )\n{\n*(_BYTE *)(i + 53) = 1;\nif ( !strcmp((const char *)(i + 37), a1) )\nreturn 0LL;\nstrncpy((char *)(i + 37), a1, 0x10uLL);\nsub_403D53((__pid_t *)i, 0);\n}\n}\nreturn 0LL;\n}\n```", "output": "i: p, list_head*", "predict": "i: p, list_head*", "funname": "check_bridge_port", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403E11"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v3`, `v4`, `i`?\n```\n__int64 __fastcall sub_408A49(__int64 a1, int *a2)\n{\nchar v3[8]; // [rsp+10h] [rbp-10h] BYREF\nint v4; // [rsp+18h] [rbp-8h]\nunsigned int i; // [rsp+1Ch] [rbp-4h]\n\nfor ( i = 0; i <= 7; ++i )\nv3[i] = (unsigned int)a2[(i <= 3) + 5] >> (8 * (~(_BYTE)i & 3));\nsub_408919(a2, byte_4102C1, 1u);\nwhile ( (a2[5] & 0x1F8) != 448 )\nsub_408919(a2, byte_4102C3, 1u);\nsub_408919(a2, v3, 8u);\nfor ( i = 0; i <= 0x13; ++i )\n*(_BYTE *)(i + a1) = (unsigned int)a2[i >> 2] >> (8 * (~(_BYTE)i & 3));\nv4 = 0;\ni = 0;\nmemset(a2 + 7, 0, 0x40uLL);\nmemset(a2, 0, 0x14uLL);\nmemset(a2 + 5, 0, 8uLL);\nmemset(v3, 0, sizeof(v3));\nreturn sub_406C3F(a2, a2 + 7);\n}\n```", "output": "a1: digest, unsigned char*\na2: context, SHA1_CTX*\nv3: finalcount, unsigned char[8]\nv4: j, uint32\ni: i, uint32", "predict": "a1: digest, unsigned char*\na2: context, SHA1_CTX*\nv3: finalcount, unsigned char[8]\nv4: j, uint32\ni: i, uint32", "funname": "SHA1Final", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408A49"}
{"input": "What are the original name and data type of variables `a1`, `a2`?\n```\n__int64 __fastcall sub_403ECE(__int64 a1, __int64 a2)\n{\nsub_4062B8(a1, sub_403E11, a2);\nreturn 0LL;\n}\n```", "output": "a1: name, const char*\na2: arg, void*", "predict": "a1: name, const char*\na2: arg, void*", "funname": "check_bridge", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403ECE"}
{"input": "What are the original name and data type of variables `a1`?\n```\nunsigned __int64 __fastcall sub_40ABC8(_DWORD *a1)\n{\nunsigned __int64 result; // rax\n\nif ( a1 )\n{\nif ( !a1[75] )\nsub_40AB08(a1);\na1[88] = 0;\nresult = (unsigned int)--a1[75];\nif ( (int)result <= 11 )\n{\nresult = (unsigned __int64)a1;\n*a1 = a1[a1[75] + 76];\n}\n}\nreturn result;\n}\n```", "output": "a1: ctx, BN_CTX*", "predict": "a1: ctx, BN_CTX*", "funname": "BN_CTX_end", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40ABC8"}
{"input": "What are the original name and data type of variables `a1`, `a2`, `v5`, `v6`, `i`, `hostlong`, `v9`?\n```\n_DWORD *__fastcall sub_405EAD(__int64 a1, int a2)\n{\nuint32_t v2; // eax\n_DWORD *result; // rax\nuint32_t v4; // ecx\nint v5[6]; // [rsp+10h] [rbp-30h] BYREF\n_DWORD *v6; // [rsp+28h] [rbp-18h]\nint i; // [rsp+30h] [rbp-10h]\nuint32_t hostlong; // [rsp+34h] [rbp-Ch]\nunsigned __int8 *v9; // [rsp+38h] [rbp-8h]\n\nv6 = (_DWORD *)(a1 + 20);\nv9 = (unsigned __int8 *)(a1 + 20);\n*(_BYTE *)(a1 + 44) = -(char)(a2 + 25) & 0x3F;\nhostlong = *((unsigned __int8 *)v6 + 24) + a2 + 25;\n*(_DWORD *)(a1 + 4) = htonl(hostlong);\nv2 = sub_405DF7();\nv6[5] = htonl(v2);\nresult = sub_405E43(v6, v5, hostlong);\nfor ( i = 0; i <= 4; ++i )\n{\nv4 = htonl(v5[i]);\nresult = v6;\nv6[i] = v4;\n}\nwhile ( (int)hostlong > 0 )\n{\nresult = sub_404C8D(dword_414D80, v9, v9);\nv9 += 16;\nhostlong -= 16;\n}\nreturn result;\n}\n```", "output": "a1: msg, ead_msg*\na2: len, unsigned int\nv5: hash, uint32_t[5]\nv6: enc, ead_msg_encrypted*\ni: i, int\nhostlong: enclen, int\nv9: data, unsigned char*", "predict": "a1: msg, ead_msg*\na2: len, unsigned int\nv5: hash, uint32_t[5]\nv6: enc, ead_msg_encrypted*\ni: i, int\nhostlong: enclen, int\nv9: data, unsigned char*", "funname": "ead_encrypt_message", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405EAD"}
{"input": "What are the original name and data type of variables `a1`?\n```\n_DWORD *__fastcall sub_4088BF(_DWORD *a1)\n{\n_DWORD *result; // rax\n\n*a1 = 1732584193;\na1[1] = -271733879;\na1[2] = -1732584194;\na1[3] = 271733878;\na1[4] = -1009589776;\na1[6] = 0;\nresult = a1;\na1[5] = a1[6];\nreturn result;\n}\n```", "output": "a1: context, SHA1_CTX*", "predict": "a1: context, SHA1_CTX*", "funname": "SHA1Init", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4088BF"}
{"input": "What are the original name and data type of variables `a1`, `v1`?\n```\nvoid __fastcall sub_40C867(__int64 a1)\n{\nint v1; // [rsp+1Ch] [rbp-4h]\n\nif ( a1 )\n{\nif ( *(_QWORD *)a1 )\n{\nmemset(*(void **)a1, 0, 8LL * *(int *)(a1 + 12));\nif ( (*(_DWORD *)(a1 + 20) & 2) == 0 )\nfree(*(void **)a1);\n}\nv1 = *(_DWORD *)(a1 + 20) & 1;\nmemset((void *)a1, 0, 0x18uLL);\nif ( v1 )\nfree((void *)a1);\n}\n}\n```", "output": "a1: a, BIGNUM*\nv1: i, int", "predict": "a1: a, BIGNUM*\nv1: i, int", "funname": "BN_clear_free", "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C867"}
