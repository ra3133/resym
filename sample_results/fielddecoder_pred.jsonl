{"input": "```\n_QWORD *__fastcall sub_402582(_QWORD *a1, __int64 a2)\n{\n_QWORD *result; // rax\n\n*(_QWORD *)(a2 + 8) = a1;\nresult = a1;\n*a1 = a2;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)(a2 + 8)?\n", "output": "(_QWORD *)(a2 + 8): next, list_head* -> prev, list_head*", "predict": "(_QWORD *)(a2 + 8): next, const list_head* -> prev, list_head*", "funname": "__list_del", "ground_truth": [["(_QWORD *)(a2 + 8)", "next", "list_head*", "prev", "list_head*"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402582"}
{"input": "```\n__int64 __fastcall sub_40CE13(__int64 a1, __int64 a2)\n{\nbool v2; // al\n\nif ( *(_DWORD *)(a1 + 12) )\nv2 = a1 == 0;\nelse\nv2 = sub_40C9FA(a1, 2) == 0;\nif ( v2 )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 0;\n*(_DWORD *)(a1 + 8) = 0;\n**(_QWORD **)a1 = a2;\nif ( **(_QWORD **)a1 )\n*(_DWORD *)(a1 + 8) = 1;\nreturn 1LL;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD **)a1, (_DWORD *)(a1 + 8), (_DWORD *)(a1 + 12), (_DWORD *)(a1 + 16)?\n", "output": "(_QWORD **)a1: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): a, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): a, BIGNUM* -> neg, int", "predict": "(_QWORD **)a1: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): a, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): a, BIGNUM* -> neg, int", "funname": "BN_set_word", "ground_truth": [["(_QWORD **)a1", "a", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "a", "BIGNUM*", "top", "int"], ["(_DWORD *)(a1 + 12)", "a", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(a1 + 16)", "a", "BIGNUM*", "neg", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40CE13"}
{"input": "```\n__int64 sub_402EC2()\n{\nchar *v1; // [rsp+28h] [rbp-18h]\nchar *v2; // [rsp+30h] [rbp-10h]\nint v3; // [rsp+3Ch] [rbp-4h]\n\nv2 = (char *)off_4132D8 + 42;\nv1 = (char *)off_4132D8 + 62;\nv3 = strlen(src);\nif ( v3 > 1024 )\nv3 = 1024;\n*((_DWORD *)v2 + 1) = htonl(v3 + 2);\nstrncpy(v1 + 2, src, v3);\nv1[v3 + 2] = 0;\n*(_WORD *)v1 = htons(1u);\nreturn 1LL;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_WORD *)v1, v1 + 2, (_DWORD *)v2 + 1?\n", "output": "(_WORD *)v1: pong, ead_msg_pong* -> auth_type, uint16_t\nv1 + 2: pong, ead_msg_pong* -> name, char\n(_DWORD *)v2 + 1: msg, ead_msg* -> len, uint32_t", "predict": "(_WORD *)v1: pong, ead_msg_pong* -> auth_type, uint16_t\nv1 + 2: pong, ead_msg_pong* -> name, char\n(_DWORD *)v2 + 1: msg, ead_msg* -> len, uint32_t", "funname": "handle_ping", "ground_truth": [["(_WORD *)v1", "pong", "ead_msg_pong*", "auth_type", "uint16_t"], ["v1 + 2", "pong", "ead_msg_pong*", "name", "char"], ["(_DWORD *)v2 + 1", "msg", "ead_msg*", "len", "uint32_t"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402EC2"}
{"input": "```\n_DWORD *__fastcall sub_4046D3(int *a1, unsigned __int8 *a2)\n{\n_DWORD *result; // rax\nint *v3; // [rsp+8h] [rbp-18h]\nunsigned int v4; // [rsp+18h] [rbp-8h]\nint i; // [rsp+1Ch] [rbp-4h]\n\nv3 = a1;\n*a1 = a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24);\na1[1] = (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24) ^ a2[7];\na1[2] = (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24) ^ a2[11];\nresult = a1 + 3;\na1[3] = (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24) ^ a2[15];\nfor ( i = 0; i <= 9; ++i )\n{\nv4 = v3[3];\nv3[4] = ((unsigned __int8)byte_40FDC0[i] << 24) ^ (unsigned __int8)BYTE1(dword_40F4C0[HIBYTE(v4)]) ^ dword_40F4C0[(unsigned __int8)v4] & 0xFF00 ^ dword_40F4C0[BYTE1(v4)] & 0xFF0000 ^ (dword_40F4C0[BYTE2(v4)] << 8) & 0xFF000000 ^ *v3;\nv3[5] = v3[1] ^ v3[4];\nv3[6] = v3[2] ^ v3[5];\nresult = v3 + 7;\nv3[7] = v3[3] ^ v3[6];\nv3 += 4;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1 + 3, a2, a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8], a2[9], a2[10], a2[11], a2[12], a2[13], a2[14], a2[15], v3, v3[1], v3[2], v3[3], v3[4], v3[5], v3[6], v3 + 7?\n", "output": "a1: rk, u32* -> -, u32\na1[1]: rk, u32* -> -, u32\na1[2]: rk, u32* -> -, u32\na1 + 3: rk, u32* -> -, u32\na2: cipherKey, const u8* -> -, const u8\na2[1]: cipherKey, const u8* -> -, const u8\na2[2]: cipherKey, const u8* -> -, const u8\na2[3]: cipherKey, const u8* -> -, const u8\na2[4]: cipherKey, const u8* -> -, const u8\na2[5]: cipherKey, const u8* -> -, const u8\na2[6]: cipherKey, const u8* -> -, const u8\na2[7]: cipherKey, const u8* -> -, const u8\na2[8]: cipherKey, const u8* -> -, const u8\na2[9]: cipherKey, const u8* -> -, const u8\na2[10]: cipherKey, const u8* -> -, const u8\na2[11]: cipherKey, const u8* -> -, const u8\na2[12]: cipherKey, const u8* -> -, const u8\na2[13]: cipherKey, const u8* -> -, const u8\na2[14]: cipherKey, const u8* -> -, const u8\na2[15]: cipherKey, const u8* -> -, const u8\nv3: rk, u32* -> -, u32\nv3[1]: rk, u32* -> -, u32\nv3[2]: rk, u32* -> -, u32\nv3[3]: rk, u32* -> -, u32\nv3[4]: rk, u32* -> -, u32\nv3[5]: rk, u32* -> -, u32\nv3[6]: rk, u32* -> -, u32\nv3 + 7: rk, u32* -> -, u32", "predict": "a1: rk, u32* -> -, u32\na1[1]: rk, u32* -> -, u32\na1[2]: rk, u32* -> -, u32\na1 + 3: rk, u32* -> -, u32\na2: cipherKey, const u8* -> -, const u8\na2[1]: cipherKey, const u8* -> -, const u8\na2[2]: cipherKey, const u8* -> -, const u8\na2[3]: cipherKey, const u8* -> -, const u8\na2[4]: cipherKey, const u8* -> -, const u8\na2[5]: cipherKey, const u8* -> -, const u8\na2[6]: cipherKey, const u8* -> -, const u8\na2[7]: cipherKey, const u8* -> -, const u8\na2[8]: cipherKey, const u8* -> -, const u8\na2[9]: cipherKey, const u8* -> -, const u8\na2[10]: cipherKey, const u8* -> -, const u8\na2[11]: cipherKey, const u8* -> -, const u8\na2[12]: cipherKey, const u8* -> -, const u8\na2[13]: cipherKey, const u8* -> -, const u8\na2[14]: cipherKey, const u8* -> -, const u8\na2[15]: cipherKey, const u8* -> -, const u8\nv3: rk, u32* -> -, u32\nv3[1]: rk, u32* -> -, u32\nv3[2]: rk, u32* -> -, u32\nv3[3]: rk, u32* -> -, u32\nv3[4]: rk, u32* -> -, u32\nv3[5]: rk, u32* -> -, u32\nv3[6]: rk, u32* -> -, u32\nv3 + 7: rk, u32* -> -, u32", "funname": "rijndaelKeySetupEnc", "ground_truth": [["a1", "rk", "u32*", "-", "u32"], ["a1[1]", "rk", "u32*", "-", "u32"], ["a1[2]", "rk", "u32*", "-", "u32"], ["a1 + 3", "rk", "u32*", "-", "u32"], ["a2", "cipherKey", "const u8*", "-", "const u8"], ["a2[1]", "cipherKey", "const u8*", "-", "const u8"], ["a2[2]", "cipherKey", "const u8*", "-", "const u8"], ["a2[3]", "cipherKey", "const u8*", "-", "const u8"], ["a2[4]", "cipherKey", "const u8*", "-", "const u8"], ["a2[5]", "cipherKey", "const u8*", "-", "const u8"], ["a2[6]", "cipherKey", "const u8*", "-", "const u8"], ["a2[7]", "cipherKey", "const u8*", "-", "const u8"], ["a2[8]", "cipherKey", "const u8*", "-", "const u8"], ["a2[9]", "cipherKey", "const u8*", "-", "const u8"], ["a2[10]", "cipherKey", "const u8*", "-", "const u8"], ["a2[11]", "cipherKey", "const u8*", "-", "const u8"], ["a2[12]", "cipherKey", "const u8*", "-", "const u8"], ["a2[13]", "cipherKey", "const u8*", "-", "const u8"], ["a2[14]", "cipherKey", "const u8*", "-", "const u8"], ["a2[15]", "cipherKey", "const u8*", "-", "const u8"], ["v3", "rk", "u32*", "-", "u32"], ["v3[1]", "rk", "u32*", "-", "u32"], ["v3[2]", "rk", "u32*", "-", "u32"], ["v3[3]", "rk", "u32*", "-", "u32"], ["v3[4]", "rk", "u32*", "-", "u32"], ["v3[5]", "rk", "u32*", "-", "u32"], ["v3[6]", "rk", "u32*", "-", "u32"], ["v3 + 7", "rk", "u32*", "-", "u32"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4046D3"}
{"input": "```\nunsigned __int64 __fastcall sub_40D606(unsigned __int64 *a1, unsigned __int64 *a2, int a3, unsigned __int64 *a4)\n{\nunsigned __int64 *v4; // rax\nint v8; // [rsp+24h] [rbp-2Ch]\nunsigned __int64 *v9; // [rsp+28h] [rbp-28h]\nunsigned __int64 *v10; // [rsp+30h] [rbp-20h]\nint v11; // [rsp+38h] [rbp-18h]\nint i; // [rsp+3Ch] [rbp-14h]\n\nv8 = 2 * a3;\nv10 = a2;\nv4 = &a1[2 * a3 - 1];\n*v4 = 0LL;\n*a1 = *v4;\nv9 = a1 + 1;\nv11 = a3 - 1;\nif ( a3 - 1 > 0 )\n{\nv10 = a2 + 1;\nv9[v11] = sub_40BB0A(v9, a2 + 1, v11, *a2);\nv9 = a1 + 3;\n}\nfor ( i = a3 - 2; i > 0; --i )\n{\n--v11;\n++v10;\nv9[v11] = sub_40B510(v9, v10, v11, *(v10 - 1));\nv9 += 2;\n}\nsub_40C4C7(a1, a1, a1, v8);\nsub_40C061(a4, a2, a3);\nreturn sub_40C4C7(a1, a1, a4, v8);\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1 + 1, a1 + 3, a2, a2 + 1?\n", "output": "a1: r, long unsigned int* -> -, long unsigned int\na1 + 1: r, long unsigned int* -> -, long unsigned int\na1 + 3: r, long unsigned int* -> -, long unsigned int\na2: a, long unsigned int* -> -, long unsigned int\na2 + 1: a, long unsigned int* -> -, long unsigned int", "predict": "a1: r, long unsigned int* -> -, long unsigned int\na1 + 1: r, long unsigned int* -> -, long unsigned int\na1 + 3: r, long unsigned int* -> -, long unsigned int\na2: a, long unsigned int* -> -, long unsigned int\na2 + 1: a, long unsigned int* -> -, long unsigned int", "funname": "bn_sqr_normal", "ground_truth": [["a1", "r", "long unsigned int*", "-", "long unsigned int"], ["a1 + 1", "r", "long unsigned int*", "-", "long unsigned int"], ["a1 + 3", "r", "long unsigned int*", "-", "long unsigned int"], ["a2", "a", "long unsigned int*", "-", "long unsigned int"], ["a2 + 1", "a", "long unsigned int*", "-", "long unsigned int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D606"}
{"input": "```\n__int16 __fastcall sub_403889(__int64 a1, __int64 a2, __int64 a3)\n{\nunsigned __int64 v3; // rax\nint v4; // ebx\nint v5; // ebx\nint v6; // ebx\nunsigned __int64 v7; // rbx\nint v8; // ebx\n\nLODWORD(v3) = *(_DWORD *)(a2 + 20);\nif ( (unsigned int)v3 > 0x3D )\n{\nv4 = *(unsigned __int16 *)(a3 + 12);\nLOWORD(v3) = htons(0x800u);\nif ( v4 == (_DWORD)v3 )\n{\nLODWORD(v3) = memcmp((const void *)a3, &unk_40F1C8, 6uLL);\nif ( !(_DWORD)v3 )\n{\nLOWORD(v3) = *(unsigned __int8 *)(a3 + 23);\nif ( (_BYTE)v3 == 17 )\n{\nv5 = *(unsigned __int16 *)(a3 + 36);\nLOWORD(v3) = htons(0xDADAu);\nif ( v5 == (_DWORD)v3 )\n{\nv6 = *(_DWORD *)(a3 + 42);\nLODWORD(v3) = htonl(0xDADACAFE);\nif ( v6 == (_DWORD)v3 )\n{\nv7 = *(unsigned int *)(a2 + 20);\nv3 = (int)ntohl(*(_DWORD *)(a3 + 46)) + 62LL;\nif ( v7 >= v3 )\n{\nif ( *(_WORD *)(a3 + 54) == 0xFFFF\n|| (v8 = *(unsigned __int16 *)(a3 + 54), LOWORD(v3) = htons(word_4132E0), v8 == (_DWORD)v3) )\n{\nLOWORD(v3) = sub_4036C6(a3, *(_DWORD *)(a2 + 20));\n}\n}\n}\n}\n}\n}\n}\n}\nreturn v3;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_DWORD *)(a2 + 20), (const void *)a3, (unsigned __int16 *)(a3 + 12), (unsigned __int8 *)(a3 + 23), (unsigned __int16 *)(a3 + 36), (_DWORD *)(a3 + 42), (_DWORD *)(a3 + 46)?\n", "output": "(_DWORD *)(a2 + 20): h, const pcap_pkthdr* -> len, bpf_u_int32\n(const void *)a3: bytes, const u_char* -> -, const u_char\n(unsigned __int16 *)(a3 + 12): bytes, const u_char* -> -, const u_char\n(unsigned __int8 *)(a3 + 23): bytes, const u_char* -> -, const u_char\n(unsigned __int16 *)(a3 + 36): bytes, const u_char* -> -, const u_char\n(_DWORD *)(a3 + 42): bytes, const u_char* -> -, const u_char\n(_DWORD *)(a3 + 46): bytes, const u_char* -> -, const u_char", "predict": "(_DWORD *)(a2 + 20): h, const pcap_pkthdr* -> len, bpf_u_int32\n(const void *)a3: bytes, const u_char* -> -, const u_char\n(unsigned __int16 *)(a3 + 12): bytes, const u_char* -> -, const u_char\n(unsigned __int8 *)(a3 + 23): bytes, const u_char* -> -, const u_char\n(unsigned __int16 *)(a3 + 36): bytes, const u_char* -> -, const u_char\n(_DWORD *)(a3 + 42): bytes, const u_char* -> -, const u_char\n(_DWORD *)(a3 + 46): bytes, const u_char* -> -, const u_char", "funname": "handle_packet", "ground_truth": [["(_DWORD *)(a2 + 20)", "h", "const pcap_pkthdr*", "len", "bpf_u_int32"], ["(const void *)a3", "bytes", "const u_char*", "-", "const u_char"], ["(unsigned __int16 *)(a3 + 12)", "bytes", "const u_char*", "-", "const u_char"], ["(unsigned __int8 *)(a3 + 23)", "bytes", "const u_char*", "-", "const u_char"], ["(unsigned __int16 *)(a3 + 36)", "bytes", "const u_char*", "-", "const u_char"], ["(_DWORD *)(a3 + 42)", "bytes", "const u_char*", "-", "const u_char"], ["(_DWORD *)(a3 + 46)", "bytes", "const u_char*", "-", "const u_char"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403889"}
{"input": "```\n__int64 __fastcall sub_402AAD(unsigned __int16 a1, unsigned __int8 *a2, unsigned __int16 a3)\n{\nunsigned __int16 v5; // [rsp+1Eh] [rbp-12h]\nunsigned __int16 v6; // [rsp+1Eh] [rbp-12h]\nunsigned __int8 *v7; // [rsp+20h] [rbp-10h]\nunsigned __int8 *v8; // [rsp+28h] [rbp-8h]\n\nv8 = a2;\nv7 = &a2[a3 - 1];\nwhile ( v8 < v7 )\n{\nv5 = (*v8 << 8) + v8[1];\na1 += v5;\nif ( a1 < v5 )\n++a1;\nv8 += 2;\n}\nif ( v8 == v7 )\n{\nv6 = *v8 << 8;\na1 += v6;\nif ( a1 < v6 )\n++a1;\n}\nreturn a1;\n}\n```\nWhat are the variable name and type for the following memory accesses:v8, v8[1]?\n", "output": "v8: dataptr, const u8_t* -> -, const u8_t\nv8[1]: dataptr, const u8_t* -> -, const u8_t", "predict": "v8: dataptr, const u8_t* -> -, const u8_t\nv8[1]: dataptr, const u8_t* -> -, const u8_t", "funname": "chksum", "ground_truth": [["v8", "dataptr", "const u8_t*", "-", "const u8_t"], ["v8[1]", "dataptr", "const u8_t*", "-", "const u8_t"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402AAD"}
{"input": "```\n__int64 __fastcall sub_40A857(__int64 a1, __int64 a2, __int64 a3)\n{\n__int64 result; // rax\nsigned int v4; // eax\nbool v5; // al\n__int64 v6; // [rsp+8h] [rbp-38h]\n__int64 v7; // [rsp+10h] [rbp-30h]\nint v8; // [rsp+38h] [rbp-8h]\nint v9; // [rsp+3Ch] [rbp-4h]\n\nv7 = a2;\nv6 = a3;\nv9 = 0;\nv8 = 0;\nif ( *(_DWORD *)(a2 + 16) )\n{\nif ( *(_DWORD *)(a3 + 16) )\n{\nv7 = a3;\nv6 = a2;\n}\nelse\n{\nv9 = 1;\nv8 = 1;\n}\n}\nelse if ( *(_DWORD *)(a3 + 16) )\n{\nv9 = 1;\nv8 = 0;\n}\nif ( v9 )\n{\nif ( (unsigned int)sub_40A462((__int64 *)a1, (__int64 *)v7, (__int64 *)v6) )\n{\n*(_DWORD *)(a1 + 16) = v8;\nresult = 1LL;\n}\nelse\n{\nresult = 0LL;\n}\n}\nelse\n{\nv4 = *(_DWORD *)(v7 + 8);\nif ( *(_DWORD *)(v6 + 8) >= v4 )\nv4 = *(_DWORD *)(v6 + 8);\nif ( v4 <= *(_DWORD *)(a1 + 12) )\nv5 = a1 == 0;\nelse\nv5 = sub_40C9FA(a1, (unsigned int)v4) == 0;\nif ( v5 )\nreturn 0LL;\nif ( (int)sub_40D158(v7, v6) >= 0 )\n{\nif ( !(unsigned int)sub_40A626(a1, v7, v6) )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 0;\n}\nelse\n{\nif ( !(unsigned int)sub_40A626(a1, v6, v7) )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 1;\n}\nresult = 1LL;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(__int64 *)a1, (_DWORD *)(a1 + 12), (_DWORD *)(a1 + 16), (_DWORD *)(a2 + 16), (_DWORD *)(a3 + 16), (__int64 *)v6, (_DWORD *)(v6 + 8), (__int64 *)v7, (_DWORD *)(v7 + 8)?\n", "output": "(__int64 *)a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 12): r, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): r, BIGNUM* -> neg, int\n(_DWORD *)(a2 + 16): a, const BIGNUM* -> neg, int\n(_DWORD *)(a3 + 16): b, const BIGNUM* -> neg, int\n(__int64 *)v6: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v6 + 8): b, const BIGNUM* -> top, int\n(__int64 *)v7: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v7 + 8): a, const BIGNUM* -> top, int", "predict": "(__int64 *)a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 12): r, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): r, BIGNUM* -> neg, int\n(_DWORD *)(a2 + 16): a, const BIGNUM* -> neg, int\n(_DWORD *)(a3 + 16): b, const BIGNUM* -> neg, int\n(__int64 *)v6: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v6 + 8): b, const BIGNUM* -> top, int\n(__int64 *)v7: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v7 + 8): a, const BIGNUM* -> top, int", "funname": "BN_sub", "ground_truth": [["(__int64 *)a1", "r", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 12)", "r", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(a1 + 16)", "r", "BIGNUM*", "neg", "int"], ["(_DWORD *)(a2 + 16)", "a", "const BIGNUM*", "neg", "int"], ["(_DWORD *)(a3 + 16)", "b", "const BIGNUM*", "neg", "int"], ["(__int64 *)v6", "b", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(v6 + 8)", "b", "const BIGNUM*", "top", "int"], ["(__int64 *)v7", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(v7 + 8)", "a", "const BIGNUM*", "top", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A857"}
{"input": "```\n__int64 __fastcall sub_40D358(__int64 a1, int a2)\n{\nif ( a2 < 0 )\nreturn 0LL;\nif ( a2 / 64 < *(_DWORD *)(a1 + 8) )\nreturn (*(_QWORD *)(*(_QWORD *)a1 + 8LL * (a2 / 64)) >> (a2 % 64)) & 1LL;\nreturn 0LL;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)a1, (_DWORD *)(a1 + 8)?\n", "output": "(_QWORD *)a1: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, const BIGNUM* -> top, int", "predict": "(_QWORD *)a1: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, const BIGNUM* -> top, int", "funname": "BN_is_bit_set", "ground_truth": [["(_QWORD *)a1", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "a", "const BIGNUM*", "top", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D358"}
{"input": "```\n__int64 __fastcall sub_40C804(__int64 a1)\n{\nint v2; // [rsp+Ch] [rbp-Ch]\n\nif ( !*(_DWORD *)(a1 + 8) )\nreturn 0LL;\nv2 = (*(_DWORD *)(a1 + 8) - 1) << 6;\nreturn v2 + (unsigned int)sub_40C6B5(*(_QWORD *)(*(_QWORD *)a1 + 8LL * *(int *)(a1 + 8) - 8));\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)a1, (_DWORD *)(a1 + 8)?\n", "output": "(_QWORD *)a1: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, const BIGNUM* -> top, int", "predict": "(_QWORD *)a1: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, const BIGNUM* -> top, int", "funname": "BN_num_bits", "ground_truth": [["(_QWORD *)a1", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "a", "const BIGNUM*", "top", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C804"}
{"input": "```\nchar *__fastcall sub_409670(__int64 a1, __int64 a2)\n{\nunsigned int v3; // eax\nint v4[24]; // [rsp+10h] [rbp-B0h] BYREF\nchar v5[32]; // [rsp+70h] [rbp-50h] BYREF\nchar v6[32]; // [rsp+90h] [rbp-30h] BYREF\nchar *v7; // [rsp+B0h] [rbp-10h]\nunsigned int i; // [rsp+BCh] [rbp-4h]\n\nv7 = (char *)malloc(0x658uLL);\nif ( !v7 )\nreturn 0LL;\nsub_4088BF((_DWORD *)v7 + 95);\n*(_DWORD *)v7 = *(_DWORD *)(a1 + 40);\n*((_DWORD *)v7 + 2) = *(_DWORD *)(a2 + 8);\n*((_QWORD *)v7 + 2) = v7 + 532;\nmemcpy(*((void **)v7 + 2), *(const void **)(a2 + 16), *((int *)v7 + 2));\nsub_4088BF(v4);\nsub_408919(v4, *((char **)v7 + 2), *((_DWORD *)v7 + 2));\nsub_408A49((__int64)v6, v4);\n*((_DWORD *)v7 + 6) = *(_DWORD *)(a2 + 24);\n*((_QWORD *)v7 + 4) = v7 + 788;\nmemcpy(*((void **)v7 + 4), *(const void **)(a2 + 32), *((int *)v7 + 6));\nsub_4088BF(v4);\nsub_408919(v4, *((char **)v7 + 4), *((_DWORD *)v7 + 6));\nsub_408A49((__int64)v5, v4);\nfor ( i = 0; i <= 0x13; ++i )\nv6[i] ^= v5[i];\nsub_408919((int *)v7 + 95, v6, 0x14u);\nsub_4088BF(v4);\nv3 = strlen(*(const char **)a1);\nsub_408919(v4, *(char **)a1, v3);\nsub_408A49((__int64)v6, v4);\nsub_408919((int *)v7 + 95, v6, 0x14u);\n*((_DWORD *)v7 + 10) = *(_DWORD *)(a1 + 8);\n*((_QWORD *)v7 + 6) = v7 + 1044;\nmemcpy(*((void **)v7 + 6), *(const void **)(a1 + 16), *((int *)v7 + 10));\n*((_DWORD *)v7 + 14) = *(_DWORD *)(a1 + 24);\n*((_QWORD *)v7 + 8) = v7 + 1300;\nmemcpy(*((void **)v7 + 8), *(const void **)(a1 + 32), *((int *)v7 + 14));\nsub_408919((int *)v7 + 95, *((char **)v7 + 8), *((_DWORD *)v7 + 14));\n*((_QWORD *)v7 + 10) = v7 + 1332;\n*((_QWORD *)v7 + 12) = v7 + 1364;\nsub_4088BF((_DWORD *)v7 + 49);\nsub_4088BF((_DWORD *)v7 + 26);\nsub_4088BF((_DWORD *)v7 + 72);\nreturn v7;\n}\n```\nWhat are the variable name and type for the following memory accesses:(const char **)a1, (_DWORD *)(a1 + 8), (_DWORD *)(a1 + 24), (_DWORD *)(a1 + 40), v7?\n", "output": "(const char **)a1: ent, t_pwent* -> name, char*\n(_DWORD *)(a1 + 8): ent, t_pwent* -> password, t_num\n(_DWORD *)(a1 + 24): ent, t_pwent* -> salt, t_num\n(_DWORD *)(a1 + 40): ent, t_pwent* -> index, int\nv7: ts, t_server* -> index, int", "predict": "(const char **)a1: ent, t_pwent* -> name, char*\n(_DWORD *)(a1 + 8): ent, t_pwent* -> password, t_num\n(_DWORD *)(a1 + 24): ent, t_pwent* -> salt, t_num\n(_DWORD *)(a1 + 40): ent, t_pwent* -> index, int\nv7: ts, t_server* -> index, int", "funname": "t_serveropenraw", "ground_truth": [["(const char **)a1", "ent", "t_pwent*", "name", "char*"], ["(_DWORD *)(a1 + 8)", "ent", "t_pwent*", "password", "t_num"], ["(_DWORD *)(a1 + 24)", "ent", "t_pwent*", "salt", "t_num"], ["(_DWORD *)(a1 + 40)", "ent", "t_pwent*", "index", "int"], ["v7", "ts", "t_server*", "index", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "409670"}
{"input": "```\n__int64 __fastcall sub_40A626(__int64 a1, __int64 a2, __int64 a3)\n{\nbool v4; // al\nunsigned __int64 *v5; // rbx\nunsigned __int64 *v6; // r15\nunsigned __int64 *v7; // r12\nunsigned __int64 *v8; // rax\nunsigned __int64 v9; // r13\nunsigned __int64 *v10; // rax\nunsigned __int64 v11; // r14\n__int64 v12; // r13\n__int64 *v13; // rax\nunsigned __int64 *v14; // rax\nunsigned __int64 v15; // r13\nunsigned __int64 v16; // r14\nunsigned __int64 *v17; // rax\nint v18; // eax\nint v19; // eax\nint v20; // eax\nint v21; // eax\n_QWORD *v22; // rax\nint v24; // [rsp+28h] [rbp-48h]\nsigned int v25; // [rsp+2Ch] [rbp-44h]\n__int64 v26; // [rsp+30h] [rbp-40h]\n_BOOL4 v27; // [rsp+38h] [rbp-38h]\nint i; // [rsp+3Ch] [rbp-34h]\nint v29; // [rsp+3Ch] [rbp-34h]\nint v30; // [rsp+3Ch] [rbp-34h]\nint v31; // [rsp+3Ch] [rbp-34h]\n\nif ( *(_DWORD *)(a2 + 8) < *(_DWORD *)(a3 + 8) )\nreturn 0LL;\nv25 = *(_DWORD *)(a2 + 8);\nv24 = *(_DWORD *)(a3 + 8);\nif ( v25 <= *(_DWORD *)(a1 + 12) )\nv4 = a1 == 0;\nelse\nv4 = sub_40C9FA(a1, (unsigned int)v25) == 0;\nif ( v4 )\nreturn 0LL;\nv5 = *(unsigned __int64 **)a2;\nv6 = *(unsigned __int64 **)a3;\nv7 = *(unsigned __int64 **)a1;\nv27 = 0;\nfor ( i = 0; i < v24; ++i )\n{\nv8 = v5++;\nv9 = *v8;\nv10 = v6++;\nv11 = *v10;\nif ( v27 )\n{\nv27 = v9 <= v11;\nv12 = v9 - v11 - 1;\n}\nelse\n{\nv27 = v9 < v11;\nv12 = v9 - v11;\n}\nv13 = (__int64 *)v7++;\n*v13 = v12;\n}\nif ( v27 )\n{\ndo\n{\nif ( i >= v25 )\nbreak;\n++i;\nv14 = v5++;\nv15 = *v14;\nv16 = *v14 - 1;\nv17 = v7++;\n*v17 = v16;\n}\nwhile ( v15 <= v16 );\n}\nif ( v7 != v5 )\n{\nwhile ( 1 )\n{\nv18 = i;\nv29 = i + 1;\nif ( v25 <= v18 )\nbreak;\n*v7 = *v5;\nv19 = v29;\nv30 = v29 + 1;\nif ( v25 <= v19 )\nbreak;\nv7[1] = v5[1];\nv20 = v30;\nv31 = v30 + 1;\nif ( v25 <= v20 )\nbreak;\nv7[2] = v5[2];\nv21 = v31;\ni = v31 + 1;\nif ( v25 <= v21 )\nbreak;\nv7[3] = v5[3];\nv7 += 4;\nv5 += 4;\n}\n}\n*(_DWORD *)(a1 + 8) = v25;\nif ( *(int *)(a1 + 8) > 0 )\n{\nv26 = *(_QWORD *)a1 + 8LL * *(int *)(a1 + 8) - 8;\nwhile ( *(int *)(a1 + 8) > 0 )\n{\nv22 = (_QWORD *)v26;\nv26 -= 8LL;\nif ( *v22 )\nbreak;\n--*(_DWORD *)(a1 + 8);\n}\n}\nreturn 1LL;\n}\n```\nWhat are the variable name and type for the following memory accesses:(unsigned __int64 **)a1, (_DWORD *)(a1 + 8), (_DWORD *)(a1 + 12), (unsigned __int64 **)a2, (_DWORD *)(a2 + 8), (unsigned __int64 **)a3, (_DWORD *)(a3 + 8)?\n", "output": "(unsigned __int64 **)a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): r, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): r, BIGNUM* -> dmax, int\n(unsigned __int64 **)a2: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): a, const BIGNUM* -> top, int\n(unsigned __int64 **)a3: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a3 + 8): b, const BIGNUM* -> top, int", "predict": "(unsigned __int64 **)a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): r, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): r, BIGNUM* -> dmax, int\n(unsigned __int64 **)a2: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): a, const BIGNUM* -> top, int\n(unsigned __int64 **)a3: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a3 + 8): b, const BIGNUM* -> top, int", "funname": "BN_usub", "ground_truth": [["(unsigned __int64 **)a1", "r", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "r", "BIGNUM*", "top", "int"], ["(_DWORD *)(a1 + 12)", "r", "BIGNUM*", "dmax", "int"], ["(unsigned __int64 **)a2", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a2 + 8)", "a", "const BIGNUM*", "top", "int"], ["(unsigned __int64 **)a3", "b", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a3 + 8)", "b", "const BIGNUM*", "top", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A626"}
{"input": "```\n_DWORD *sub_40C999()\n{\n_DWORD *v1; // [rsp+8h] [rbp-8h]\n\nv1 = malloc(0x18uLL);\nif ( !v1 )\nreturn 0LL;\nv1[5] = 1;\nv1[2] = 0;\nv1[4] = 0;\nv1[3] = 0;\n*(_QWORD *)v1 = 0LL;\nreturn v1;\n}\n```\nWhat are the variable name and type for the following memory accesses:v1, v1[2], v1[3], v1[4], v1[5]?\n", "output": "v1: ret, BIGNUM* -> d, long unsigned int*\nv1[2]: ret, BIGNUM* -> top, int\nv1[3]: ret, BIGNUM* -> dmax, int\nv1[4]: ret, BIGNUM* -> neg, int\nv1[5]: ret, BIGNUM* -> flags, int", "predict": "v1: ret, BIGNUM* -> d, long unsigned int*\nv1[2]: ret, BIGNUM* -> top, int\nv1[3]: ret, BIGNUM* -> dmax, int\nv1[4]: ret, BIGNUM* -> neg, int\nv1[5]: ret, BIGNUM* -> flags, int", "funname": "BN_new", "ground_truth": [["v1", "ret", "BIGNUM*", "d", "long unsigned int*"], ["v1[2]", "ret", "BIGNUM*", "top", "int"], ["v1[3]", "ret", "BIGNUM*", "dmax", "int"], ["v1[4]", "ret", "BIGNUM*", "neg", "int"], ["v1[5]", "ret", "BIGNUM*", "flags", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C999"}
{"input": "```\n_DWORD *__fastcall sub_40466E(_DWORD *a1)\n{\n_DWORD *result; // rax\n\n*a1 = 1732584193;\na1[1] = -271733879;\na1[2] = -1732584194;\na1[3] = 271733878;\nresult = a1 + 4;\na1[4] = -1009589776;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1[3], a1 + 4?\n", "output": "a1: buf, uint32_t* -> -, uint32_t\na1[1]: buf, uint32_t* -> -, uint32_t\na1[2]: buf, uint32_t* -> -, uint32_t\na1[3]: buf, uint32_t* -> -, uint32_t\na1 + 4: buf, uint32_t* -> -, uint32_t", "predict": "a1: buf, uint32_t* -> -, uint32_t\na1[1]: buf, uint32_t* -> -, uint32_t\na1[2]: buf, uint32_t* -> -, uint32_t\na1[3]: buf, uint32_t* -> -, uint32_t\na1 + 4: buf, uint32_t* -> -, uint32_t", "funname": "sha_init", "ground_truth": [["a1", "buf", "uint32_t*", "-", "uint32_t"], ["a1[1]", "buf", "uint32_t*", "-", "uint32_t"], ["a1[2]", "buf", "uint32_t*", "-", "uint32_t"], ["a1[3]", "buf", "uint32_t*", "-", "uint32_t"], ["a1 + 4", "buf", "uint32_t*", "-", "uint32_t"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40466E"}
{"input": "```\n_QWORD *__fastcall sub_402514(_QWORD *a1, _QWORD *a2, __int64 a3)\n{\n_QWORD *result; // rax\n\n*(_QWORD *)(a3 + 8) = a1;\n*a1 = a3;\na1[1] = a2;\nresult = a2;\n*a2 = a1;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], (_QWORD *)(a3 + 8)?\n", "output": "a1: new, list_head* -> next, list_head*\na1[1]: new, list_head* -> prev, list_head*\n(_QWORD *)(a3 + 8): next, list_head* -> prev, list_head*", "predict": "a1: new, list_head* -> next, list_head*\na1[1]: new, list_head* -> prev, list_head*\n(_QWORD *)(a3 + 8): next, list_head* -> prev, list_head*", "funname": "__list_add", "ground_truth": [["a1", "new", "list_head*", "next", "list_head*"], ["a1[1]", "new", "list_head*", "prev", "list_head*"], ["(_QWORD *)(a3 + 8)", "next", "list_head*", "prev", "list_head*"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402514"}
{"input": "```\n__int64 __fastcall sub_40E1BA(__int64 a1, __int64 a2, int a3)\n{\nint v3; // eax\nint v4; // edx\n__int64 result; // rax\nbool v6; // al\n__int64 *v7; // rdx\n__int64 *v8; // rax\nunsigned __int64 *v9; // rax\nunsigned __int64 *v10; // rax\n__int64 *v11; // rax\nunsigned __int64 *v12; // rax\n_QWORD *v13; // rax\nint v14; // [rsp+Ch] [rbp-54h]\nunsigned __int64 v15; // [rsp+20h] [rbp-40h]\nint v16; // [rsp+28h] [rbp-38h]\nint v17; // [rsp+30h] [rbp-30h]\nint v18; // [rsp+34h] [rbp-2Ch]\n__int64 v19; // [rsp+38h] [rbp-28h]\nunsigned __int64 v20; // [rsp+40h] [rbp-20h]\n__int64 v21; // [rsp+48h] [rbp-18h]\nunsigned __int64 *v22; // [rsp+48h] [rbp-18h]\n__int64 *v23; // [rsp+50h] [rbp-10h]\nint j; // [rsp+5Ch] [rbp-4h]\nint i; // [rsp+5Ch] [rbp-4h]\n\nv14 = a3;\nv3 = a3;\nv4 = a3 + 63;\nif ( v3 < 0 )\nv3 = v4;\nv18 = v3 >> 6;\nv17 = v14 % 64;\nif ( v3 >> 6 <= *(_DWORD *)(a2 + 8) && *(_DWORD *)(a2 + 8) )\n{\nif ( a1 == a2\n|| ((*(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 8) - v18 < *(_DWORD *)(a1 + 12)) ? (v6 = a1 == 0) : (v6 = sub_40C9FA(a1, *(_DWORD *)(a2 + 8) - v18 + 1) == 0),\n!v6) )\n{\nv21 = *(_QWORD *)a2 + 8LL * v18;\nv23 = *(__int64 **)a1;\nv16 = *(_DWORD *)(a2 + 8) - v18;\n*(_DWORD *)(a1 + 8) = v16;\nif ( v17 )\n{\nv9 = (unsigned __int64 *)v21;\nv22 = (unsigned __int64 *)(v21 + 8);\nv20 = *v9;\nfor ( i = 1; i < v16; ++i )\n{\nv15 = v20 >> v17;\nv10 = v22++;\nv20 = *v10;\nv11 = v23++;\n*v11 = v15 | (v20 << (64 - (unsigned __int8)(v14 % 64)));\n}\nv12 = (unsigned __int64 *)v23++;\n*v12 = v20 >> v17;\n}\nelse\n{\nfor ( j = v16 + 1; j > 0; --j )\n{\nv7 = (__int64 *)v21;\nv21 += 8LL;\nv8 = v23++;\n*v8 = *v7;\n}\n}\n*v23 = 0LL;\nif ( *(int *)(a1 + 8) > 0 )\n{\nv19 = *(_QWORD *)a1 + 8LL * *(int *)(a1 + 8) - 8;\nwhile ( *(int *)(a1 + 8) > 0 )\n{\nv13 = (_QWORD *)v19;\nv19 -= 8LL;\nif ( *v13 )\nbreak;\n--*(_DWORD *)(a1 + 8);\n}\n}\nresult = 1LL;\n}\nelse\n{\nresult = 0LL;\n}\n}\nelse\n{\nsub_40CE13(a1, 0LL);\nresult = 1LL;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(__int64 **)a1, (_DWORD *)(a1 + 8), (_DWORD *)(a1 + 12), (_DWORD *)(a1 + 16), (_QWORD *)a2, (_DWORD *)(a2 + 8), (_DWORD *)(a2 + 16)?\n", "output": "(__int64 **)a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): r, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): r, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): r, BIGNUM* -> neg, int\n(_QWORD *)a2: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): a, BIGNUM* -> top, int\n(_DWORD *)(a2 + 16): a, BIGNUM* -> neg, int", "predict": "(__int64 **)a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): r, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): r, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): r, BIGNUM* -> neg, int\n(_QWORD *)a2: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): a, BIGNUM* -> top, int\n(_DWORD *)(a2 + 16): a, BIGNUM* -> neg, int", "funname": "BN_rshift", "ground_truth": [["(__int64 **)a1", "r", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "r", "BIGNUM*", "top", "int"], ["(_DWORD *)(a1 + 12)", "r", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(a1 + 16)", "r", "BIGNUM*", "neg", "int"], ["(_QWORD *)a2", "a", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a2 + 8)", "a", "BIGNUM*", "top", "int"], ["(_DWORD *)(a2 + 16)", "a", "BIGNUM*", "neg", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40E1BA"}
{"input": "```\n__int64 __fastcall sub_403C42(__int64 a1)\n{\n__int64 result; // rax\n\nif ( byte_414830 == 1 || (*(_DWORD *)(a1 + 32) = fork()) == 0 )\n{\nqword_414838 = a1;\nsignal(17, (__sighandler_t)handler);\nsub_4039D5(1);\nsub_403B44();\n}\nresult = *(unsigned int *)(a1 + 32);\nif ( (int)result < 0 )\n{\nresult = a1;\n*(_DWORD *)(a1 + 32) = 0;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_DWORD *)(a1 + 32)?\n", "output": "(_DWORD *)(a1 + 32): i, ead_instance* -> pid, int", "predict": "(_DWORD *)(a1 + 32): i, ead_instance* -> pid, int", "funname": "start_server", "ground_truth": [["(_DWORD *)(a1 + 32)", "i", "ead_instance*", "pid", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "403C42"}
{"input": "```\nunsigned __int64 __fastcall sub_40C061(unsigned __int64 *a1, _QWORD *a2, int a3)\n{\nunsigned __int64 result; // rax\nint v4; // [rsp+0h] [rbp-74h]\nint v5; // [rsp+0h] [rbp-74h]\nint v6; // [rsp+0h] [rbp-74h]\nint v7; // [rsp+0h] [rbp-74h]\nunsigned __int64 v10; // [rsp+14h] [rbp-60h]\n__int64 v11; // [rsp+1Ch] [rbp-58h]\nunsigned __int64 v12; // [rsp+1Ch] [rbp-58h]\nunsigned __int64 v13; // [rsp+24h] [rbp-50h]\n__int64 v14; // [rsp+2Ch] [rbp-48h]\nunsigned __int64 v15; // [rsp+2Ch] [rbp-48h]\nunsigned __int64 v16; // [rsp+34h] [rbp-40h]\n__int64 v17; // [rsp+3Ch] [rbp-38h]\nunsigned __int64 v18; // [rsp+3Ch] [rbp-38h]\nunsigned __int64 v19; // [rsp+44h] [rbp-30h]\n__int64 v20; // [rsp+4Ch] [rbp-28h]\nunsigned __int64 v21; // [rsp+4Ch] [rbp-28h]\nunsigned __int64 v22; // [rsp+54h] [rbp-20h]\nunsigned __int64 v23; // [rsp+54h] [rbp-20h]\nunsigned __int64 v24; // [rsp+5Ch] [rbp-18h]\nunsigned __int64 v25; // [rsp+5Ch] [rbp-18h]\nunsigned __int64 v26; // [rsp+64h] [rbp-10h]\nunsigned __int64 v27; // [rsp+64h] [rbp-10h]\n__int64 v28; // [rsp+6Ch] [rbp-8h]\nunsigned __int64 v29; // [rsp+6Ch] [rbp-8h]\n\nv4 = a3;\nif ( a3 > 0 )\n{\nwhile ( 1 )\n{\nv20 = (unsigned int)*a2;\nv28 = HIDWORD(*a2);\nv19 = v28 * v20;\nv29 = ((unsigned __int64)(v28 * v20) >> 31) + v28 * v28;\nv19 <<= 33;\nv21 = v19 + v20 * v20;\nif ( v21 < v19 )\n++v29;\n*a1 = v21;\nresult = v29;\na1[1] = v29;\nv5 = v4 - 1;\nif ( !v5 )\nbreak;\nv26 = a2[1];\nv17 = (unsigned int)v26;\nv26 >>= 32;\nv16 = v26 * v17;\nv27 = ((v26 * v17) >> 31) + v26 * v26;\nv16 <<= 33;\nv18 = v16 + v17 * v17;\nif ( v18 < v16 )\n++v27;\na1[2] = v18;\nresult = v27;\na1[3] = v27;\nv6 = v5 - 1;\nif ( !v6 )\nbreak;\nv24 = a2[2];\nv14 = (unsigned int)v24;\nv24 >>= 32;\nv13 = v24 * v14;\nv25 = ((v24 * v14) >> 31) + v24 * v24;\nv13 <<= 33;\nv15 = v13 + v14 * v14;\nif ( v15 < v13 )\n++v25;\na1[4] = v15;\nresult = v25;\na1[5] = v25;\nv7 = v6 - 1;\nif ( !v7 )\nbreak;\nv22 = a2[3];\nv11 = (unsigned int)v22;\nv22 >>= 32;\nv10 = v22 * v11;\nv23 = ((v22 * v11) >> 31) + v22 * v22;\nv10 <<= 33;\nv12 = v10 + v11 * v11;\nif ( v12 < v10 )\n++v23;\na1[6] = v12;\nresult = v23;\na1[7] = v23;\nv4 = v7 - 1;\nif ( !v4 )\nbreak;\na2 += 4;\na1 += 8;\n}\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1[3], a1[4], a1[5], a1[6], a1[7], a2, a2[1], a2[2], a2[3]?\n", "output": "a1: r, long unsigned int* -> -, long unsigned int\na1[1]: r, long unsigned int* -> -, long unsigned int\na1[2]: r, long unsigned int* -> -, long unsigned int\na1[3]: r, long unsigned int* -> -, long unsigned int\na1[4]: r, long unsigned int* -> -, long unsigned int\na1[5]: r, long unsigned int* -> -, long unsigned int\na1[6]: r, long unsigned int* -> -, long unsigned int\na1[7]: r, long unsigned int* -> -, long unsigned int\na2: a, long unsigned int* -> -, long unsigned int\na2[1]: a, long unsigned int* -> -, long unsigned int\na2[2]: a, long unsigned int* -> -, long unsigned int\na2[3]: a, long unsigned int* -> -, long unsigned int", "predict": "a1: r, long unsigned int* -> -, long unsigned int\na1[1]: r, long unsigned int* -> -, long unsigned int\na1[2]: r, long unsigned int* -> -, long unsigned int\na1[3]: r, long unsigned int* -> -, long unsigned int\na1[4]: r, long unsigned int* -> -, long unsigned int\na1[5]: r, long unsigned int* -> -, long unsigned int\na1[6]: r, long unsigned int* -> -, long unsigned int\na1[7]: r, long unsigned int* -> -, long unsigned int\na2: a, long unsigned int* -> -, long unsigned int\na2[1]: a, long unsigned int* -> -, long unsigned int\na2[2]: a, long unsigned int* -> -, long unsigned int\na2[3]: a, long unsigned int* -> -, long unsigned int", "funname": "bn_sqr_words", "ground_truth": [["a1", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[1]", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[2]", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[3]", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[4]", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[5]", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[6]", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[7]", "r", "long unsigned int*", "-", "long unsigned int"], ["a2", "a", "long unsigned int*", "-", "long unsigned int"], ["a2[1]", "a", "long unsigned int*", "-", "long unsigned int"], ["a2[2]", "a", "long unsigned int*", "-", "long unsigned int"], ["a2[3]", "a", "long unsigned int*", "-", "long unsigned int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C061"}
{"input": "```\n__int64 __fastcall sub_405FA1(__int64 a1)\n{\n__int64 result; // rax\nunsigned int v2; // eax\nuint32_t v3; // eax\nint s2[8]; // [rsp+10h] [rbp-50h] BYREF\nint s1[5]; // [rsp+30h] [rbp-30h] BYREF\nint v6; // [rsp+44h] [rbp-1Ch]\nunsigned __int8 *v7; // [rsp+48h] [rbp-18h]\nint i; // [rsp+50h] [rbp-10h]\nint v9; // [rsp+54h] [rbp-Ch]\nunsigned __int8 *v10; // [rsp+58h] [rbp-8h]\n\nv7 = (unsigned __int8 *)(a1 + 20);\nv10 = (unsigned __int8 *)(a1 + 20);\nv9 = ntohl(*(_DWORD *)(a1 + 4));\nv6 = v9;\nif ( !v9 || v9 % 64 > 0 )\nreturn 0LL;\nwhile ( v9 > 0 )\n{\nsub_4054D5(dword_414E40, v10, v10);\nv10 += 16;\nv9 -= 16;\n}\nv10 = v7;\nif ( v7[24] > 0x3Fu )\nreturn 0LL;\nv2 = ntohl(*((_DWORD *)v7 + 5));\nif ( (unsigned __int8)sub_405DB9(v2) != 1 )\nreturn 0LL;\nfor ( i = 0; i <= 4; ++i )\n{\nv3 = ntohl(*(_DWORD *)&v7[4 * i]);\ns1[i] = v3;\n}\nsub_405E43(v7, s2, v6);\nif ( !memcmp(s1, s2, 0x14uLL) )\nresult = v6 - (unsigned int)v7[24] - 25;\nelse\nresult = 0LL;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_DWORD *)(a1 + 4), v7, (_DWORD *)v7 + 5, v7[24]?\n", "output": "(_DWORD *)(a1 + 4): msg, ead_msg* -> len, uint32_t\nv7: enc, ead_msg_encrypted* -> hash, uint32_t[-]\n(_DWORD *)v7 + 5: enc, ead_msg_encrypted* -> iv, uint32_t\nv7[24]: enc, ead_msg_encrypted* -> pad, uint8_t", "predict": "(_DWORD *)(a1 + 4): msg, ead_msg* -> len, uint32_t\nv7: enc, ead_msg_encrypted* -> hash, uint32_t[-]\n(_DWORD *)v7 + 5: enc, ead_msg_encrypted* -> iv, uint32_t\nv7[24]: enc, ead_msg_encrypted* -> pad, uint8_t", "funname": "ead_decrypt_message", "ground_truth": [["(_DWORD *)(a1 + 4)", "msg", "ead_msg*", "len", "uint32_t"], ["v7", "enc", "ead_msg_encrypted*", "hash", "uint32_t[-]"], ["(_DWORD *)v7 + 5", "enc", "ead_msg_encrypted*", "iv", "uint32_t"], ["v7[24]", "enc", "ead_msg_encrypted*", "pad", "uint8_t"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405FA1"}
{"input": "```\n__int64 __fastcall sub_405D19(__int64 a1)\n{\n__int64 result; // rax\n\nmemset(dword_414D80, 0, 0xB0uLL);\nmemset(dword_414E40, 0, sizeof(dword_414E40));\nsub_4046D3(dword_414D80, (unsigned __int8 *)a1);\nsub_40493E(dword_414E40, (unsigned __int8 *)a1);\ndword_414EF0 = ntohl(*(_DWORD *)(a1 + 32)) & 0xFFFFFF;\ndword_414EF4 = dword_414EF0;\nresult = *(unsigned int *)(a1 + 36);\ndword_414EF8 = *(_DWORD *)(a1 + 36);\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(unsigned __int8 *)a1, (unsigned int *)(a1 + 36)?\n", "output": "(unsigned __int8 *)a1: skey, unsigned char* -> -, unsigned char\n(unsigned int *)(a1 + 36): skey, unsigned char* -> -, unsigned char", "predict": "(unsigned __int8 *)a1: skey, unsigned char* -> -, unsigned char\n(unsigned int *)(a1 + 36): skey, unsigned char* -> -, unsigned char", "funname": "ead_set_key", "ground_truth": [["(unsigned __int8 *)a1", "skey", "unsigned char*", "-", "unsigned char"], ["(unsigned int *)(a1 + 36)", "skey", "unsigned char*", "-", "unsigned char"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405D19"}
{"input": "```\n__int64 __fastcall sub_40B1C5(__int64 a1, __int64 a2, __int64 a3, int *a4)\n{\nbool v5; // al\n_QWORD *v6; // rax\nunsigned int v9; // [rsp+2Ch] [rbp-24h]\nunsigned int v10; // [rsp+30h] [rbp-20h]\nunsigned int v11; // [rsp+34h] [rbp-1Ch]\n__int64 v12; // [rsp+38h] [rbp-18h]\nunsigned int v13; // [rsp+44h] [rbp-Ch]\n__int64 v14; // [rsp+48h] [rbp-8h]\n\nv13 = 0;\nv11 = *(_DWORD *)(a2 + 8);\nv10 = *(_DWORD *)(a3 + 8);\nif ( !v11 || !v10 )\n{\nsub_40CE13(a1, 0LL);\nreturn 1LL;\n}\nv9 = v11 + v10;\nsub_40AB08(a4);\nif ( a1 != a2 && a1 != a3 )\n{\nv14 = a1;\nLABEL_9:\n*(_DWORD *)(v14 + 16) = *(_DWORD *)(a3 + 16) ^ *(_DWORD *)(a2 + 16);\nif ( (signed int)v9 <= *(_DWORD *)(v14 + 12) )\nv5 = v14 == 0;\nelse\nv5 = sub_40C9FA(v14, v9) == 0;\nif ( !v5 )\n{\n*(_DWORD *)(v14 + 8) = v9;\nsub_40B381(*(_QWORD *)v14, *(_QWORD *)a2, v11, *(_QWORD *)a3, v10);\nif ( *(int *)(v14 + 8) > 0 )\n{\nv12 = *(_QWORD *)v14 + 8LL * *(int *)(v14 + 8) - 8;\nwhile ( *(int *)(v14 + 8) > 0 )\n{\nv6 = (_QWORD *)v12;\nv12 -= 8LL;\nif ( *v6 )\nbreak;\n--*(_DWORD *)(v14 + 8);\n}\n}\nif ( a1 != v14 )\nsub_40CC70(a1, v14);\nv13 = 1;\n}\ngoto LABEL_21;\n}\nv14 = sub_40AB57(a4);\nif ( v14 )\ngoto LABEL_9;\nLABEL_21:\nsub_40ABC8(a4);\nreturn v13;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)a2, (_DWORD *)(a2 + 8), (_DWORD *)(a2 + 16), (_QWORD *)a3, (_DWORD *)(a3 + 8), (_DWORD *)(a3 + 16), (_QWORD *)v14, (_DWORD *)(v14 + 8), (_DWORD *)(v14 + 12), (_DWORD *)(v14 + 16)?\n", "output": "(_QWORD *)a2: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): a, BIGNUM* -> top, int\n(_DWORD *)(a2 + 16): a, BIGNUM* -> neg, int\n(_QWORD *)a3: b, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a3 + 8): b, BIGNUM* -> top, int\n(_DWORD *)(a3 + 16): b, BIGNUM* -> neg, int\n(_QWORD *)v14: rr, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v14 + 8): rr, BIGNUM* -> top, int\n(_DWORD *)(v14 + 12): rr, BIGNUM* -> dmax, int\n(_DWORD *)(v14 + 16): rr, BIGNUM* -> neg, int", "predict": "(_QWORD *)a2: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): a, BIGNUM* -> top, int\n(_DWORD *)(a2 + 16): a, BIGNUM* -> neg, int\n(_QWORD *)a3: b, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a3 + 8): b, BIGNUM* -> top, int\n(_DWORD *)(a3 + 16): b, BIGNUM* -> neg, int\n(_QWORD *)v14: rr, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v14 + 8): rr, BIGNUM* -> top, int\n(_DWORD *)(v14 + 12): rr, BIGNUM* -> dmax, int\n(_DWORD *)(v14 + 16): rr, BIGNUM* -> neg, int", "funname": "BN_mul", "ground_truth": [["(_QWORD *)a2", "a", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a2 + 8)", "a", "BIGNUM*", "top", "int"], ["(_DWORD *)(a2 + 16)", "a", "BIGNUM*", "neg", "int"], ["(_QWORD *)a3", "b", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a3 + 8)", "b", "BIGNUM*", "top", "int"], ["(_DWORD *)(a3 + 16)", "b", "BIGNUM*", "neg", "int"], ["(_QWORD *)v14", "rr", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(v14 + 8)", "rr", "BIGNUM*", "top", "int"], ["(_DWORD *)(v14 + 12)", "rr", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(v14 + 16)", "rr", "BIGNUM*", "neg", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40B1C5"}
{"input": "```\nint *__fastcall sub_40427F(int *a1, __int64 a2, __int64 a3)\n{\nint *result; // rax\nint v5; // [rsp+1Ch] [rbp-24h]\nint v6; // [rsp+1Ch] [rbp-24h]\nint v7; // [rsp+1Ch] [rbp-24h]\nint v8; // [rsp+1Ch] [rbp-24h]\nunsigned int i; // [rsp+20h] [rbp-20h]\nunsigned int j; // [rsp+20h] [rbp-20h]\nunsigned int k; // [rsp+20h] [rbp-20h]\nint v12; // [rsp+24h] [rbp-1Ch]\nint v13; // [rsp+28h] [rbp-18h]\nint v14; // [rsp+2Ch] [rbp-14h]\nint v15; // [rsp+30h] [rbp-10h]\nint v16; // [rsp+34h] [rbp-Ch]\n\nfor ( i = 0; i <= 0xF; ++i )\n*(_DWORD *)(4LL * i + a3) = *(unsigned __int8 *)((int)(4 * i) + 3LL + a2) | (*(unsigned __int8 *)((int)(4 * i) + 2LL + a2) << 8) | (*(unsigned __int8 *)((int)(4 * i) + 1LL + a2) << 16) | (*(unsigned __int8 *)((int)(4 * i) + a2) << 24);\nfor ( j = 0; j <= 0x3F; ++j )\n*(_DWORD *)(4LL * (j + 16) + a3) = sub_404267(\n*(_DWORD *)(4LL * (j + 2) + a3) ^ (unsigned int)(*(_DWORD *)(4LL * (j + 8) + a3) ^ *(_DWORD *)(4LL * (j + 13) + a3)) ^ *(_DWORD *)(4LL * j + a3),\n1);\nv16 = *a1;\nv15 = a1[1];\nv14 = a1[2];\nv13 = a1[3];\nv12 = a1[4];\nfor ( k = 0; k <= 0x13; ++k )\n{\nv5 = v12 + (v13 ^ v15 & (v13 ^ v14)) + sub_404267(v16, 5) + *(_DWORD *)(4LL * k + a3) + 1518500249;\nv12 = v13;\nv13 = v14;\nv14 = sub_404267(v15, 30);\nv15 = v16;\nv16 = v5;\n}\nwhile ( k <= 0x27 )\n{\nv6 = v12 + (v13 ^ v14 ^ v15) + sub_404267(v16, 5) + *(_DWORD *)(4LL * k + a3) + 1859775393;\nv12 = v13;\nv13 = v14;\nv14 = sub_404267(v15, 30);\nv15 = v16;\nv16 = v6;\n++k;\n}\nwhile ( k <= 0x3B )\n{\nv7 = v12 + (v14 & v15) + (v13 & (v14 ^ v15)) + sub_404267(v16, 5) + *(_DWORD *)(4LL * k + a3) - 1894007588;\nv12 = v13;\nv13 = v14;\nv14 = sub_404267(v15, 30);\nv15 = v16;\nv16 = v7;\n++k;\n}\nwhile ( k <= 0x4F )\n{\nv8 = v12 + (v13 ^ v14 ^ v15) + sub_404267(v16, 5) + *(_DWORD *)(4LL * k + a3) - 899497514;\nv12 = v13;\nv13 = v14;\nv14 = sub_404267(v15, 30);\nv15 = v16;\nv16 = v8;\n++k;\n}\n*a1 += v16;\na1[1] += v15;\na1[2] += v14;\na1[3] += v13;\nresult = a1 + 4;\na1[4] += v12;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1[3], a1[4]?\n", "output": "a1: digest, uint32_t* -> -, uint32_t\na1[1]: digest, uint32_t* -> -, uint32_t\na1[2]: digest, uint32_t* -> -, uint32_t\na1[3]: digest, uint32_t* -> -, uint32_t\na1[4]: digest, uint32_t* -> -, uint32_t", "predict": "a1: digest, uint32_t* -> -, uint32_t\na1[1]: digest, uint32_t* -> -, uint32_t\na1[2]: digest, uint32_t* -> -, uint32_t\na1[3]: digest, uint32_t* -> -, uint32_t\na1[4]: digest, uint32_t* -> -, uint32_t", "funname": "sha_transform", "ground_truth": [["a1", "digest", "uint32_t*", "-", "uint32_t"], ["a1[1]", "digest", "uint32_t*", "-", "uint32_t"], ["a1[2]", "digest", "uint32_t*", "-", "uint32_t"], ["a1[3]", "digest", "uint32_t*", "-", "uint32_t"], ["a1[4]", "digest", "uint32_t*", "-", "uint32_t"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40427F"}
{"input": "```\nunsigned __int64 __fastcall sub_40B510(unsigned __int64 *a1, _QWORD *a2, int a3, unsigned __int64 a4)\n{\nint v5; // [rsp+Ch] [rbp-F4h]\nint v6; // [rsp+Ch] [rbp-F4h]\nint v7; // [rsp+Ch] [rbp-F4h]\nint v8; // [rsp+Ch] [rbp-F4h]\nunsigned __int64 v11; // [rsp+30h] [rbp-D0h]\nunsigned __int64 v12; // [rsp+38h] [rbp-C8h]\n__int64 v13; // [rsp+40h] [rbp-C0h]\nunsigned __int64 v14; // [rsp+40h] [rbp-C0h]\nunsigned __int64 v15; // [rsp+50h] [rbp-B0h]\nunsigned __int64 v16; // [rsp+58h] [rbp-A8h]\n__int64 v17; // [rsp+60h] [rbp-A0h]\nunsigned __int64 v18; // [rsp+60h] [rbp-A0h]\nunsigned __int64 v19; // [rsp+70h] [rbp-90h]\nunsigned __int64 v20; // [rsp+78h] [rbp-88h]\n__int64 v21; // [rsp+80h] [rbp-80h]\nunsigned __int64 v22; // [rsp+80h] [rbp-80h]\nunsigned __int64 v23; // [rsp+90h] [rbp-70h]\nunsigned __int64 v24; // [rsp+98h] [rbp-68h]\n__int64 v25; // [rsp+A0h] [rbp-60h]\nunsigned __int64 v26; // [rsp+A0h] [rbp-60h]\nunsigned __int64 v27; // [rsp+A8h] [rbp-58h]\n__int64 v28; // [rsp+B8h] [rbp-48h]\nunsigned __int64 v29; // [rsp+B8h] [rbp-48h]\nunsigned __int64 v30; // [rsp+C0h] [rbp-40h]\nunsigned __int64 v31; // [rsp+C0h] [rbp-40h]\n__int64 v32; // [rsp+C8h] [rbp-38h]\nunsigned __int64 v33; // [rsp+C8h] [rbp-38h]\nunsigned __int64 v34; // [rsp+D0h] [rbp-30h]\nunsigned __int64 v35; // [rsp+D0h] [rbp-30h]\n__int64 v36; // [rsp+D8h] [rbp-28h]\nunsigned __int64 v37; // [rsp+D8h] [rbp-28h]\nunsigned __int64 v38; // [rsp+E0h] [rbp-20h]\nunsigned __int64 v39; // [rsp+E0h] [rbp-20h]\n__int64 v40; // [rsp+E8h] [rbp-18h]\nunsigned __int64 v41; // [rsp+E8h] [rbp-18h]\n__int64 v42; // [rsp+F0h] [rbp-10h]\nunsigned __int64 v43; // [rsp+F0h] [rbp-10h]\nunsigned __int64 v44; // [rsp+F8h] [rbp-8h]\nunsigned __int64 v45; // [rsp+F8h] [rbp-8h]\nunsigned __int64 v46; // [rsp+F8h] [rbp-8h]\nunsigned __int64 v47; // [rsp+F8h] [rbp-8h]\n\nv5 = a3;\nv44 = 0LL;\nif ( a3 <= 0 )\nreturn 0LL;\nv27 = HIDWORD(a4);\nwhile ( 1 )\n{\nv25 = (unsigned int)*a2;\nv42 = HIDWORD(*a2);\nv40 = v27 * v42;\nv23 = v42 * (unsigned int)a4 + v25 * v27;\nif ( v23 < v42 * (unsigned __int64)(unsigned int)a4 )\nv40 += 0x100000000LL;\nv41 = HIDWORD(v23) + v40;\nv24 = (v23 << 32) + (unsigned int)a4 * v25;\nif ( v24 < v23 << 32 )\n++v41;\nv43 = v41;\nif ( v44 + v24 < v44 )\nv43 = v41 + 1;\nv26 = *a1 + v44 + v24;\nif ( v26 < *a1 )\n++v43;\nv44 = v43;\n*a1 = v26;\nv6 = v5 - 1;\nif ( !v6 )\nbreak;\nv38 = a2[1];\nv21 = (unsigned int)v38;\nv38 >>= 32;\nv36 = v27 * v38;\nv19 = v38 * (unsigned int)a4 + v21 * v27;\nif ( v19 < v38 * (unsigned int)a4 )\nv36 += 0x100000000LL;\nv37 = HIDWORD(v19) + v36;\nv20 = (v19 << 32) + (unsigned int)a4 * v21;\nif ( v20 < v19 << 32 )\n++v37;\nv39 = v37;\nif ( v43 + v20 < v43 )\nv39 = v37 + 1;\nv45 = a1[1];\nv22 = v45 + v43 + v20;\nif ( v22 < v45 )\n++v39;\nv44 = v39;\na1[1] = v22;\nv7 = v6 - 1;\nif ( !v7 )\nbreak;\nv34 = a2[2];\nv17 = (unsigned int)v34;\nv34 >>= 32;\nv32 = v27 * v34;\nv15 = v34 * (unsigned int)a4 + v17 * v27;\nif ( v15 < v34 * (unsigned int)a4 )\nv32 += 0x100000000LL;\nv33 = HIDWORD(v15) + v32;\nv16 = (v15 << 32) + (unsigned int)a4 * v17;\nif ( v16 < v15 << 32 )\n++v33;\nv35 = v33;\nif ( v39 + v16 < v39 )\nv35 = v33 + 1;\nv46 = a1[2];\nv18 = v46 + v39 + v16;\nif ( v18 < v46 )\n++v35;\nv44 = v35;\na1[2] = v18;\nv8 = v7 - 1;\nif ( !v8 )\nbreak;\nv30 = a2[3];\nv13 = (unsigned int)v30;\nv30 >>= 32;\nv28 = v27 * v30;\nv11 = v30 * (unsigned int)a4 + v13 * v27;\nif ( v11 < v30 * (unsigned int)a4 )\nv28 += 0x100000000LL;\nv29 = HIDWORD(v11) + v28;\nv12 = (v11 << 32) + (unsigned int)a4 * v13;\nif ( v12 < v11 << 32 )\n++v29;\nv31 = v29;\nif ( v35 + v12 < v35 )\nv31 = v29 + 1;\nv47 = a1[3];\nv14 = v47 + v35 + v12;\nif ( v14 < v47 )\n++v31;\nv44 = v31;\na1[3] = v14;\nv5 = v8 - 1;\nif ( !v5 )\nbreak;\na2 += 4;\na1 += 4;\n}\nreturn v44;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1[3], a2, a2[1], a2[2], a2[3]?\n", "output": "a1: rp, long unsigned int* -> -, long unsigned int\na1[1]: rp, long unsigned int* -> -, long unsigned int\na1[2]: rp, long unsigned int* -> -, long unsigned int\na1[3]: rp, long unsigned int* -> -, long unsigned int\na2: ap, long unsigned int* -> -, long unsigned int\na2[1]: ap, long unsigned int* -> -, long unsigned int\na2[2]: ap, long unsigned int* -> -, long unsigned int\na2[3]: ap, long unsigned int* -> -, long unsigned int", "predict": "a1: rp, long unsigned int* -> -, long unsigned int\na1[1]: rp, long unsigned int* -> -, long unsigned int\na1[2]: rp, long unsigned int* -> -, long unsigned int\na1[3]: rp, long unsigned int* -> -, long unsigned int\na2: ap, long unsigned int* -> -, long unsigned int\na2[1]: ap, long unsigned int* -> -, long unsigned int\na2[2]: ap, long unsigned int* -> -, long unsigned int\na2[3]: ap, long unsigned int* -> -, long unsigned int", "funname": "bn_mul_add_words", "ground_truth": [["a1", "rp", "long unsigned int*", "-", "long unsigned int"], ["a1[1]", "rp", "long unsigned int*", "-", "long unsigned int"], ["a1[2]", "rp", "long unsigned int*", "-", "long unsigned int"], ["a1[3]", "rp", "long unsigned int*", "-", "long unsigned int"], ["a2", "ap", "long unsigned int*", "-", "long unsigned int"], ["a2[1]", "ap", "long unsigned int*", "-", "long unsigned int"], ["a2[2]", "ap", "long unsigned int*", "-", "long unsigned int"], ["a2[3]", "ap", "long unsigned int*", "-", "long unsigned int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40B510"}
{"input": "```\nvoid __fastcall sub_40C906(__int64 a1)\n{\nint v1; // eax\n\nif ( a1 )\n{\nif ( *(_QWORD *)a1 && (*(_DWORD *)(a1 + 20) & 2) == 0 )\nfree(*(void **)a1);\nv1 = *(_DWORD *)(a1 + 20);\nBYTE1(v1) |= 0x80u;\n*(_DWORD *)(a1 + 20) = v1;\nif ( (*(_DWORD *)(a1 + 20) & 1) != 0 )\nfree((void *)a1);\n}\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)a1, (_DWORD *)(a1 + 20)?\n", "output": "(_QWORD *)a1: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 20): a, BIGNUM* -> flags, int", "predict": "(_QWORD *)a1: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 20): a, BIGNUM* -> flags, int", "funname": "BN_free", "ground_truth": [["(_QWORD *)a1", "a", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 20)", "a", "BIGNUM*", "flags", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C906"}
{"input": "```\n__int64 __fastcall sub_4025A8(__int64 a1)\n{\n__int64 result; // rax\n\nsub_402582(*(_QWORD **)(a1 + 8), *(_QWORD *)a1);\n*(_QWORD *)a1 = 0LL;\nresult = a1;\n*(_QWORD *)(a1 + 8) = 0LL;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)a1, (_QWORD **)(a1 + 8)?\n", "output": "(_QWORD *)a1: entry, list_head* -> next, list_head*\n(_QWORD **)(a1 + 8): entry, list_head* -> prev, list_head*", "predict": "(_QWORD *)a1: entry, list_head_t* -> next, list_head*\n(_QWORD **)(a1 + 8): entry, list_head_t* -> prev, list_head*", "funname": "list_del", "ground_truth": [["(_QWORD *)a1", "entry", "list_head*", "next", "list_head*"], ["(_QWORD **)(a1 + 8)", "entry", "list_head*", "prev", "list_head*"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4025A8"}
{"input": "```\n__int64 __fastcall sub_40DF1C(__int64 a1, __int64 *a2, int a3)\n{\nint v3; // eax\nint v4; // edx\nbool v5; // al\n_QWORD *v7; // rax\nint v8; // [rsp+Ch] [rbp-54h]\nunsigned __int64 v9; // [rsp+28h] [rbp-38h]\n_QWORD *s; // [rsp+30h] [rbp-30h]\n__int64 v11; // [rsp+38h] [rbp-28h]\nint v12; // [rsp+4Ch] [rbp-14h]\n__int64 v13; // [rsp+50h] [rbp-10h]\nint j; // [rsp+5Ch] [rbp-4h]\nint i; // [rsp+5Ch] [rbp-4h]\n\nv8 = a3;\n*(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);\nv3 = a3;\nv4 = a3 + 63;\nif ( v8 < 0 )\nv3 = v4;\nif ( *((_DWORD *)a2 + 2) + (v3 >> 6) < *(_DWORD *)(a1 + 12) )\nv5 = a1 == 0;\nelse\nv5 = sub_40C9FA(a1, *((_DWORD *)a2 + 2) + v8 / 64 + 1) == 0;\nif ( v5 )\nreturn 0LL;\nv12 = v8 / 64;\nv11 = *a2;\ns = *(_QWORD **)a1;\n*(_QWORD *)(8LL * (*((_DWORD *)a2 + 2) + v8 / 64) + *(_QWORD *)a1) = 0LL;\nif ( v8 % 64 )\n{\nfor ( i = *((_DWORD *)a2 + 2) - 1; i >= 0; --i )\n{\nv9 = *(_QWORD *)(8LL * i + v11);\ns[v12 + 1 + i] |= v9 >> (64 - (unsigned __int8)(v8 % 64));\ns[v12 + i] = v9 << (v8 % 64);\n}\n}\nelse\n{\nfor ( j = *((_DWORD *)a2 + 2) - 1; j >= 0; --j )\ns[v12 + j] = *(_QWORD *)(8LL * j + v11);\n}\nmemset(s, 0, 8LL * v12);\n*(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2) + v12 + 1;\nif ( *(int *)(a1 + 8) > 0 )\n{\nv13 = *(_QWORD *)a1 + 8LL * *(int *)(a1 + 8) - 8;\nwhile ( *(int *)(a1 + 8) > 0 )\n{\nv7 = (_QWORD *)v13;\nv13 -= 8LL;\nif ( *v7 )\nbreak;\n--*(_DWORD *)(a1 + 8);\n}\n}\nreturn 1LL;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD **)a1, (_DWORD *)(a1 + 8), (_DWORD *)(a1 + 12), (_DWORD *)(a1 + 16), a2, (_DWORD *)a2 + 2, (_DWORD *)a2 + 4?\n", "output": "(_QWORD **)a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): r, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): r, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): r, BIGNUM* -> neg, int\na2: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)a2 + 2: a, const BIGNUM* -> top, int\n(_DWORD *)a2 + 4: a, const BIGNUM* -> neg, int", "predict": "(_QWORD **)a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): r, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): r, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): r, BIGNUM* -> neg, int\na2: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)a2 + 2: a, const BIGNUM* -> top, int\n(_DWORD *)a2 + 4: a, const BIGNUM* -> neg, int", "funname": "BN_lshift", "ground_truth": [["(_QWORD **)a1", "r", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "r", "BIGNUM*", "top", "int"], ["(_DWORD *)(a1 + 12)", "r", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(a1 + 16)", "r", "BIGNUM*", "neg", "int"], ["a2", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)a2 + 2", "a", "const BIGNUM*", "top", "int"], ["(_DWORD *)a2 + 4", "a", "const BIGNUM*", "neg", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40DF1C"}
{"input": "```\n__int64 __fastcall sub_4031DB(__int64 a1, __int64 a2, _DWORD *a3)\n{\n__int64 result; // rax\nconst void *v4; // rax\nchar *dest; // [rsp+20h] [rbp-20h]\nchar *v7; // [rsp+28h] [rbp-18h]\n\nif ( (unsigned int)sub_409FD9(qword_414840, a1 + 62) )\n{\n*a3 = 2;\nresult = 0LL;\n}\nelse\n{\nv7 = (char *)off_4132D8 + 42;\ndest = (char *)off_4132D8 + 62;\n*((_DWORD *)v7 + 1) = htonl(0x14u);\nv4 = (const void *)sub_40A0EF(qword_414840);\nmemmove(dest, v4, 0x14uLL);\n*a3 = 10;\nresult = 1LL;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_DWORD *)v7 + 1?\n", "output": "(_DWORD *)v7 + 1: msg, ead_msg* -> len, uint32_t", "predict": "(_DWORD *)v7 + 1: msg, ead_msg* -> len, uint32_t", "funname": "handle_send_auth", "ground_truth": [["(_DWORD *)v7 + 1", "msg", "ead_msg*", "len", "uint32_t"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4031DB"}
{"input": "```\n__int64 __fastcall sub_40D158(__int64 a1, __int64 a2)\n{\n__int64 result; // rax\nunsigned __int64 v3; // [rsp+18h] [rbp-28h]\nunsigned __int64 v4; // [rsp+20h] [rbp-20h]\nunsigned int v5; // [rsp+3Ch] [rbp-4h]\nint i; // [rsp+3Ch] [rbp-4h]\n\nv5 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8);\nif ( v5 )\nreturn v5;\nfor ( i = *(_DWORD *)(a1 + 8) - 1; ; --i )\n{\nif ( i < 0 )\nreturn 0LL;\nv4 = *(_QWORD *)(8LL * i + *(_QWORD *)a1);\nv3 = *(_QWORD *)(8LL * i + *(_QWORD *)a2);\nif ( v4 != v3 )\nbreak;\n}\nif ( v4 <= v3 )\nresult = 0xFFFFFFFFLL;\nelse\nresult = 1LL;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)a1, (_DWORD *)(a1 + 8), (_QWORD *)a2, (_DWORD *)(a2 + 8)?\n", "output": "(_QWORD *)a1: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, const BIGNUM* -> top, int\n(_QWORD *)a2: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): b, const BIGNUM* -> top, int", "predict": "(_QWORD *)a1: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, const BIGNUM* -> top, int\n(_QWORD *)a2: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): b, const BIGNUM* -> top, int", "funname": "BN_ucmp", "ground_truth": [["(_QWORD *)a1", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "a", "const BIGNUM*", "top", "int"], ["(_QWORD *)a2", "b", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a2 + 8)", "b", "const BIGNUM*", "top", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D158"}
{"input": "```\n__int64 __fastcall sub_40D754(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int *a5)\n{\n__int64 v6; // rax\n_QWORD *v9; // rax\n__int64 v13; // [rsp+30h] [rbp-E0h] BYREF\nint v14; // [rsp+38h] [rbp-D8h]\nint v15; // [rsp+3Ch] [rbp-D4h]\nint v16; // [rsp+40h] [rbp-D0h]\nunsigned __int64 v17; // [rsp+50h] [rbp-C0h]\nunsigned __int64 v18; // [rsp+58h] [rbp-B8h]\nunsigned __int64 v19; // [rsp+60h] [rbp-B0h]\nunsigned __int64 v20; // [rsp+68h] [rbp-A8h]\nunsigned __int64 v21; // [rsp+70h] [rbp-A0h]\n__int64 v22; // [rsp+78h] [rbp-98h]\nunsigned __int64 v23; // [rsp+80h] [rbp-90h]\nunsigned __int64 v24; // [rsp+88h] [rbp-88h]\nunsigned __int64 v25; // [rsp+90h] [rbp-80h]\nunsigned __int64 v26; // [rsp+98h] [rbp-78h]\nint v27; // [rsp+A0h] [rbp-70h]\nint v28; // [rsp+A4h] [rbp-6Ch]\nint v29; // [rsp+A8h] [rbp-68h]\nunsigned int v30; // [rsp+ACh] [rbp-64h]\n__int64 v31; // [rsp+B0h] [rbp-60h]\n__int64 v32; // [rsp+B8h] [rbp-58h]\n__int64 v33; // [rsp+C0h] [rbp-50h]\nunsigned __int64 v34; // [rsp+C8h] [rbp-48h]\nunsigned __int64 v35; // [rsp+D0h] [rbp-40h]\nunsigned __int64 v36; // [rsp+D8h] [rbp-38h]\nunsigned __int64 v37; // [rsp+E0h] [rbp-30h]\nunsigned __int64 v38; // [rsp+E8h] [rbp-28h]\nunsigned __int64 *v39; // [rsp+F0h] [rbp-20h]\n_QWORD *v40; // [rsp+F8h] [rbp-18h]\n__int64 v41; // [rsp+100h] [rbp-10h]\nint j; // [rsp+108h] [rbp-8h]\nint i; // [rsp+10Ch] [rbp-4h]\n\nif ( !*(_DWORD *)(a4 + 8) || *(_DWORD *)(a4 + 8) == 1 && !**(_QWORD **)a4 )\nreturn 0LL;\nif ( (int)sub_40D158(a3, a4) < 0 )\n{\nif ( a2 && !sub_40CC70(a2, a3) )\nreturn 0LL;\nif ( a1 )\nsub_40CE13(a1, 0LL);\nreturn 1LL;\n}\nsub_40AB08(a5);\nv33 = sub_40AB57(a5);\n*(_DWORD *)(v33 + 16) = 0;\nv32 = sub_40AB57(a5);\nv31 = sub_40AB57(a5);\nif ( a1 )\nv41 = a1;\nelse\nv41 = sub_40AB57(a5);\nif ( !v41 )\ngoto LABEL_57;\nv30 = 64 - (int)sub_40C804(a4) % 64;\nsub_40DF1C(v31, a4, v30);\n*(_DWORD *)(v31 + 16) = 0;\nv30 += 64;\nsub_40DF1C(v32, a3, v30);\n*(_DWORD *)(v32 + 16) = 0;\nv29 = *(_DWORD *)(v31 + 8);\nv28 = *(_DWORD *)(v32 + 8);\nv27 = v28 - v29;\nsub_40C974(&v13);\nv13 = *(_QWORD *)v32 + 8LL * v27;\nv14 = v29;\nv15 = *(_DWORD *)(v32 + 12) + 1;\nv26 = *(_QWORD *)(*(_QWORD *)v31 + 8LL * v29 - 8);\nv6 = v29 == 1 ? 0LL : *(_QWORD *)(*(_QWORD *)v31 + 8LL * v29 - 16);\nv25 = v6;\nv39 = (unsigned __int64 *)(*(_QWORD *)v32 + 8LL * v28 - 8);\n*(_DWORD *)(v41 + 16) = *(_DWORD *)(a4 + 16) ^ *(_DWORD *)(a3 + 16);\nif ( v27 >= *(_DWORD *)(v41 + 12) ? sub_40C9FA(v41, v27 + 1) == 0 : v41 == 0 )\ngoto LABEL_57;\n*(_DWORD *)(v41 + 8) = v27;\nv40 = (_QWORD *)(*(_QWORD *)v41 + 8LL * v27 - 8);\nif ( v29 >= *(_DWORD *)(v33 + 12) ? sub_40C9FA(v33, v29 + 1) == 0 : v33 == 0 )\ngoto LABEL_57;\nif ( (int)sub_40D158((__int64)&v13, v31) >= 0 )\n{\nif ( (unsigned int)sub_40A626((__int64)&v13, (__int64)&v13, v31) )\n{\n*v40 = 1LL;\n*(_QWORD *)(*(_QWORD *)v41 + 8LL * *(int *)(v41 + 8) - 8) = 1LL;\ngoto LABEL_31;\n}\nLABEL_57:\nsub_40ABC8(a5);\nreturn 0LL;\n}\n--*(_DWORD *)(v41 + 8);\nLABEL_31:\n--v40;\nfor ( i = 0; i < v27 - 1; ++i )\n{\nv37 = 0LL;\nv24 = *v39;\nv23 = *(v39 - 1);\nif ( v24 == v26 )\n{\nv38 = -1LL;\n}\nelse\n{\nv38 = sub_40C2DF(v24, v23, v26);\nv37 = v23 - v26 * v38;\nv36 = (unsigned int)v25;\nv35 = HIDWORD(v25);\nv22 = (unsigned int)v38;\nv21 = HIDWORD(v38);\nv19 = (unsigned int)v25 * HIDWORD(v38);\nv20 = (unsigned int)v38 * (unsigned __int64)(unsigned int)v25;\nv18 = HIDWORD(v25) * (unsigned int)v38;\nv34 = HIDWORD(v38) * HIDWORD(v25);\nv19 += v18;\nif ( v19 < v18 )\nv34 += 0x100000000LL;\nv34 += HIDWORD(v19);\nv18 = v19 << 32;\nv20 += v19 << 32;\nif ( v20 < v19 << 32 )\n++v34;\nv36 = v20;\nv35 = v34;\nwhile ( v35 >= v37 && (v35 != v37 || v36 > *(v39 - 2)) )\n{\n--v38;\nv37 += v26;\nif ( v37 < v26 )\nbreak;\nif ( v36 < v25 )\n--v35;\nv36 -= v25;\n}\n}\nv17 = sub_40BB0A(*(_QWORD **)v33, *(_QWORD **)v31, v29, v38);\nv13 -= 8LL;\n++v14;\n*(_QWORD *)(8LL * v29 + *(_QWORD *)v33) = v17;\nfor ( j = v29 + 1; j > 0 && !*(_QWORD *)(*(_QWORD *)v33 + 8LL * j - 8); --j )\n;\n*(_DWORD *)(v33 + 8) = j;\nj = v14;\nsub_40A857((__int64)&v13, (__int64)&v13, v33);\n*(_DWORD *)(v32 + 8) = *(_DWORD *)(v32 + 8) + v14 - j;\nif ( v16 )\n{\n--v38;\nj = v14;\nsub_40A34C((__int64)&v13, (__int64)&v13, v31);\n*(_DWORD *)(v32 + 8) += v14 - j;\n}\nv9 = v40--;\n*v9 = v38;\n--v39;\n}\nif ( a2 )\n{\nsub_40E1BA(a2, v32, v30);\n*(_DWORD *)(a2 + 16) = *(_DWORD *)(a3 + 16);\n}\nsub_40ABC8(a5);\nreturn 1LL;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_DWORD *)(a2 + 16), (_DWORD *)(a3 + 16), (_QWORD **)a4, (_DWORD *)(a4 + 8), (_DWORD *)(a4 + 16), (_QWORD *)v31, (_DWORD *)(v31 + 8), (_DWORD *)(v31 + 16), (_QWORD *)v32, (_DWORD *)(v32 + 8), (_DWORD *)(v32 + 12), (_DWORD *)(v32 + 16), (_QWORD **)v33, (_DWORD *)(v33 + 8), (_DWORD *)(v33 + 12), (_DWORD *)(v33 + 16), (_QWORD *)v41, (_DWORD *)(v41 + 8), (_DWORD *)(v41 + 12), (_DWORD *)(v41 + 16)?\n", "output": "(_DWORD *)(a2 + 16): rm, BIGNUM* -> neg, int\n(_DWORD *)(a3 + 16): num, const BIGNUM* -> neg, int\n(_QWORD **)a4: divisor, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a4 + 8): divisor, const BIGNUM* -> top, int\n(_DWORD *)(a4 + 16): divisor, const BIGNUM* -> neg, int\n(_QWORD *)v31: sdiv, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v31 + 8): sdiv, BIGNUM* -> top, int\n(_DWORD *)(v31 + 16): sdiv, BIGNUM* -> neg, int\n(_QWORD *)v32: snum, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v32 + 8): snum, BIGNUM* -> top, int\n(_DWORD *)(v32 + 12): snum, BIGNUM* -> dmax, int\n(_DWORD *)(v32 + 16): snum, BIGNUM* -> neg, int\n(_QWORD **)v33: tmp, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v33 + 8): tmp, BIGNUM* -> top, int\n(_DWORD *)(v33 + 12): tmp, BIGNUM* -> dmax, int\n(_DWORD *)(v33 + 16): tmp, BIGNUM* -> neg, int\n(_QWORD *)v41: res, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v41 + 8): res, BIGNUM* -> top, int\n(_DWORD *)(v41 + 12): res, BIGNUM* -> dmax, int\n(_DWORD *)(v41 + 16): res, BIGNUM* -> neg, int", "predict": "(_DWORD *)(a2 + 16): rm, BIGNUM* -> neg, int\n(_DWORD *)(a3 + 16): num, const BIGNUM* -> neg, int\n(_QWORD **)a4: divisor, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a4 + 8): divisor, const BIGNUM* -> top, int\n(_DWORD *)(a4 + 16): divisor, const BIGNUM* -> neg, int\n(_QWORD *)v31: sdiv, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v31 + 8): sdiv, BIGNUM* -> top, int\n(_DWORD *)(v31 + 16): sdiv, BIGNUM* -> neg, int\n(_QWORD *)v32: snum, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v32 + 8): snum, BIGNUM* -> top, int\n(_DWORD *)(v32 + 12): snum, BIGNUM* -> dmax, int\n(_DWORD *)(v32 + 16): snum, BIGNUM* -> neg, int\n(_QWORD **)v33: tmp, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v33 + 8): tmp, BIGNUM* -> top, int\n(_DWORD *)(v33 + 12): tmp, BIGNUM* -> dmax, int\n(_DWORD *)(v33 + 16): tmp, BIGNUM* -> neg, int\n(_QWORD *)v41: res, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(v41 + 8): res, BIGNUM* -> top, int\n(_DWORD *)(v41 + 12): res, BIGNUM* -> dmax, int\n(_DWORD *)(v41 + 16): res, BIGNUM* -> neg, int", "funname": "BN_div", "ground_truth": [["(_DWORD *)(a2 + 16)", "rm", "BIGNUM*", "neg", "int"], ["(_DWORD *)(a3 + 16)", "num", "const BIGNUM*", "neg", "int"], ["(_QWORD **)a4", "divisor", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a4 + 8)", "divisor", "const BIGNUM*", "top", "int"], ["(_DWORD *)(a4 + 16)", "divisor", "const BIGNUM*", "neg", "int"], ["(_QWORD *)v31", "sdiv", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(v31 + 8)", "sdiv", "BIGNUM*", "top", "int"], ["(_DWORD *)(v31 + 16)", "sdiv", "BIGNUM*", "neg", "int"], ["(_QWORD *)v32", "snum", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(v32 + 8)", "snum", "BIGNUM*", "top", "int"], ["(_DWORD *)(v32 + 12)", "snum", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(v32 + 16)", "snum", "BIGNUM*", "neg", "int"], ["(_QWORD **)v33", "tmp", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(v33 + 8)", "tmp", "BIGNUM*", "top", "int"], ["(_DWORD *)(v33 + 12)", "tmp", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(v33 + 16)", "tmp", "BIGNUM*", "neg", "int"], ["(_QWORD *)v41", "res", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(v41 + 8)", "res", "BIGNUM*", "top", "int"], ["(_DWORD *)(v41 + 12)", "res", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(v41 + 16)", "res", "BIGNUM*", "neg", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D754"}
{"input": "```\n_DWORD *__fastcall sub_40CF0A(unsigned __int8 *a1, int a2, _DWORD *a3)\n{\n_DWORD *result; // rax\nint v4; // eax\nbool v5; // al\nunsigned __int8 *v6; // rax\n_QWORD *v8; // rax\n_DWORD *v9; // [rsp+8h] [rbp-38h]\n__int64 v11; // [rsp+20h] [rbp-20h]\n__int64 v12; // [rsp+28h] [rbp-18h]\nint v13; // [rsp+34h] [rbp-Ch]\nint v14; // [rsp+38h] [rbp-8h]\nunsigned int v15; // [rsp+3Ch] [rbp-4h]\n\nv9 = a3;\nif ( !a3 )\nv9 = sub_40C999();\nif ( !v9 )\nreturn 0LL;\nv12 = 0LL;\nv13 = a2;\nif ( a2 )\n{\nif ( (8 * (a2 + 10) - 1) / 64 <= v9[3] )\n{\nv5 = v9 == 0LL;\n}\nelse\n{\nv4 = a2 + 2;\nif ( a2 + 2 < 0 )\nv4 = a2 + 9;\nv5 = sub_40C9FA((__int64)v9, (v4 >> 3) + 1) == 0;\n}\nif ( v5 )\n{\nresult = 0LL;\n}\nelse\n{\nv15 = ((unsigned int)(a2 - 1) >> 3) + 1;\nv14 = ((_BYTE)a2 - 1) & 7;\nv9[2] = v15;\nwhile ( v13-- )\n{\nv6 = a1++;\nv12 = (v12 << 8) | *v6;\nLODWORD(v6) = v14--;\nif ( !(_DWORD)v6 )\n{\n*(_QWORD *)(8LL * --v15 + *(_QWORD *)v9) = v12;\nv12 = 0LL;\nv14 = 7;\n}\n}\nif ( (int)v9[2] > 0 )\n{\nv11 = *(_QWORD *)v9 + 8LL * (int)v9[2] - 8;\nwhile ( (int)v9[2] > 0 )\n{\nv8 = (_QWORD *)v11;\nv11 -= 8LL;\nif ( *v8 )\nbreak;\n--v9[2];\n}\n}\nresult = v9;\n}\n}\nelse\n{\nv9[2] = 0;\nresult = v9;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:v9, v9[2], v9[3]?\n", "output": "v9: ret, BIGNUM* -> d, long unsigned int*\nv9[2]: ret, BIGNUM* -> top, int\nv9[3]: ret, BIGNUM* -> dmax, int", "predict": "v9: ret, BIGNUM* -> d, long unsigned int*\nv9[2]: ret, BIGNUM* -> top, int\nv9[3]: ret, BIGNUM* -> dmax, int", "funname": "BN_bin2bn", "ground_truth": [["v9", "ret", "BIGNUM*", "d", "long unsigned int*"], ["v9[2]", "ret", "BIGNUM*", "top", "int"], ["v9[3]", "ret", "BIGNUM*", "dmax", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40CF0A"}
{"input": "```\n_BYTE *__fastcall sub_4054D5(_DWORD *a1, unsigned __int8 *a2, _BYTE *a3)\n{\nint v3; // ebx\nint v4; // ebx\nint v5; // ebx\nint v6; // ebx\nint v7; // ebx\nint v8; // ebx\nint v9; // ebx\nint v10; // ebx\nint v11; // ebx\nint v12; // ebx\nint v13; // ebx\nint v14; // ebx\nint v15; // ebx\nint v16; // ebx\nint v17; // ebx\nint v18; // ebx\nint v19; // ebx\nint v20; // ebx\nint v21; // ebx\nint v22; // ebx\nint v23; // ebx\nint v24; // ebx\nint v25; // ebx\nint v26; // ebx\n_BYTE *result; // rax\n_DWORD *v29; // [rsp+10h] [rbp-40h]\nunsigned int v30; // [rsp+20h] [rbp-30h]\nunsigned int v31; // [rsp+24h] [rbp-2Ch]\nunsigned int v32; // [rsp+28h] [rbp-28h]\nunsigned int v33; // [rsp+2Ch] [rbp-24h]\nint v34; // [rsp+34h] [rbp-1Ch]\nunsigned int v35; // [rsp+38h] [rbp-18h]\nint v36; // [rsp+38h] [rbp-18h]\nunsigned int v37; // [rsp+3Ch] [rbp-14h]\nint v38; // [rsp+3Ch] [rbp-14h]\nunsigned int v39; // [rsp+40h] [rbp-10h]\nint v40; // [rsp+40h] [rbp-10h]\nunsigned int v41; // [rsp+44h] [rbp-Ch]\nint v42; // [rsp+44h] [rbp-Ch]\n\nv29 = a1;\nv41 = a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24) ^ *a1;\nv39 = a2[7] ^ (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24) ^ a1[1];\nv37 = a2[11] ^ (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24) ^ a1[2];\nv35 = a2[15] ^ (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24) ^ a1[3];\nv34 = 5;\nwhile ( 1 )\n{\nv3 = dword_40F8C0[HIBYTE(v41)];\nv4 = sub_4046BB(dword_40F8C0[BYTE2(v35)], 8) ^ v3;\nv5 = sub_4046BB(dword_40F8C0[BYTE1(v37)], 16) ^ v4;\nv33 = sub_4046BB(dword_40F8C0[(unsigned __int8)v39], 24) ^ v5 ^ v29[4];\nv6 = dword_40F8C0[HIBYTE(v39)];\nv7 = sub_4046BB(dword_40F8C0[BYTE2(v41)], 8) ^ v6;\nv8 = sub_4046BB(dword_40F8C0[BYTE1(v35)], 16) ^ v7;\nv32 = sub_4046BB(dword_40F8C0[(unsigned __int8)v37], 24) ^ v8 ^ v29[5];\nv9 = dword_40F8C0[HIBYTE(v37)];\nv10 = sub_4046BB(dword_40F8C0[BYTE2(v39)], 8) ^ v9;\nv11 = sub_4046BB(dword_40F8C0[BYTE1(v41)], 16) ^ v10;\nv31 = sub_4046BB(dword_40F8C0[(unsigned __int8)v35], 24) ^ v11 ^ v29[6];\nv12 = dword_40F8C0[HIBYTE(v35)];\nv13 = sub_4046BB(dword_40F8C0[BYTE2(v37)], 8) ^ v12;\nv14 = sub_4046BB(dword_40F8C0[BYTE1(v39)], 16) ^ v13;\nv30 = sub_4046BB(dword_40F8C0[(unsigned __int8)v41], 24) ^ v14 ^ v29[7];\nv29 += 8;\nif ( !--v34 )\nbreak;\nv15 = dword_40F8C0[HIBYTE(v33)];\nv16 = sub_4046BB(dword_40F8C0[BYTE2(v30)], 8) ^ v15;\nv17 = sub_4046BB(dword_40F8C0[BYTE1(v31)], 16) ^ v16;\nv41 = sub_4046BB(dword_40F8C0[(unsigned __int8)v32], 24) ^ v17 ^ *v29;\nv18 = dword_40F8C0[HIBYTE(v32)];\nv19 = sub_4046BB(dword_40F8C0[BYTE2(v33)], 8) ^ v18;\nv20 = sub_4046BB(dword_40F8C0[BYTE1(v30)], 16) ^ v19;\nv39 = sub_4046BB(dword_40F8C0[(unsigned __int8)v31], 24) ^ v20 ^ v29[1];\nv21 = dword_40F8C0[HIBYTE(v31)];\nv22 = sub_4046BB(dword_40F8C0[BYTE2(v32)], 8) ^ v21;\nv23 = sub_4046BB(dword_40F8C0[BYTE1(v33)], 16) ^ v22;\nv37 = sub_4046BB(dword_40F8C0[(unsigned __int8)v30], 24) ^ v23 ^ v29[2];\nv24 = dword_40F8C0[HIBYTE(v30)];\nv25 = sub_4046BB(dword_40F8C0[BYTE2(v31)], 8) ^ v24;\nv26 = sub_4046BB(dword_40F8C0[BYTE1(v32)], 16) ^ v25;\nv35 = sub_4046BB(dword_40F8C0[(unsigned __int8)v33], 24) ^ v26 ^ v29[3];\n}\nv42 = ((unsigned __int8)byte_40FCC0[BYTE1(v31)] << 8) ^ ((unsigned __int8)byte_40FCC0[BYTE2(v30)] << 16) ^ ((unsigned __int8)byte_40FCC0[HIBYTE(v33)] << 24) ^ (unsigned __int8)byte_40FCC0[(unsigned __int8)v32] ^ *v29;\n*a3 = HIBYTE(v42);\na3[1] = BYTE2(v42);\na3[2] = BYTE1(v42);\na3[3] = v42;\nv40 = ((unsigned __int8)byte_40FCC0[BYTE1(v30)] << 8) ^ ((unsigned __int8)byte_40FCC0[BYTE2(v33)] << 16) ^ ((unsigned __int8)byte_40FCC0[HIBYTE(v32)] << 24) ^ (unsigned __int8)byte_40FCC0[(unsigned __int8)v31] ^ v29[1];\na3[4] = HIBYTE(v40);\na3[5] = BYTE2(v40);\na3[6] = BYTE1(v40);\na3[7] = v40;\nv38 = ((unsigned __int8)byte_40FCC0[BYTE1(v33)] << 8) ^ ((unsigned __int8)byte_40FCC0[BYTE2(v32)] << 16) ^ ((unsigned __int8)byte_40FCC0[HIBYTE(v31)] << 24) ^ (unsigned __int8)byte_40FCC0[(unsigned __int8)v30] ^ v29[2];\na3[8] = HIBYTE(v38);\na3[9] = BYTE2(v38);\na3[10] = BYTE1(v38);\na3[11] = v38;\nv36 = ((unsigned __int8)byte_40FCC0[BYTE1(v32)] << 8) ^ ((unsigned __int8)byte_40FCC0[BYTE2(v31)] << 16) ^ ((unsigned __int8)byte_40FCC0[HIBYTE(v30)] << 24) ^ (unsigned __int8)byte_40FCC0[(unsigned __int8)v33] ^ v29[3];\na3[12] = HIBYTE(v36);\na3[13] = BYTE2(v36);\na3[14] = BYTE1(v36);\nresult = a3 + 15;\na3[15] = v36;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1[3], a2, a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8], a2[9], a2[10], a2[11], a2[12], a2[13], a2[14], a2[15], a3, a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8], a3[9], a3[10], a3[11], a3[12], a3[13], a3[14], a3 + 15?\n", "output": "a1: rk, const u32* -> -, const u32\na1[1]: rk, const u32* -> -, const u32\na1[2]: rk, const u32* -> -, const u32\na1[3]: rk, const u32* -> -, const u32\na2: ct, const u8* -> -, const u8\na2[1]: ct, const u8* -> -, const u8\na2[2]: ct, const u8* -> -, const u8\na2[3]: ct, const u8* -> -, const u8\na2[4]: ct, const u8* -> -, const u8\na2[5]: ct, const u8* -> -, const u8\na2[6]: ct, const u8* -> -, const u8\na2[7]: ct, const u8* -> -, const u8\na2[8]: ct, const u8* -> -, const u8\na2[9]: ct, const u8* -> -, const u8\na2[10]: ct, const u8* -> -, const u8\na2[11]: ct, const u8* -> -, const u8\na2[12]: ct, const u8* -> -, const u8\na2[13]: ct, const u8* -> -, const u8\na2[14]: ct, const u8* -> -, const u8\na2[15]: ct, const u8* -> -, const u8\na3: pt, u8* -> -, u8\na3[1]: pt, u8* -> -, u8\na3[2]: pt, u8* -> -, u8\na3[3]: pt, u8* -> -, u8\na3[4]: pt, u8* -> -, u8\na3[5]: pt, u8* -> -, u8\na3[6]: pt, u8* -> -, u8\na3[7]: pt, u8* -> -, u8\na3[8]: pt, u8* -> -, u8\na3[9]: pt, u8* -> -, u8\na3[10]: pt, u8* -> -, u8\na3[11]: pt, u8* -> -, u8\na3[12]: pt, u8* -> -, u8\na3[13]: pt, u8* -> -, u8\na3[14]: pt, u8* -> -, u8\na3 + 15: pt, u8* -> -, u8", "predict": "a1: rk, const u32* -> -, const u32\na1[1]: rk, const u32* -> -, const u32\na1[2]: rk, const u32* -> -, const u32\na1[3]: rk, const u32* -> -, const u32\na2: ct, const u8* -> -, const u8\na2[1]: ct, const u8* -> -, const u8\na2[2]: ct, const u8* -> -, const u8\na2[3]: ct, const u8* -> -, const u8\na2[4]: ct, const u8* -> -, const u8\na2[5]: ct, const u8* -> -, const u8\na2[6]: ct, const u8* -> -, const u8\na2[7]: ct, const u8* -> -, const u8\na2[8]: ct, const u8* -> -, const u8\na2[9]: ct, const u8* -> -, const u8\na2[10]: ct, const u8* -> -, const u8\na2[11]: ct, const u8* -> -, const u8\na2[12]: ct, const u8* -> -, const u8\na2[13]: ct, const u8* -> -, const u8\na2[14]: ct, const u8* -> -, const u8\na2[15]: ct, const u8* -> -, const u8\na3: pt, u8* -> -, u8\na3[1]: pt, u8* -> -, u8\na3[2]: pt, u8* -> -, u8\na3[3]: pt, u8* -> -, u8\na3[4]: pt, u8* -> -, u8\na3[5]: pt, u8* -> -, u8\na3[6]: pt, u8* -> -, u8\na3[7]: pt, u8* -> -, u8\na3[8]: pt, u8* -> -, u8\na3[9]: pt, u8* -> -, u8\na3[10]: pt, u8* -> -, u8\na3[11]: pt, u8* -> -, u8\na3[12]: pt, u8* -> -, u8\na3[13]: pt, u8* -> -, u8\na3[14]: pt, u8* -> -, u8\na3 + 15: pt, u8* -> -, u8", "funname": "rijndaelDecrypt", "ground_truth": [["a1", "rk", "const u32*", "-", "const u32"], ["a1[1]", "rk", "const u32*", "-", "const u32"], ["a1[2]", "rk", "const u32*", "-", "const u32"], ["a1[3]", "rk", "const u32*", "-", "const u32"], ["a2", "ct", "const u8*", "-", "const u8"], ["a2[1]", "ct", "const u8*", "-", "const u8"], ["a2[2]", "ct", "const u8*", "-", "const u8"], ["a2[3]", "ct", "const u8*", "-", "const u8"], ["a2[4]", "ct", "const u8*", "-", "const u8"], ["a2[5]", "ct", "const u8*", "-", "const u8"], ["a2[6]", "ct", "const u8*", "-", "const u8"], ["a2[7]", "ct", "const u8*", "-", "const u8"], ["a2[8]", "ct", "const u8*", "-", "const u8"], ["a2[9]", "ct", "const u8*", "-", "const u8"], ["a2[10]", "ct", "const u8*", "-", "const u8"], ["a2[11]", "ct", "const u8*", "-", "const u8"], ["a2[12]", "ct", "const u8*", "-", "const u8"], ["a2[13]", "ct", "const u8*", "-", "const u8"], ["a2[14]", "ct", "const u8*", "-", "const u8"], ["a2[15]", "ct", "const u8*", "-", "const u8"], ["a3", "pt", "u8*", "-", "u8"], ["a3[1]", "pt", "u8*", "-", "u8"], ["a3[2]", "pt", "u8*", "-", "u8"], ["a3[3]", "pt", "u8*", "-", "u8"], ["a3[4]", "pt", "u8*", "-", "u8"], ["a3[5]", "pt", "u8*", "-", "u8"], ["a3[6]", "pt", "u8*", "-", "u8"], ["a3[7]", "pt", "u8*", "-", "u8"], ["a3[8]", "pt", "u8*", "-", "u8"], ["a3[9]", "pt", "u8*", "-", "u8"], ["a3[10]", "pt", "u8*", "-", "u8"], ["a3[11]", "pt", "u8*", "-", "u8"], ["a3[12]", "pt", "u8*", "-", "u8"], ["a3[13]", "pt", "u8*", "-", "u8"], ["a3[14]", "pt", "u8*", "-", "u8"], ["a3 + 15", "pt", "u8*", "-", "u8"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4054D5"}
{"input": "```\nunsigned __int64 __fastcall sub_40BB0A(_QWORD *a1, _QWORD *a2, int a3, unsigned __int64 a4)\n{\nint v5; // [rsp+Ch] [rbp-F4h]\nint v6; // [rsp+Ch] [rbp-F4h]\nint v7; // [rsp+Ch] [rbp-F4h]\nint v8; // [rsp+Ch] [rbp-F4h]\nunsigned __int64 v11; // [rsp+30h] [rbp-D0h]\nunsigned __int64 v12; // [rsp+38h] [rbp-C8h]\n__int64 v13; // [rsp+40h] [rbp-C0h]\nunsigned __int64 v14; // [rsp+50h] [rbp-B0h]\nunsigned __int64 v15; // [rsp+58h] [rbp-A8h]\n__int64 v16; // [rsp+60h] [rbp-A0h]\nunsigned __int64 v17; // [rsp+70h] [rbp-90h]\nunsigned __int64 v18; // [rsp+78h] [rbp-88h]\n__int64 v19; // [rsp+80h] [rbp-80h]\nunsigned __int64 v20; // [rsp+90h] [rbp-70h]\nunsigned __int64 v21; // [rsp+98h] [rbp-68h]\n__int64 v22; // [rsp+A0h] [rbp-60h]\n__int64 v23; // [rsp+A0h] [rbp-60h]\nunsigned __int64 v24; // [rsp+A8h] [rbp-58h]\n__int64 v25; // [rsp+B8h] [rbp-48h]\nunsigned __int64 v26; // [rsp+B8h] [rbp-48h]\nunsigned __int64 v27; // [rsp+C0h] [rbp-40h]\nunsigned __int64 v28; // [rsp+C0h] [rbp-40h]\n__int64 v29; // [rsp+C8h] [rbp-38h]\nunsigned __int64 v30; // [rsp+C8h] [rbp-38h]\nunsigned __int64 v31; // [rsp+D0h] [rbp-30h]\nunsigned __int64 v32; // [rsp+D0h] [rbp-30h]\n__int64 v33; // [rsp+D8h] [rbp-28h]\nunsigned __int64 v34; // [rsp+D8h] [rbp-28h]\nunsigned __int64 v35; // [rsp+E0h] [rbp-20h]\nunsigned __int64 v36; // [rsp+E0h] [rbp-20h]\n__int64 v37; // [rsp+E8h] [rbp-18h]\nunsigned __int64 v38; // [rsp+E8h] [rbp-18h]\n__int64 v39; // [rsp+F0h] [rbp-10h]\nunsigned __int64 v40; // [rsp+F0h] [rbp-10h]\nunsigned __int64 v41; // [rsp+F8h] [rbp-8h]\n\nv5 = a3;\nv41 = 0LL;\nif ( a3 <= 0 )\nreturn 0LL;\nv24 = HIDWORD(a4);\nwhile ( 1 )\n{\nv22 = (unsigned int)*a2;\nv39 = HIDWORD(*a2);\nv37 = v24 * v39;\nv20 = v39 * (unsigned int)a4 + v22 * v24;\nif ( v20 < v39 * (unsigned __int64)(unsigned int)a4 )\nv37 += 0x100000000LL;\nv38 = HIDWORD(v20) + v37;\nv21 = (v20 << 32) + (unsigned int)a4 * v22;\nif ( v21 < v20 << 32 )\n++v38;\nv40 = v38;\nv23 = v41 + v21;\nif ( v41 + v21 < v41 )\nv40 = v38 + 1;\nv41 = v40;\n*a1 = v23;\nv6 = v5 - 1;\nif ( !v6 )\nbreak;\nv35 = a2[1];\nv19 = (unsigned int)v35;\nv35 >>= 32;\nv33 = v24 * v35;\nv17 = v35 * (unsigned int)a4 + v19 * v24;\nif ( v17 < v35 * (unsigned int)a4 )\nv33 += 0x100000000LL;\nv34 = HIDWORD(v17) + v33;\nv18 = (v17 << 32) + (unsigned int)a4 * v19;\nif ( v18 < v17 << 32 )\n++v34;\nv36 = v34;\nif ( v40 + v18 < v40 )\nv36 = v34 + 1;\nv41 = v36;\na1[1] = v40 + v18;\nv7 = v6 - 1;\nif ( !v7 )\nbreak;\nv31 = a2[2];\nv16 = (unsigned int)v31;\nv31 >>= 32;\nv29 = v24 * v31;\nv14 = v31 * (unsigned int)a4 + v16 * v24;\nif ( v14 < v31 * (unsigned int)a4 )\nv29 += 0x100000000LL;\nv30 = HIDWORD(v14) + v29;\nv15 = (v14 << 32) + (unsigned int)a4 * v16;\nif ( v15 < v14 << 32 )\n++v30;\nv32 = v30;\nif ( v36 + v15 < v36 )\nv32 = v30 + 1;\nv41 = v32;\na1[2] = v36 + v15;\nv8 = v7 - 1;\nif ( !v8 )\nbreak;\nv27 = a2[3];\nv13 = (unsigned int)v27;\nv27 >>= 32;\nv25 = v24 * v27;\nv11 = v27 * (unsigned int)a4 + v13 * v24;\nif ( v11 < v27 * (unsigned int)a4 )\nv25 += 0x100000000LL;\nv26 = HIDWORD(v11) + v25;\nv12 = (v11 << 32) + (unsigned int)a4 * v13;\nif ( v12 < v11 << 32 )\n++v26;\nv28 = v26;\nif ( v32 + v12 < v32 )\nv28 = v26 + 1;\nv41 = v28;\na1[3] = v32 + v12;\nv5 = v8 - 1;\nif ( !v5 )\nbreak;\na2 += 4;\na1 += 4;\n}\nreturn v41;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1[3], a2, a2[1], a2[2], a2[3]?\n", "output": "a1: rp, long unsigned int* -> -, long unsigned int\na1[1]: rp, long unsigned int* -> -, long unsigned int\na1[2]: rp, long unsigned int* -> -, long unsigned int\na1[3]: rp, long unsigned int* -> -, long unsigned int\na2: ap, long unsigned int* -> -, long unsigned int\na2[1]: ap, long unsigned int* -> -, long unsigned int\na2[2]: ap, long unsigned int* -> -, long unsigned int\na2[3]: ap, long unsigned int* -> -, long unsigned int", "predict": "a1: rp, long unsigned int* -> -, long unsigned int\na1[1]: rp, long unsigned int* -> -, long unsigned int\na1[2]: rp, long unsigned int* -> -, long unsigned int\na1[3]: rp, long unsigned int* -> -, long unsigned int\na2: ap, long unsigned int* -> -, long unsigned int\na2[1]: ap, long unsigned int* -> -, long unsigned int\na2[2]: ap, long unsigned int* -> -, long unsigned int\na2[3]: ap, long unsigned int* -> -, long unsigned int", "funname": "bn_mul_words", "ground_truth": [["a1", "rp", "long unsigned int*", "-", "long unsigned int"], ["a1[1]", "rp", "long unsigned int*", "-", "long unsigned int"], ["a1[2]", "rp", "long unsigned int*", "-", "long unsigned int"], ["a1[3]", "rp", "long unsigned int*", "-", "long unsigned int"], ["a2", "ap", "long unsigned int*", "-", "long unsigned int"], ["a2[1]", "ap", "long unsigned int*", "-", "long unsigned int"], ["a2[2]", "ap", "long unsigned int*", "-", "long unsigned int"], ["a2[3]", "ap", "long unsigned int*", "-", "long unsigned int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40BB0A"}
{"input": "```\n__int64 __fastcall sub_402FFB(__int64 a1, __int64 a2, _DWORD *a3)\n{\n__int64 v3; // rdx\n__int64 v4; // rdx\nchar *v7; // [rsp+20h] [rbp-10h]\nchar *v8; // [rsp+28h] [rbp-8h]\n\nv8 = (char *)off_4132D8 + 42;\nv7 = (char *)off_4132D8 + 62;\n*((_DWORD *)v8 + 1) = htonl(0x42u);\n*v7 = *(_DWORD *)qword_413F20 - 1;\nv7[1] = *(_DWORD *)(qword_414840 + 56);\nmemmove(v7 + 2, *(const void **)(qword_414840 + 64), *(int *)(qword_414840 + 56));\nv3 = qword_414808;\n*(_QWORD *)(v7 + 34) = *(_QWORD *)dest;\n*(_QWORD *)(v7 + 42) = v3;\nv4 = qword_414818;\n*(_QWORD *)(v7 + 50) = qword_414810;\n*(_QWORD *)(v7 + 58) = v4;\n*a3 = 6;\nreturn 1LL;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_DWORD *)v8 + 1?\n", "output": "(_DWORD *)v8 + 1: msg, ead_msg* -> len, uint32_t", "predict": "(_DWORD *)v8 + 1: msg, ead_msg* -> len, uint32_t", "funname": "handle_get_prime", "ground_truth": [["(_DWORD *)v8 + 1", "msg", "ead_msg*", "len", "uint32_t"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "402FFB"}
{"input": "```\n__int64 __fastcall sub_40C9FA(__int64 a1, int a2)\n{\nint v3; // eax\n__int64 v4; // [rsp+10h] [rbp-40h]\n__int64 v5; // [rsp+18h] [rbp-38h]\n__int64 v6; // [rsp+20h] [rbp-30h]\n_QWORD *v7; // [rsp+30h] [rbp-20h]\nint i; // [rsp+3Ch] [rbp-14h]\nint j; // [rsp+3Ch] [rbp-14h]\nint k; // [rsp+3Ch] [rbp-14h]\n_QWORD *v11; // [rsp+40h] [rbp-10h]\n_QWORD *v12; // [rsp+48h] [rbp-8h]\n_QWORD *v13; // [rsp+48h] [rbp-8h]\n\nif ( a2 <= *(_DWORD *)(a1 + 12) )\nreturn a1;\nif ( (*(_DWORD *)(a1 + 20) & 2) != 0 )\nreturn 0LL;\nv12 = malloc(8LL * (a2 + 1));\nv7 = v12;\nif ( !v12 )\nreturn 0LL;\nv11 = *(_QWORD **)a1;\nif ( *(_QWORD *)a1 )\n{\nfor ( i = *(int *)(a1 + 8) >> 2; i > 0; --i )\n{\nv6 = v11[1];\nv5 = v11[2];\nv4 = v11[3];\n*v12 = *v11;\nv12[1] = v6;\nv12[2] = v5;\nv12[3] = v4;\nv12 += 4;\nv11 += 4;\n}\nv3 = *(_DWORD *)(a1 + 8) & 3;\nswitch ( v3 )\n{\ncase 3:\nv12[2] = v11[2];\nbreak;\ncase 1:\nLABEL_16:\n*v12 = *v11;\nLABEL_17:\nfree(*(void **)a1);\ngoto LABEL_18;\ncase 2:\nbreak;\ndefault:\ngoto LABEL_17;\n}\nv12[1] = v11[1];\ngoto LABEL_16;\n}\nLABEL_18:\n*(_QWORD *)a1 = v7;\n*(_DWORD *)(a1 + 12) = a2;\nv13 = (_QWORD *)(*(_QWORD *)a1 + 8LL * *(int *)(a1 + 8));\nfor ( j = (*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 8)) >> 3; j > 0; --j )\n{\n*v13 = 0LL;\nv13[1] = 0LL;\nv13[2] = 0LL;\nv13[3] = 0LL;\nv13[4] = 0LL;\nv13[5] = 0LL;\nv13[6] = 0LL;\nv13[7] = 0LL;\nv13 += 8;\n}\nfor ( k = ((unsigned __int8)*(_DWORD *)(a1 + 12) - (unsigned __int8)*(_DWORD *)(a1 + 8)) & 7; k > 0; --k )\n*v13++ = 0LL;\nreturn a1;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD **)a1, (int *)(a1 + 8), (_DWORD *)(a1 + 12), (_DWORD *)(a1 + 20), v11, v11[1], v11[2], v11[3], v13, v13[1], v13[2], v13[3], v13[4], v13[5], v13[6], v13[7]?\n", "output": "(_QWORD **)a1: b, BIGNUM* -> d, long unsigned int*\n(int *)(a1 + 8): b, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): b, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 20): b, BIGNUM* -> flags, int\nv11: B, const long unsigned int* -> -, const long unsigned int\nv11[1]: B, const long unsigned int* -> -, const long unsigned int\nv11[2]: B, const long unsigned int* -> -, const long unsigned int\nv11[3]: B, const long unsigned int* -> -, const long unsigned int\nv13: A, long unsigned int* -> -, long unsigned int\nv13[1]: A, long unsigned int* -> -, long unsigned int\nv13[2]: A, long unsigned int* -> -, long unsigned int\nv13[3]: A, long unsigned int* -> -, long unsigned int\nv13[4]: A, long unsigned int* -> -, long unsigned int\nv13[5]: A, long unsigned int* -> -, long unsigned int\nv13[6]: A, long unsigned int* -> -, long unsigned int\nv13[7]: A, long unsigned int* -> -, long unsigned int", "predict": "(_QWORD **)a1: b, BIGNUM* -> d, long unsigned int*\n(int *)(a1 + 8): b, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): b, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 20): b, BIGNUM* -> flags, int\nv11: B, const long unsigned int* -> -, const long unsigned int\nv11[1]: B, const long unsigned int* -> -, const long unsigned int\nv11[2]: B, const long unsigned int* -> -, const long unsigned int\nv11[3]: B, const long unsigned int* -> -, const long unsigned int\nv13: A, long unsigned int* -> -, long unsigned int\nv13[1]: A, long unsigned int* -> -, long unsigned int\nv13[2]: A, long unsigned int* -> -, long unsigned int\nv13[3]: A, long unsigned int* -> -, long unsigned int\nv13[4]: A, long unsigned int* -> -, long unsigned int\nv13[5]: A, long unsigned int* -> -, long unsigned int\nv13[6]: A, long unsigned int* -> -, long unsigned int\nv13[7]: A, long unsigned int* -> -, long unsigned int", "funname": "bn_expand2", "ground_truth": [["(_QWORD **)a1", "b", "BIGNUM*", "d", "long unsigned int*"], ["(int *)(a1 + 8)", "b", "BIGNUM*", "top", "int"], ["(_DWORD *)(a1 + 12)", "b", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(a1 + 20)", "b", "BIGNUM*", "flags", "int"], ["v11", "B", "const long unsigned int*", "-", "const long unsigned int"], ["v11[1]", "B", "const long unsigned int*", "-", "const long unsigned int"], ["v11[2]", "B", "const long unsigned int*", "-", "const long unsigned int"], ["v11[3]", "B", "const long unsigned int*", "-", "const long unsigned int"], ["v13", "A", "long unsigned int*", "-", "long unsigned int"], ["v13[1]", "A", "long unsigned int*", "-", "long unsigned int"], ["v13[2]", "A", "long unsigned int*", "-", "long unsigned int"], ["v13[3]", "A", "long unsigned int*", "-", "long unsigned int"], ["v13[4]", "A", "long unsigned int*", "-", "long unsigned int"], ["v13[5]", "A", "long unsigned int*", "-", "long unsigned int"], ["v13[6]", "A", "long unsigned int*", "-", "long unsigned int"], ["v13[7]", "A", "long unsigned int*", "-", "long unsigned int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C9FA"}
{"input": "```\n__int64 __fastcall sub_40A462(__int64 *a1, __int64 *a2, __int64 *a3)\n{\nbool v3; // al\nint v5; // ebx\nunsigned __int64 *v6; // rax\nunsigned __int64 *v7; // rax\nunsigned __int64 *v8; // rax\nunsigned __int64 *v9; // rdx\nunsigned __int64 *v10; // rax\n__int64 *v11; // [rsp+8h] [rbp-68h]\n__int64 *v12; // [rsp+10h] [rbp-60h]\nunsigned __int64 v13; // [rsp+28h] [rbp-48h]\nunsigned int v14; // [rsp+38h] [rbp-38h]\nint v15; // [rsp+3Ch] [rbp-34h]\n__int64 v16; // [rsp+48h] [rbp-28h]\n__int64 v17; // [rsp+50h] [rbp-20h]\nunsigned __int64 *v18; // [rsp+50h] [rbp-20h]\n__int64 v19; // [rsp+58h] [rbp-18h]\nunsigned __int64 *v20; // [rsp+58h] [rbp-18h]\n\nv12 = a2;\nv11 = a3;\nif ( *((_DWORD *)a2 + 2) < *((_DWORD *)a3 + 2) )\n{\nv12 = a3;\nv11 = a2;\n}\nv15 = *((_DWORD *)v12 + 2);\nv14 = *((_DWORD *)v11 + 2);\nif ( v15 < *((_DWORD *)a1 + 3) )\nv3 = a1 == 0LL;\nelse\nv3 = sub_40C9FA(a1, (unsigned int)(v15 + 1)) == 0;\nif ( v3 )\nreturn 0LL;\n*((_DWORD *)a1 + 2) = v15;\nv19 = *v12;\nv17 = *a1;\nv16 = sub_40C4C7(*a1, *v12, *v11, v14);\nv18 = (unsigned __int64 *)(8LL * (int)v14 + v17);\nv20 = (unsigned __int64 *)(8LL * (int)v14 + v19);\nv5 = v14;\nif ( v16 )\n{\nwhile ( v5 < v15 )\n{\n++v5;\nv6 = v20++;\nv13 = *v6;\nv7 = v18++;\n*v7 = v13 + 1;\nif ( v13 <= *v7 )\n{\nv16 = 0LL;\nbreak;\n}\n}\nif ( v5 >= v15 && v16 )\n{\nv8 = v18++;\n*v8 = 1LL;\n++*((_DWORD *)a1 + 2);\n}\n}\nif ( v18 != v20 )\n{\nwhile ( v5 < v15 )\n{\nv9 = v20++;\nv10 = v18++;\n*v10 = *v9;\n++v5;\n}\n}\nreturn 1LL;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, (_DWORD *)a1 + 2, (_DWORD *)a1 + 3, a2, (_DWORD *)a2 + 2, a3, (_DWORD *)a3 + 2, v11, (_DWORD *)v11 + 2, v12, (_DWORD *)v12 + 2?\n", "output": "a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)a1 + 2: r, BIGNUM* -> top, int\n(_DWORD *)a1 + 3: r, BIGNUM* -> dmax, int\na2: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)a2 + 2: a, const BIGNUM* -> top, int\na3: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)a3 + 2: b, const BIGNUM* -> top, int\nv11: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)v11 + 2: b, const BIGNUM* -> top, int\nv12: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)v12 + 2: a, const BIGNUM* -> top, int", "predict": "a1: r, BIGNUM* -> d, long unsigned int*\n(_DWORD *)a1 + 2: r, BIGNUM* -> top, int\n(_DWORD *)a1 + 3: r, BIGNUM* -> dmax, int\na2: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)a2 + 2: a, const BIGNUM* -> top, int\na3: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)a3 + 2: b, const BIGNUM* -> top, int\nv11: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)v11 + 2: b, const BIGNUM* -> top, int\nv12: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)v12 + 2: a, const BIGNUM* -> top, int", "funname": "BN_uadd", "ground_truth": [["a1", "r", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)a1 + 2", "r", "BIGNUM*", "top", "int"], ["(_DWORD *)a1 + 3", "r", "BIGNUM*", "dmax", "int"], ["a2", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)a2 + 2", "a", "const BIGNUM*", "top", "int"], ["a3", "b", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)a3 + 2", "b", "const BIGNUM*", "top", "int"], ["v11", "b", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)v11 + 2", "b", "const BIGNUM*", "top", "int"], ["v12", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)v12 + 2", "a", "const BIGNUM*", "top", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A462"}
{"input": "```\nunsigned __int64 __fastcall sub_40C4C7(unsigned __int64 *a1, _QWORD *a2, _QWORD *a3, int a4)\n{\nint v5; // [rsp+0h] [rbp-3Ch]\nint v6; // [rsp+0h] [rbp-3Ch]\nint v7; // [rsp+0h] [rbp-3Ch]\nint v8; // [rsp+0h] [rbp-3Ch]\nunsigned __int64 v12; // [rsp+24h] [rbp-18h]\nunsigned __int64 v13; // [rsp+24h] [rbp-18h]\nunsigned __int64 v14; // [rsp+24h] [rbp-18h]\nunsigned __int64 v15; // [rsp+24h] [rbp-18h]\nunsigned __int64 v16; // [rsp+2Ch] [rbp-10h]\nunsigned __int64 v17; // [rsp+2Ch] [rbp-10h]\nunsigned __int64 v18; // [rsp+2Ch] [rbp-10h]\nunsigned __int64 v19; // [rsp+2Ch] [rbp-10h]\nunsigned __int64 v20; // [rsp+34h] [rbp-8h]\n\nv5 = a4;\nif ( a4 <= 0 )\nreturn 0LL;\nv20 = 0LL;\nwhile ( 1 )\n{\nv16 = v20 + *a2;\nv12 = *a3 + v16;\nv20 = (v12 < v16) + (unsigned __int64)(v16 < v20);\n*a1 = v12;\nv6 = v5 - 1;\nif ( v6 <= 0 )\nbreak;\nv17 = v20 + a2[1];\nv13 = a3[1] + v17;\nv20 = (v13 < v17) + (unsigned __int64)(v17 < v20);\na1[1] = v13;\nv7 = v6 - 1;\nif ( v7 <= 0 )\nbreak;\nv18 = v20 + a2[2];\nv14 = a3[2] + v18;\nv20 = (v14 < v18) + (unsigned __int64)(v18 < v20);\na1[2] = v14;\nv8 = v7 - 1;\nif ( v8 <= 0 )\nbreak;\nv19 = v20 + a2[3];\nv15 = a3[3] + v19;\nv20 = (v15 < v19) + (unsigned __int64)(v19 < v20);\na1[3] = v15;\nv5 = v8 - 1;\nif ( v5 <= 0 )\nbreak;\na2 += 4;\na3 += 4;\na1 += 4;\n}\nreturn v20;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1[3], a2, a2[1], a2[2], a2[3], a3, a3[1], a3[2], a3[3]?\n", "output": "a1: r, long unsigned int* -> -, long unsigned int\na1[1]: r, long unsigned int* -> -, long unsigned int\na1[2]: r, long unsigned int* -> -, long unsigned int\na1[3]: r, long unsigned int* -> -, long unsigned int\na2: a, long unsigned int* -> -, long unsigned int\na2[1]: a, long unsigned int* -> -, long unsigned int\na2[2]: a, long unsigned int* -> -, long unsigned int\na2[3]: a, long unsigned int* -> -, long unsigned int\na3: b, long unsigned int* -> -, long unsigned int\na3[1]: b, long unsigned int* -> -, long unsigned int\na3[2]: b, long unsigned int* -> -, long unsigned int\na3[3]: b, long unsigned int* -> -, long unsigned int", "predict": "a1: r, long unsigned int* -> -, long unsigned int\na1[1]: r, long unsigned int* -> -, long unsigned int\na1[2]: r, long unsigned int* -> -, long unsigned int\na1[3]: r, long unsigned int* -> -, long unsigned int\na2: a, long unsigned int* -> -, long unsigned int\na2[1]: a, long unsigned int* -> -, long unsigned int\na2[2]: a, long unsigned int* -> -, long unsigned int\na2[3]: a, long unsigned int* -> -, long unsigned int\na3: b, long unsigned int* -> -, long unsigned int\na3[1]: b, long unsigned int* -> -, long unsigned int\na3[2]: b, long unsigned int* -> -, long unsigned int\na3[3]: b, long unsigned int* -> -, long unsigned int", "funname": "bn_add_words", "ground_truth": [["a1", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[1]", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[2]", "r", "long unsigned int*", "-", "long unsigned int"], ["a1[3]", "r", "long unsigned int*", "-", "long unsigned int"], ["a2", "a", "long unsigned int*", "-", "long unsigned int"], ["a2[1]", "a", "long unsigned int*", "-", "long unsigned int"], ["a2[2]", "a", "long unsigned int*", "-", "long unsigned int"], ["a2[3]", "a", "long unsigned int*", "-", "long unsigned int"], ["a3", "b", "long unsigned int*", "-", "long unsigned int"], ["a3[1]", "b", "long unsigned int*", "-", "long unsigned int"], ["a3[2]", "b", "long unsigned int*", "-", "long unsigned int"], ["a3[3]", "b", "long unsigned int*", "-", "long unsigned int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C4C7"}
{"input": "```\n_BOOL8 __fastcall sub_40A34C(__int64 a1, __int64 a2, __int64 a3)\n{\n_BOOL8 result; // rax\n__int64 v4; // [rsp+8h] [rbp-28h]\n__int64 v5; // [rsp+10h] [rbp-20h]\n\nv5 = a2;\nv4 = a3;\nif ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a3 + 16) )\n{\nif ( *(_DWORD *)(a2 + 16) )\n*(_DWORD *)(a1 + 16) = 1;\nelse\n*(_DWORD *)(a1 + 16) = 0;\nresult = (unsigned int)sub_40A462(a1, a2, a3) != 0;\n}\nelse\n{\nif ( *(_DWORD *)(a2 + 16) )\n{\nv5 = a3;\nv4 = a2;\n}\nif ( (int)sub_40D158(v5, v4) >= 0 )\n{\nif ( !(unsigned int)sub_40A626(a1, v5, v4) )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 0;\n}\nelse\n{\nif ( !(unsigned int)sub_40A626(a1, v4, v5) )\nreturn 0LL;\n*(_DWORD *)(a1 + 16) = 1;\n}\nresult = 1LL;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_DWORD *)(a1 + 16), (_DWORD *)(a2 + 16), (_DWORD *)(a3 + 16)?\n", "output": "(_DWORD *)(a1 + 16): r, BIGNUM* -> neg, int\n(_DWORD *)(a2 + 16): a, const BIGNUM* -> neg, int\n(_DWORD *)(a3 + 16): b, const BIGNUM* -> neg, int", "predict": "(_DWORD *)(a1 + 16): r, BIGNUM* -> neg, int\n(_DWORD *)(a2 + 16): a, const BIGNUM* -> neg, int\n(_DWORD *)(a3 + 16): b, const BIGNUM* -> neg, int", "funname": "BN_add", "ground_truth": [["(_DWORD *)(a1 + 16)", "r", "BIGNUM*", "neg", "int"], ["(_DWORD *)(a2 + 16)", "a", "const BIGNUM*", "neg", "int"], ["(_DWORD *)(a3 + 16)", "b", "const BIGNUM*", "neg", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40A34C"}
{"input": "```\nvoid *__fastcall sub_408919(int *a1, char *a2, unsigned int a3)\n{\nunsigned int v5; // [rsp+28h] [rbp-8h]\nunsigned int n; // [rsp+2Ch] [rbp-4h]\n\nv5 = ((unsigned int)a1[5] >> 3) & 0x3F;\na1[5] += 8 * a3;\nif ( a1[5] < 8 * a3 )\n++a1[6];\na1[6] += a3 >> 29;\nif ( v5 + a3 <= 0x3F )\n{\nn = 0;\n}\nelse\n{\nn = 64 - v5;\nmemcpy((char *)a1 + v5 + 28, a2, 64 - v5);\nsub_406C3F(a1, a1 + 7);\nwhile ( a3 > n + 63 )\n{\nsub_406C3F(a1, &a2[n]);\nn += 64;\n}\nv5 = 0;\n}\nreturn memcpy((char *)a1 + v5 + 28, &a2[n], a3 - n);\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[5], a1 + 7?\n", "output": "a1: context, SHA1_CTX* -> state, uint32[-]\na1[5]: context, SHA1_CTX* -> count, uint32[-]\na1 + 7: context, SHA1_CTX* -> buffer, unsigned char[-]", "predict": "a1: context, SHA1_CTX* -> state, uint32[-]\na1[5]: context, SHA1_CTX* -> count, uint32[-]\na1 + 7: context, SHA1_CTX* -> buffer, unsigned char[-]", "funname": "SHA1Update", "ground_truth": [["a1", "context", "SHA1_CTX*", "state", "uint32[-]"], ["a1[5]", "context", "SHA1_CTX*", "count", "uint32[-]"], ["a1 + 7", "context", "SHA1_CTX*", "buffer", "unsigned char[-]"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408919"}
{"input": "```\n__int64 __fastcall sub_40D215(__int64 a1, __int64 a2)\n{\n__int64 result; // rax\nunsigned __int64 v3; // [rsp+10h] [rbp-20h]\nunsigned __int64 v4; // [rsp+18h] [rbp-18h]\nunsigned int v5; // [rsp+24h] [rbp-Ch]\nunsigned int v6; // [rsp+28h] [rbp-8h]\nint i; // [rsp+2Ch] [rbp-4h]\n\nif ( a1 && a2 )\n{\nif ( *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 16) )\n{\nif ( *(_DWORD *)(a1 + 16) )\n{\nv6 = -1;\nv5 = 1;\n}\nelse\n{\nv6 = 1;\nv5 = -1;\n}\nif ( *(_DWORD *)(a1 + 8) <= *(_DWORD *)(a2 + 8) )\n{\nif ( *(_DWORD *)(a1 + 8) >= *(_DWORD *)(a2 + 8) )\n{\nfor ( i = *(_DWORD *)(a1 + 8) - 1; i >= 0; --i )\n{\nv4 = *(_QWORD *)(*(_QWORD *)a1 + 8LL * i);\nv3 = *(_QWORD *)(*(_QWORD *)a2 + 8LL * i);\nif ( v4 > v3 )\nreturn v6;\nif ( v4 < v3 )\nreturn v5;\n}\nresult = 0LL;\n}\nelse\n{\nresult = v5;\n}\n}\nelse\n{\nresult = v6;\n}\n}\nelse if ( *(_DWORD *)(a1 + 16) )\n{\nresult = 0xFFFFFFFFLL;\n}\nelse\n{\nresult = 1LL;\n}\n}\nelse if ( a1 )\n{\nresult = 0xFFFFFFFFLL;\n}\nelse\n{\nresult = a2 != 0;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)a1, (_DWORD *)(a1 + 8), (_DWORD *)(a1 + 16), (_QWORD *)a2, (_DWORD *)(a2 + 8), (_DWORD *)(a2 + 16)?\n", "output": "(_QWORD *)a1: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, const BIGNUM* -> top, int\n(_DWORD *)(a1 + 16): a, const BIGNUM* -> neg, int\n(_QWORD *)a2: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): b, const BIGNUM* -> top, int\n(_DWORD *)(a2 + 16): b, const BIGNUM* -> neg, int", "predict": "(_QWORD *)a1: a, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, const BIGNUM* -> top, int\n(_DWORD *)(a1 + 16): a, const BIGNUM* -> neg, int\n(_QWORD *)a2: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): b, const BIGNUM* -> top, int\n(_DWORD *)(a2 + 16): b, const BIGNUM* -> neg, int", "funname": "BN_cmp", "ground_truth": [["(_QWORD *)a1", "a", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "a", "const BIGNUM*", "top", "int"], ["(_DWORD *)(a1 + 16)", "a", "const BIGNUM*", "neg", "int"], ["(_QWORD *)a2", "b", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a2 + 8)", "b", "const BIGNUM*", "top", "int"], ["(_DWORD *)(a2 + 16)", "b", "const BIGNUM*", "neg", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40D215"}
{"input": "```\n_BYTE *__fastcall sub_404C8D(_DWORD *a1, unsigned __int8 *a2, _BYTE *a3)\n{\nint v3; // ebx\nint v4; // ebx\nint v5; // ebx\nint v6; // ebx\nint v7; // ebx\nint v8; // ebx\nint v9; // ebx\nint v10; // ebx\nint v11; // ebx\nint v12; // ebx\nint v13; // ebx\nint v14; // ebx\nint v15; // ebx\nint v16; // ebx\nint v17; // ebx\nint v18; // ebx\nint v19; // ebx\nint v20; // ebx\nint v21; // ebx\nint v22; // ebx\nint v23; // ebx\nint v24; // ebx\nint v25; // ebx\nint v26; // ebx\n_BYTE *result; // rax\n_DWORD *v29; // [rsp+10h] [rbp-40h]\nunsigned int v30; // [rsp+20h] [rbp-30h]\nunsigned int v31; // [rsp+24h] [rbp-2Ch]\nunsigned int v32; // [rsp+28h] [rbp-28h]\nunsigned int v33; // [rsp+2Ch] [rbp-24h]\nint v34; // [rsp+34h] [rbp-1Ch]\nunsigned int v35; // [rsp+38h] [rbp-18h]\nunsigned int v36; // [rsp+38h] [rbp-18h]\nunsigned int v37; // [rsp+3Ch] [rbp-14h]\nunsigned int v38; // [rsp+3Ch] [rbp-14h]\nunsigned int v39; // [rsp+40h] [rbp-10h]\nunsigned int v40; // [rsp+40h] [rbp-10h]\nunsigned int v41; // [rsp+44h] [rbp-Ch]\nunsigned int v42; // [rsp+44h] [rbp-Ch]\n\nv29 = a1;\nv41 = a2[3] ^ (a2[2] << 8) ^ (a2[1] << 16) ^ (*a2 << 24) ^ *a1;\nv39 = a2[7] ^ (a2[6] << 8) ^ (a2[5] << 16) ^ (a2[4] << 24) ^ a1[1];\nv37 = a2[11] ^ (a2[10] << 8) ^ (a2[9] << 16) ^ (a2[8] << 24) ^ a1[2];\nv35 = a2[15] ^ (a2[14] << 8) ^ (a2[13] << 16) ^ (a2[12] << 24) ^ a1[3];\nv34 = 5;\nwhile ( 1 )\n{\nv3 = dword_40F4C0[HIBYTE(v41)];\nv4 = sub_4046BB(dword_40F4C0[BYTE2(v39)], 8) ^ v3;\nv5 = sub_4046BB(dword_40F4C0[BYTE1(v37)], 16) ^ v4;\nv33 = sub_4046BB(dword_40F4C0[(unsigned __int8)v35], 24) ^ v5 ^ v29[4];\nv6 = dword_40F4C0[HIBYTE(v39)];\nv7 = sub_4046BB(dword_40F4C0[BYTE2(v37)], 8) ^ v6;\nv8 = sub_4046BB(dword_40F4C0[BYTE1(v35)], 16) ^ v7;\nv32 = sub_4046BB(dword_40F4C0[(unsigned __int8)v41], 24) ^ v8 ^ v29[5];\nv9 = dword_40F4C0[HIBYTE(v37)];\nv10 = sub_4046BB(dword_40F4C0[BYTE2(v35)], 8) ^ v9;\nv11 = sub_4046BB(dword_40F4C0[BYTE1(v41)], 16) ^ v10;\nv31 = sub_4046BB(dword_40F4C0[(unsigned __int8)v39], 24) ^ v11 ^ v29[6];\nv12 = dword_40F4C0[HIBYTE(v35)];\nv13 = sub_4046BB(dword_40F4C0[BYTE2(v41)], 8) ^ v12;\nv14 = sub_4046BB(dword_40F4C0[BYTE1(v39)], 16) ^ v13;\nv30 = sub_4046BB(dword_40F4C0[(unsigned __int8)v37], 24) ^ v14 ^ v29[7];\nv29 += 8;\nif ( !--v34 )\nbreak;\nv15 = dword_40F4C0[HIBYTE(v33)];\nv16 = sub_4046BB(dword_40F4C0[BYTE2(v32)], 8) ^ v15;\nv17 = sub_4046BB(dword_40F4C0[BYTE1(v31)], 16) ^ v16;\nv41 = sub_4046BB(dword_40F4C0[(unsigned __int8)v30], 24) ^ v17 ^ *v29;\nv18 = dword_40F4C0[HIBYTE(v32)];\nv19 = sub_4046BB(dword_40F4C0[BYTE2(v31)], 8) ^ v18;\nv20 = sub_4046BB(dword_40F4C0[BYTE1(v30)], 16) ^ v19;\nv39 = sub_4046BB(dword_40F4C0[(unsigned __int8)v33], 24) ^ v20 ^ v29[1];\nv21 = dword_40F4C0[HIBYTE(v31)];\nv22 = sub_4046BB(dword_40F4C0[BYTE2(v30)], 8) ^ v21;\nv23 = sub_4046BB(dword_40F4C0[BYTE1(v33)], 16) ^ v22;\nv37 = sub_4046BB(dword_40F4C0[(unsigned __int8)v32], 24) ^ v23 ^ v29[2];\nv24 = dword_40F4C0[HIBYTE(v30)];\nv25 = sub_4046BB(dword_40F4C0[BYTE2(v33)], 8) ^ v24;\nv26 = sub_4046BB(dword_40F4C0[BYTE1(v32)], 16) ^ v25;\nv35 = sub_4046BB(dword_40F4C0[(unsigned __int8)v31], 24) ^ v26 ^ v29[3];\n}\nv42 = (unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v30]) ^ dword_40F4C0[BYTE1(v31)] & 0xFF00 ^ (dword_40F4C0[BYTE2(v32)] & 0xFF0000 | (dword_40F4C0[HIBYTE(v33)] << 8) & 0xFF000000) ^ *v29;\n*a3 = HIBYTE(v42);\na3[1] = BYTE2(v42);\na3[2] = BYTE1(v42);\na3[3] = v42;\nv40 = (unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v33]) ^ dword_40F4C0[BYTE1(v30)] & 0xFF00 ^ (dword_40F4C0[BYTE2(v31)] & 0xFF0000 | (dword_40F4C0[HIBYTE(v32)] << 8) & 0xFF000000) ^ v29[1];\na3[4] = HIBYTE(v40);\na3[5] = BYTE2(v40);\na3[6] = BYTE1(v40);\na3[7] = v40;\nv38 = (unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v32]) ^ dword_40F4C0[BYTE1(v33)] & 0xFF00 ^ (dword_40F4C0[BYTE2(v30)] & 0xFF0000 | (dword_40F4C0[HIBYTE(v31)] << 8) & 0xFF000000) ^ v29[2];\na3[8] = HIBYTE(v38);\na3[9] = BYTE2(v38);\na3[10] = BYTE1(v38);\na3[11] = v38;\nv36 = (unsigned __int8)BYTE1(dword_40F4C0[(unsigned __int8)v31]) ^ dword_40F4C0[BYTE1(v32)] & 0xFF00 ^ (dword_40F4C0[BYTE2(v33)] & 0xFF0000 | (dword_40F4C0[HIBYTE(v30)] << 8) & 0xFF000000) ^ v29[3];\na3[12] = HIBYTE(v36);\na3[13] = BYTE2(v36);\na3[14] = BYTE1(v36);\nresult = a3 + 15;\na3[15] = v36;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1], a1[2], a1[3], a2, a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8], a2[9], a2[10], a2[11], a2[12], a2[13], a2[14], a2[15], a3, a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8], a3[9], a3[10], a3[11], a3[12], a3[13], a3[14], a3 + 15?\n", "output": "a1: rk, const u32* -> -, const u32\na1[1]: rk, const u32* -> -, const u32\na1[2]: rk, const u32* -> -, const u32\na1[3]: rk, const u32* -> -, const u32\na2: pt, const u8* -> -, const u8\na2[1]: pt, const u8* -> -, const u8\na2[2]: pt, const u8* -> -, const u8\na2[3]: pt, const u8* -> -, const u8\na2[4]: pt, const u8* -> -, const u8\na2[5]: pt, const u8* -> -, const u8\na2[6]: pt, const u8* -> -, const u8\na2[7]: pt, const u8* -> -, const u8\na2[8]: pt, const u8* -> -, const u8\na2[9]: pt, const u8* -> -, const u8\na2[10]: pt, const u8* -> -, const u8\na2[11]: pt, const u8* -> -, const u8\na2[12]: pt, const u8* -> -, const u8\na2[13]: pt, const u8* -> -, const u8\na2[14]: pt, const u8* -> -, const u8\na2[15]: pt, const u8* -> -, const u8\na3: ct, u8* -> -, u8\na3[1]: ct, u8* -> -, u8\na3[2]: ct, u8* -> -, u8\na3[3]: ct, u8* -> -, u8\na3[4]: ct, u8* -> -, u8\na3[5]: ct, u8* -> -, u8\na3[6]: ct, u8* -> -, u8\na3[7]: ct, u8* -> -, u8\na3[8]: ct, u8* -> -, u8\na3[9]: ct, u8* -> -, u8\na3[10]: ct, u8* -> -, u8\na3[11]: ct, u8* -> -, u8\na3[12]: ct, u8* -> -, u8\na3[13]: ct, u8* -> -, u8\na3[14]: ct, u8* -> -, u8\na3 + 15: ct, u8* -> -, u8", "predict": "a1: rk, const u32* -> -, const u32\na1[1]: rk, const u32* -> -, const u32\na1[2]: rk, const u32* -> -, const u32\na1[3]: rk, const u32* -> -, const u32\na2: ct, const u8* -> -, const u8\na2[1]: ct, const u8* -> -, const u8\na2[2]: ct, const u8* -> -, const u8\na2[3]: ct, const u8* -> -, const u8\na2[4]: ct, const u8* -> -, const u8\na2[5]: ct, const u8* -> -, const u8\na2[6]: ct, const u8* -> -, const u8\na2[7]: ct, const u8* -> -, const u8\na2[8]: ct, const u8* -> -, const u8\na2[9]: ct, const u8* -> -, const u8\na2[10]: ct, const u8* -> -, const u8\na2[11]: ct, const u8* -> -, const u8\na2[12]: ct, const u8* -> -, const u8\na2[13]: ct, const u8* -> -, const u8\na2[14]: ct, const u8* -> -, const u8\na2[15]: ct, const u8* -> -, const u8\na3: pt, u8* -> -, u8\na3[1]: pt, u8* -> -, u8\na3[2]: pt, u8* -> -, u8\na3[3]: pt, u8* -> -, u8\na3[4]: pt, u8* -> -, u8\na3[5]: pt, u8* -> -, u8\na3[6]: pt, u8* -> -, u8\na3[7]: pt, u8* -> -, u8\na3[8]: pt, u8* -> -, u8\na3[9]: pt, u8* -> -, u8\na3[10]: pt, u8* -> -, u8\na3[11]: pt, u8* -> -, u8\na3[12]: pt, u8* -> -, u8\na3[13]: pt, u8* -> -, u8\na3[14]: pt, u8* -> -, u8\na3 + 15: pt, u8* -> -, u8", "funname": "rijndaelEncrypt", "ground_truth": [["a1", "rk", "const u32*", "-", "const u32"], ["a1[1]", "rk", "const u32*", "-", "const u32"], ["a1[2]", "rk", "const u32*", "-", "const u32"], ["a1[3]", "rk", "const u32*", "-", "const u32"], ["a2", "pt", "const u8*", "-", "const u8"], ["a2[1]", "pt", "const u8*", "-", "const u8"], ["a2[2]", "pt", "const u8*", "-", "const u8"], ["a2[3]", "pt", "const u8*", "-", "const u8"], ["a2[4]", "pt", "const u8*", "-", "const u8"], ["a2[5]", "pt", "const u8*", "-", "const u8"], ["a2[6]", "pt", "const u8*", "-", "const u8"], ["a2[7]", "pt", "const u8*", "-", "const u8"], ["a2[8]", "pt", "const u8*", "-", "const u8"], ["a2[9]", "pt", "const u8*", "-", "const u8"], ["a2[10]", "pt", "const u8*", "-", "const u8"], ["a2[11]", "pt", "const u8*", "-", "const u8"], ["a2[12]", "pt", "const u8*", "-", "const u8"], ["a2[13]", "pt", "const u8*", "-", "const u8"], ["a2[14]", "pt", "const u8*", "-", "const u8"], ["a2[15]", "pt", "const u8*", "-", "const u8"], ["a3", "ct", "u8*", "-", "u8"], ["a3[1]", "ct", "u8*", "-", "u8"], ["a3[2]", "ct", "u8*", "-", "u8"], ["a3[3]", "ct", "u8*", "-", "u8"], ["a3[4]", "ct", "u8*", "-", "u8"], ["a3[5]", "ct", "u8*", "-", "u8"], ["a3[6]", "ct", "u8*", "-", "u8"], ["a3[7]", "ct", "u8*", "-", "u8"], ["a3[8]", "ct", "u8*", "-", "u8"], ["a3[9]", "ct", "u8*", "-", "u8"], ["a3[10]", "ct", "u8*", "-", "u8"], ["a3[11]", "ct", "u8*", "-", "u8"], ["a3[12]", "ct", "u8*", "-", "u8"], ["a3[13]", "ct", "u8*", "-", "u8"], ["a3[14]", "ct", "u8*", "-", "u8"], ["a3 + 15", "ct", "u8*", "-", "u8"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "404C8D"}
{"input": "```\n__int64 __fastcall sub_40B381(__int64 a1, _QWORD *a2, int a3, _QWORD *a4, int a5)\n{\n__int64 result; // rax\n_QWORD *v6; // [rsp+0h] [rbp-50h]\nint v7; // [rsp+8h] [rbp-48h]\nint v8; // [rsp+8h] [rbp-48h]\nint v9; // [rsp+8h] [rbp-48h]\nint v10; // [rsp+8h] [rbp-48h]\nunsigned int v11; // [rsp+Ch] [rbp-44h]\n_QWORD *v12; // [rsp+10h] [rbp-40h]\n__int64 v13; // [rsp+18h] [rbp-38h]\n__int64 *v14; // [rsp+38h] [rbp-18h]\n\nv13 = a1;\nv12 = a2;\nv11 = a3;\nv6 = a4;\nv7 = a5;\nif ( a3 < a5 )\n{\nv11 = a5;\nv7 = a3;\nv12 = a4;\nv6 = a2;\n}\nv14 = (__int64 *)(8LL * (int)v11 + a1);\nresult = sub_40BB0A(a1, v12, v11, *v6);\n*v14 = result;\nwhile ( 1 )\n{\nv8 = v7 - 1;\nif ( v8 <= 0 )\nbreak;\nresult = sub_40B510(v13 + 8, v12, v11, v6[1]);\nv14[1] = result;\nv9 = v8 - 1;\nif ( v9 <= 0 )\nbreak;\nresult = sub_40B510(v13 + 16, v12, v11, v6[2]);\nv14[2] = result;\nv10 = v9 - 1;\nif ( v10 <= 0 )\nbreak;\nresult = sub_40B510(v13 + 24, v12, v11, v6[3]);\nv14[3] = result;\nv7 = v10 - 1;\nif ( v7 <= 0 )\nbreak;\nresult = sub_40B510(v13 + 32, v12, v11, v6[4]);\nv14[4] = result;\nv14 += 4;\nv13 += 32LL;\nv6 += 4;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:v14, v14[1], v14[2], v14[3], v14[4], v6, v6[1], v6[2], v6[3], v6[4]?\n", "output": "v14: rr, long unsigned int* -> -, long unsigned int\nv14[1]: rr, long unsigned int* -> -, long unsigned int\nv14[2]: rr, long unsigned int* -> -, long unsigned int\nv14[3]: rr, long unsigned int* -> -, long unsigned int\nv14[4]: rr, long unsigned int* -> -, long unsigned int\nv6: b, long unsigned int* -> -, long unsigned int\nv6[1]: b, long unsigned int* -> -, long unsigned int\nv6[2]: b, long unsigned int* -> -, long unsigned int\nv6[3]: b, long unsigned int* -> -, long unsigned int\nv6[4]: b, long unsigned int* -> -, long unsigned int", "predict": "v14: rr, long unsigned int* -> -, long unsigned int\nv14[1]: rr, long unsigned int* -> -, long unsigned int\nv14[2]: rr, long unsigned int* -> -, long unsigned int\nv14[3]: rr, long unsigned int* -> -, long unsigned int\nv14[4]: rr, long unsigned int* -> -, long unsigned int\nv6: b, long unsigned int* -> -, long unsigned int\nv6[1]: b, long unsigned int* -> -, long unsigned int\nv6[2]: b, long unsigned int* -> -, long unsigned int\nv6[3]: b, long unsigned int* -> -, long unsigned int\nv6[4]: b, long unsigned int* -> -, long unsigned int", "funname": "bn_mul_normal", "ground_truth": [["v14", "rr", "long unsigned int*", "-", "long unsigned int"], ["v14[1]", "rr", "long unsigned int*", "-", "long unsigned int"], ["v14[2]", "rr", "long unsigned int*", "-", "long unsigned int"], ["v14[3]", "rr", "long unsigned int*", "-", "long unsigned int"], ["v14[4]", "rr", "long unsigned int*", "-", "long unsigned int"], ["v6", "b", "long unsigned int*", "-", "long unsigned int"], ["v6[1]", "b", "long unsigned int*", "-", "long unsigned int"], ["v6[2]", "b", "long unsigned int*", "-", "long unsigned int"], ["v6[3]", "b", "long unsigned int*", "-", "long unsigned int"], ["v6[4]", "b", "long unsigned int*", "-", "long unsigned int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40B381"}
{"input": "```\n__int64 __fastcall sub_40CC70(__int64 a1, __int64 a2)\n{\nbool v3; // al\nint v4; // eax\n__int64 v5; // [rsp+18h] [rbp-38h]\n__int64 v6; // [rsp+20h] [rbp-30h]\n__int64 v7; // [rsp+28h] [rbp-28h]\n_QWORD *v8; // [rsp+38h] [rbp-18h]\n_QWORD *v9; // [rsp+40h] [rbp-10h]\nint i; // [rsp+4Ch] [rbp-4h]\n\nif ( a1 == a2 )\nreturn a1;\nif ( *(_DWORD *)(a2 + 8) <= *(_DWORD *)(a1 + 12) )\nv3 = a1 == 0;\nelse\nv3 = sub_40C9FA(a1, *(_DWORD *)(a2 + 8)) == 0;\nif ( v3 )\nreturn 0LL;\nv9 = *(_QWORD **)a1;\nv8 = *(_QWORD **)a2;\nfor ( i = *(int *)(a2 + 8) >> 2; i > 0; --i )\n{\nv7 = v8[1];\nv6 = v8[2];\nv5 = v8[3];\n*v9 = *v8;\nv9[1] = v7;\nv9[2] = v6;\nv9[3] = v5;\nv9 += 4;\nv8 += 4;\n}\nv4 = *(_DWORD *)(a2 + 8) & 3;\nif ( v4 == 3 )\n{\nv9[2] = v8[2];\nLABEL_16:\nv9[1] = v8[1];\ngoto LABEL_17;\n}\nif ( v4 != 1 )\n{\nif ( v4 != 2 )\ngoto LABEL_18;\ngoto LABEL_16;\n}\nLABEL_17:\n*v9 = *v8;\nLABEL_18:\n*(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);\nif ( !*(_DWORD *)(a1 + 8) )\n{\nif ( *(_QWORD *)a1 )\n**(_QWORD **)a1 = 0LL;\n}\n*(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);\nreturn a1;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD **)a1, (_DWORD *)(a1 + 8), (_DWORD *)(a1 + 12), (_DWORD *)(a1 + 16), (_QWORD **)a2, (_DWORD *)(a2 + 8), (_DWORD *)(a2 + 16), v8, v8[1], v8[2], v8[3], v9, v9[1], v9[2], v9[3]?\n", "output": "(_QWORD **)a1: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): a, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): a, BIGNUM* -> neg, int\n(_QWORD **)a2: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): b, const BIGNUM* -> top, int\n(_DWORD *)(a2 + 16): b, const BIGNUM* -> neg, int\nv8: B, const long unsigned int* -> -, const long unsigned int\nv8[1]: B, const long unsigned int* -> -, const long unsigned int\nv8[2]: B, const long unsigned int* -> -, const long unsigned int\nv8[3]: B, const long unsigned int* -> -, const long unsigned int\nv9: A, long unsigned int* -> -, long unsigned int\nv9[1]: A, long unsigned int* -> -, long unsigned int\nv9[2]: A, long unsigned int* -> -, long unsigned int\nv9[3]: A, long unsigned int* -> -, long unsigned int", "predict": "(_QWORD **)a1: a, BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a1 + 8): a, BIGNUM* -> top, int\n(_DWORD *)(a1 + 12): a, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 16): a, BIGNUM* -> neg, int\n(_QWORD **)a2: b, const BIGNUM* -> d, long unsigned int*\n(_DWORD *)(a2 + 8): b, const BIGNUM* -> top, int\n(_DWORD *)(a2 + 16): b, const BIGNUM* -> neg, int\nv8: B, const long unsigned int* -> -, const long unsigned int\nv8[1]: B, const long unsigned int* -> -, const long unsigned int\nv8[2]: B, const long unsigned int* -> -, const long unsigned int\nv8[3]: B, const long unsigned int* -> -, const long unsigned int\nv9: A, long unsigned int* -> -, long unsigned int\nv9[1]: A, long unsigned int* -> -, long unsigned int\nv9[2]: A, long unsigned int* -> -, long unsigned int\nv9[3]: A, long unsigned int* -> -, long unsigned int", "funname": "BN_copy", "ground_truth": [["(_QWORD **)a1", "a", "BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a1 + 8)", "a", "BIGNUM*", "top", "int"], ["(_DWORD *)(a1 + 12)", "a", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(a1 + 16)", "a", "BIGNUM*", "neg", "int"], ["(_QWORD **)a2", "b", "const BIGNUM*", "d", "long unsigned int*"], ["(_DWORD *)(a2 + 8)", "b", "const BIGNUM*", "top", "int"], ["(_DWORD *)(a2 + 16)", "b", "const BIGNUM*", "neg", "int"], ["v8", "B", "const long unsigned int*", "-", "const long unsigned int"], ["v8[1]", "B", "const long unsigned int*", "-", "const long unsigned int"], ["v8[2]", "B", "const long unsigned int*", "-", "const long unsigned int"], ["v8[3]", "B", "const long unsigned int*", "-", "const long unsigned int"], ["v9", "A", "long unsigned int*", "-", "long unsigned int"], ["v9[1]", "A", "long unsigned int*", "-", "long unsigned int"], ["v9[2]", "A", "long unsigned int*", "-", "long unsigned int"], ["v9[3]", "A", "long unsigned int*", "-", "long unsigned int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40CC70"}
{"input": "```\n_QWORD *__fastcall sub_4024F2(_QWORD *a1)\n{\n_QWORD *result; // rax\n\n*a1 = a1;\nresult = a1;\na1[1] = a1;\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[1]?\n", "output": "a1: list, list_head* -> next, list_head*\na1[1]: list, list_head* -> prev, list_head*", "predict": "a1: list, list_head* -> next, list_head*\na1[1]: list, list_head* -> prev, list_head*", "funname": "INIT_LIST_HEAD", "ground_truth": [["a1", "list", "list_head*", "next", "list_head*"], ["a1[1]", "list", "list_head*", "prev", "list_head*"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4024F2"}
{"input": "```\n__int64 __fastcall sub_408A49(__int64 a1, int *a2)\n{\nchar v3[8]; // [rsp+10h] [rbp-10h] BYREF\nint v4; // [rsp+18h] [rbp-8h]\nunsigned int i; // [rsp+1Ch] [rbp-4h]\n\nfor ( i = 0; i <= 7; ++i )\nv3[i] = (unsigned int)a2[(i <= 3) + 5] >> (8 * (~(_BYTE)i & 3));\nsub_408919(a2, byte_4102C1, 1u);\nwhile ( (a2[5] & 0x1F8) != 448 )\nsub_408919(a2, byte_4102C3, 1u);\nsub_408919(a2, v3, 8u);\nfor ( i = 0; i <= 0x13; ++i )\n*(_BYTE *)(i + a1) = (unsigned int)a2[i >> 2] >> (8 * (~(_BYTE)i & 3));\nv4 = 0;\ni = 0;\nmemset(a2 + 7, 0, 0x40uLL);\nmemset(a2, 0, 0x14uLL);\nmemset(a2 + 5, 0, 8uLL);\nmemset(v3, 0, sizeof(v3));\nreturn sub_406C3F(a2, a2 + 7);\n}\n```\nWhat are the variable name and type for the following memory accesses:a2, a2[5], a2 + 7?\n", "output": "a2: context, SHA1_CTX* -> state, uint32[-]\na2[5]: context, SHA1_CTX* -> count, uint32[-]\na2 + 7: context, SHA1_CTX* -> buffer, unsigned char[-]", "predict": "a2: context, SHA1_CTX* -> state, uint32[-]\na2[5]: context, SHA1_CTX* -> count, uint32[-]\na2 + 7: context, SHA1_CTX* -> buffer, unsigned char[-]", "funname": "SHA1Final", "ground_truth": [["a2", "context", "SHA1_CTX*", "state", "uint32[-]"], ["a2[5]", "context", "SHA1_CTX*", "count", "uint32[-]"], ["a2 + 7", "context", "SHA1_CTX*", "buffer", "unsigned char[-]"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "408A49"}
{"input": "```\n_DWORD *__fastcall sub_405EAD(__int64 a1, int a2)\n{\nuint32_t v2; // eax\n_DWORD *result; // rax\nuint32_t v4; // ecx\nint v5[6]; // [rsp+10h] [rbp-30h] BYREF\n_DWORD *v6; // [rsp+28h] [rbp-18h]\nint i; // [rsp+30h] [rbp-10h]\nuint32_t hostlong; // [rsp+34h] [rbp-Ch]\nunsigned __int8 *v9; // [rsp+38h] [rbp-8h]\n\nv6 = (_DWORD *)(a1 + 20);\nv9 = (unsigned __int8 *)(a1 + 20);\n*(_BYTE *)(a1 + 44) = -(char)(a2 + 25) & 0x3F;\nhostlong = *((unsigned __int8 *)v6 + 24) + a2 + 25;\n*(_DWORD *)(a1 + 4) = htonl(hostlong);\nv2 = sub_405DF7();\nv6[5] = htonl(v2);\nresult = sub_405E43(v6, v5, hostlong);\nfor ( i = 0; i <= 4; ++i )\n{\nv4 = htonl(v5[i]);\nresult = v6;\nv6[i] = v4;\n}\nwhile ( (int)hostlong > 0 )\n{\nresult = sub_404C8D(dword_414D80, v9, v9);\nv9 += 16;\nhostlong -= 16;\n}\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:(_DWORD *)(a1 + 4), v6, v6[5], (unsigned __int8 *)v6 + 24?\n", "output": "(_DWORD *)(a1 + 4): msg, ead_msg* -> len, uint32_t\nv6: enc, ead_msg_encrypted* -> hash, uint32_t[-]\nv6[5]: enc, ead_msg_encrypted* -> iv, uint32_t\n(unsigned __int8 *)v6 + 24: enc, ead_msg_encrypted* -> pad, uint8_t", "predict": "(_DWORD *)(a1 + 4): msg, ead_msg* -> len, uint32_t\nv6: enc, ead_msg_encrypted* -> hash, uint32_t[-]\nv6[5]: enc, ead_msg_encrypted* -> iv, uint32_t\n(unsigned __int8 *)v6 + 24: enc, ead_msg_encrypted* -> pad, uint8_t", "funname": "ead_encrypt_message", "ground_truth": [["(_DWORD *)(a1 + 4)", "msg", "ead_msg*", "len", "uint32_t"], ["v6", "enc", "ead_msg_encrypted*", "hash", "uint32_t[-]"], ["v6[5]", "enc", "ead_msg_encrypted*", "iv", "uint32_t"], ["(unsigned __int8 *)v6 + 24", "enc", "ead_msg_encrypted*", "pad", "uint8_t"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "405EAD"}
{"input": "```\n_DWORD *__fastcall sub_4088BF(_DWORD *a1)\n{\n_DWORD *result; // rax\n\n*a1 = 1732584193;\na1[1] = -271733879;\na1[2] = -1732584194;\na1[3] = 271733878;\na1[4] = -1009589776;\na1[6] = 0;\nresult = a1;\na1[5] = a1[6];\nreturn result;\n}\n```\nWhat are the variable name and type for the following memory accesses:a1, a1[5]?\n", "output": "a1: context, SHA1_CTX* -> state, uint32[-]\na1[5]: context, SHA1_CTX* -> count, uint32[-]", "predict": "a1: context, SHA1_CTX* -> state, uint32[-]\na1[5]: context, SHA1_CTX* -> count, uint32[-]", "funname": "SHA1Init", "ground_truth": [["a1", "context", "SHA1_CTX*", "state", "uint32[-]"], ["a1[5]", "context", "SHA1_CTX*", "count", "uint32[-]"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "4088BF"}
{"input": "```\nvoid __fastcall sub_40C867(__int64 a1)\n{\nint v1; // [rsp+1Ch] [rbp-4h]\n\nif ( a1 )\n{\nif ( *(_QWORD *)a1 )\n{\nmemset(*(void **)a1, 0, 8LL * *(int *)(a1 + 12));\nif ( (*(_DWORD *)(a1 + 20) & 2) == 0 )\nfree(*(void **)a1);\n}\nv1 = *(_DWORD *)(a1 + 20) & 1;\nmemset((void *)a1, 0, 0x18uLL);\nif ( v1 )\nfree((void *)a1);\n}\n}\n```\nWhat are the variable name and type for the following memory accesses:(_QWORD *)a1, (int *)(a1 + 12), (_DWORD *)(a1 + 20)?\n", "output": "(_QWORD *)a1: a, BIGNUM* -> d, long unsigned int*\n(int *)(a1 + 12): a, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 20): a, BIGNUM* -> flags, int", "predict": "(_QWORD *)a1: a, BIGNUM* -> d, long unsigned int*\n(int *)(a1 + 12): a, BIGNUM* -> dmax, int\n(_DWORD *)(a1 + 20): a, BIGNUM* -> flags, int", "funname": "BN_clear_free", "ground_truth": [["(_QWORD *)a1", "a", "BIGNUM*", "d", "long unsigned int*"], ["(int *)(a1 + 12)", "a", "BIGNUM*", "dmax", "int"], ["(_DWORD *)(a1 + 20)", "a", "BIGNUM*", "flags", "int"]], "proj": "coolsnowwolf/gargoyle", "bin": "6df0f62e3ac41390b2b280a4e68d934e13d10af667230d7998a353d0c4c5cc60", "fun_id": "40C867"}
